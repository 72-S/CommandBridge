This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
gradle/
  wrapper/
    gradle-wrapper.properties
paper/
  src/
    main/
      java/
        dev/
          consti/
            commandbridge/
              paper/
                command/
                  CommandExecutor.java
                  CommandForwarder.java
                  CommandRegistrar.java
                core/
                  Runtime.java
                  Startup.java
                utils/
                  CommandUtils.java
                  GeneralUtils.java
                  SchedulerAdapter.java
                  ScriptUtils.java
                websocket/
                  Client.java
                  Ping.java
                Main.java
      resources/
        bukkit-config.yml
        bukkit-example.yml
        paper-plugin.yml
        plugin.yml
  build.gradle.kts
velocity/
  src/
    main/
      java/
        dev/
          consti/
            commandbridge/
              velocity/
                command/
                  CommandDispatcher.java
                  CommandForwarder.java
                  CommandRegistrar.java
                core/
                  Runtime.java
                  Startup.java
                helper/
                  command/
                    ListCommand.java
                    ReloadCommand.java
                    StartCommand.java
                    StopCommand.java
                    VersionCommand.java
                  FailureChecker.java
                  HelpCommand.java
                  InternalRegistrar.java
                  StatusManager.java
                util/
                  GeneralUtils.java
                  ProxyUtils.java
                  ScriptUtils.java
                websocket/
                  HttpServer.java
                  Server.java
                Main.java
      resources/
        velocity-config.yml
        velocity-example.yml
  build.gradle.kts
wiki/
  getting-started/
    installation.md
    plugin-setup.md
    requirements.md
  other/
    contribution-guidelines.md
    data-collection.md
  troubleshooting/
    common-issues.md
    support-resources.md
  README.md
  SUMMARY.md
  use-cases.md
.gitignore
build.gradle.kts
CHANGELOG.md
gradlew
gradlew.bat
README.md
server.sh
settings.gradle.kts
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="paper/src/main/java/dev/consti/commandbridge/paper/command/CommandRegistrar.java">
package dev.consti.commandbridge.paper.command;

import java.util.ArrayList;
import java.util.List;

import dev.consti.commandbridge.paper.core.Runtime;
import dev.consti.foundationlib.logging.Logger;
import dev.consti.foundationlib.utils.ScriptManager;
import dev.jorel.commandapi.CommandAPI;
import dev.jorel.commandapi.CommandAPICommand;
import dev.jorel.commandapi.arguments.GreedyStringArgument;

public class CommandRegistrar {
    private final Logger logger;
    private final CommandForwarder forwarder;
    private final List<String> registeredCommands = new ArrayList<>();

    public CommandRegistrar(Logger logger) {
        this.logger = logger;
        this.forwarder = Runtime.getInstance().getForwarder();
    }

    

public void unregisterAllCommands() {
        for (String command : registeredCommands) {
            try {
                CommandAPI.unregister(command);
                logger.debug("Unregistered command: {}", command);
            } catch (Exception e) {
                logger.error("Failed to unregister command '{}' : {}",
                        command,
                        logger.getDebug() ? e : e.getMessage()
                );
            }
        }
        registeredCommands.clear();
        logger.info("All registered commands have been unregistered.");
    
}

public void registerCommand(ScriptManager.ScriptConfig script) {
        String commandName = script.getName();
        try {
            CommandAPICommand command = new CommandAPICommand(commandName)
                    .withOptionalArguments(new GreedyStringArgument("args"))
                            .executes((sender, args) -> {
                                String argsString = (String) args.get("args");
                                logger.debug("Command '{}' called with arguments: {}", commandName, argsString);
                                String[] splitArgs = argsString != null ? argsString.split(" ") : new String[0];
                                return forwarder.executeScriptCommands(sender, script, splitArgs);
                            });
            command.register();
            registeredCommands.add(commandName);
        } catch (Exception e) {
            logger.error(
                    "Failed to register command '{}' : {}",
                    commandName,
                    logger.getDebug() ? e : e.getMessage()
            );
        }
}

}
</file>

<file path="paper/src/main/java/dev/consti/commandbridge/paper/core/Runtime.java">
package dev.consti.commandbridge.paper.core;

import dev.consti.commandbridge.paper.Main;
import dev.consti.commandbridge.paper.command.CommandRegistrar;
import dev.consti.commandbridge.paper.utils.GeneralUtils;
import dev.consti.commandbridge.paper.utils.ScriptUtils;
import dev.consti.commandbridge.paper.websocket.Client;
import dev.consti.foundationlib.logging.Logger;
import dev.consti.foundationlib.utils.ConfigManager;
import dev.consti.commandbridge.paper.command.CommandExecutor;
import dev.consti.commandbridge.paper.command.CommandForwarder;

public class Runtime {
    private static Runtime instance;
    private Logger logger;
    private ConfigManager config;
    private ScriptUtils scriptUtils;
    private Client client;
    private Startup startup;
    private CommandForwarder forwarder;
    private CommandRegistrar registrar;
    private GeneralUtils generalUtils;
    private CommandExecutor commandExecutor;

    private Runtime() {}

    public static synchronized Runtime getInstance() {
        if (instance == null) {
            instance = new Runtime();
            instance.getLogger().debug("Runtime singleton instance initialized.");
        }
        return instance;
    }

    public synchronized Logger getLogger() {
        if (logger == null) {
            logger = new Logger("CommandBridge");
            logger.debug("Logger initialized.");
        }
        return logger;
    }

    public synchronized ConfigManager getConfig() {
        if (config == null) {
            config = new ConfigManager(getLogger(), "CommandBridge");
            getLogger().debug("ConfigManager initialized.");
        }
        return config;
    }

    public synchronized ScriptUtils getScriptUtils() {
        if (scriptUtils == null) {
            scriptUtils = new ScriptUtils(getLogger(), "CommandBridge");
            getLogger().debug("ScriptUtils initialized.");
        }
        return scriptUtils;
    }

    public synchronized Client getClient() {
        if (client == null) {
            client = new Client(getLogger(), getConfig().getKey("config.yml", "secret"));
            getLogger().debug("Server initialized.");
        }
        return client;
    }

    public synchronized Startup getStartup() {
        if (startup == null) {
            startup = new Startup(getLogger());
            getLogger().debug("Startup initialized.");
        }
        return startup;
    }

    public synchronized CommandForwarder getForwarder() {
        if (forwarder == null) {
            forwarder = new CommandForwarder(getLogger(), Main.getInstance());
            getLogger().debug("CommandHelper initialized.");
        }
        return forwarder;
    }

    public synchronized CommandRegistrar getRegistrar() {
        if (registrar == null) {
            registrar = new CommandRegistrar(getLogger());
            getLogger().debug("CommandRegistrar initialized.");
        }
        return registrar;
    }

    public synchronized GeneralUtils getGeneralUtils() {
        if (generalUtils == null) {
            generalUtils = new GeneralUtils(getLogger());
            getLogger().debug("GeneralUtils initialized.");
        }
        return generalUtils;
    }

    public synchronized CommandExecutor getCommandExecutor() {
        if (commandExecutor == null) {
            commandExecutor = new CommandExecutor();
            getLogger().debug("CommandExecutor initialized.");
        }
        return commandExecutor;
    }
}
</file>

<file path="paper/src/main/java/dev/consti/commandbridge/paper/utils/CommandUtils.java">
package dev.consti.commandbridge.paper.utils;

import java.lang.reflect.Field;

import org.bukkit.Bukkit;
import org.bukkit.command.Command;
import org.bukkit.command.CommandMap;
import org.bukkit.command.PluginCommand;

import dev.consti.commandbridge.paper.core.Runtime;

public class CommandUtils {
    private static CommandMap getCommandMap() {
        try {
            Field commandMapField = Bukkit.getServer().getClass().getDeclaredField("commandMap");
            commandMapField.setAccessible(true);
            return (CommandMap) commandMapField.get(Bukkit.getServer());
        } catch (Exception e) {
            Runtime.getInstance().getLogger().error("Error while accessing commandMap: {}", e);
            return null;
        }
    }

    public static boolean isCommandValid(String command) {
        String baseCommand = command.split(" ")[0];
        PluginCommand pluginCommand = Bukkit.getPluginCommand(baseCommand);
        if (pluginCommand != null) {
            return false;
        }

        CommandMap commandMap = getCommandMap();
        if (commandMap == null) {
            return false;
        }

        Command cmd = commandMap.getCommand(baseCommand);
        return cmd == null;
    }


}
</file>

<file path="paper/src/main/java/dev/consti/commandbridge/paper/utils/SchedulerAdapter.java">
package dev.consti.commandbridge.paper.utils;

import java.util.function.Consumer;

import org.bukkit.Bukkit;
import org.bukkit.plugin.java.JavaPlugin;
import org.jetbrains.annotations.NotNull;

import io.papermc.paper.threadedregions.scheduler.ScheduledTask;

public class SchedulerAdapter {
    private final JavaPlugin plugin;

    public SchedulerAdapter(JavaPlugin plugin) {
        this.plugin = plugin;
    }

    public void run(Runnable task) {
        if (isFolia()) {
            Bukkit.getGlobalRegionScheduler().execute(plugin, task);
        } else {
            Bukkit.getScheduler().runTask(plugin, task);
        }
    }

    public void runLater(Runnable task, long delayTicks) {
        if (isFolia()) {
            Bukkit.getGlobalRegionScheduler().runDelayed(plugin, (@NotNull Consumer<ScheduledTask>) task, delayTicks);
        } else {
            Bukkit.getScheduler().runTaskLater(plugin, task, delayTicks);
        }
    }

    public static boolean isFolia() {
        try {
            Class.forName("io.papermc.paper.threadedregions.RegionizedServer");
            return true;
        } catch (ClassNotFoundException e) {
            return false;
        }
    }
}
</file>

<file path="paper/src/main/java/dev/consti/commandbridge/paper/websocket/Ping.java">
package dev.consti.commandbridge.paper.websocket;

import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.net.URL;
import java.util.Timer;
import java.util.TimerTask;

import javax.net.ssl.HttpsURLConnection;
import javax.net.ssl.SSLContext;
import javax.net.ssl.TrustManager;
import javax.net.ssl.X509TrustManager;

import dev.consti.commandbridge.paper.core.Runtime;
import dev.consti.foundationlib.logging.Logger;
import dev.consti.foundationlib.utils.ConfigManager;

public class Ping {
    private static void startPing(Logger logger, Runnable onPong, String url, int port, int maxAttempts) {
        final int millis = 4000;

        Timer timer = new Timer();

        disableCertificateValidation();

        timer.scheduleAtFixedRate(new TimerTask() {
            int attempts = 0;

            @Override
            public void run() {
                attempts++;
                if (attempts > maxAttempts) {
                    logger.warn("Max reconnect attempts reached. Reconnect manual by running '/cbc reconnect'");
                    timer.cancel();
                    return;
                }

                try {
                    URL targetUrl = new URL("https://" + url + ":" + port + "/ping");
                    HttpsURLConnection conn = (HttpsURLConnection) targetUrl.openConnection();
                    conn.setRequestMethod("GET");
                    conn.setConnectTimeout(1500);
                    conn.setReadTimeout(1500);

                    logger.debug("Pinging WebsocketServer");

                    int responseCode = conn.getResponseCode();
                    if (responseCode == 200) {
                        BufferedReader in = new BufferedReader(new InputStreamReader(conn.getInputStream()));
                        String response = in.readLine();
                        in.close();

                        if ("pong".equalsIgnoreCase(response)) {
                            logger.info("Attempting to reconnect to the server!");
                            onPong.run();
                            timer.cancel();
                        }
                    }
                } catch (Exception e) {
                    // logger.error("Ping error: {}", e);
                }
            }
        }, 0, millis);
    }

    public static void reconnect(Logger logger) {
        ConfigManager config = Runtime.getInstance().getConfig();
        int attempts;
        try {
            attempts = Integer.parseInt(config.getKey("config.yml", "timeout")) / 4;
        } catch (RuntimeException e) {
            attempts = 120 / 4;
        }

        startPing(logger, () -> {
            Runtime.getInstance().getClient().disconnect();

            String host = config.getKey("config.yml", "remote");
            int port = Integer.parseInt(config.getKey("config.yml", "port"));

            try {
                Runtime.getInstance().getClient().connect(host, port);
                logger.info("Client reconnected successfully to {}:{}", host, port);
            } catch (Exception e) {
                logger.error("Client reconnection failed (but ping succeeded):", e);
            }

        }, config.getKey("config.yml", "remote"),
                Integer.parseInt(config.getKey("config.yml", "port")),
                attempts);
    }

    private static void disableCertificateValidation() {
        try {
            TrustManager[] trustAllCerts = new TrustManager[] {
                    new X509TrustManager() {
                        public java.security.cert.X509Certificate[] getAcceptedIssuers() {
                            return new java.security.cert.X509Certificate[0];
                        }

                        public void checkClientTrusted(java.security.cert.X509Certificate[] certs, String authType) {
                        }

                        public void checkServerTrusted(java.security.cert.X509Certificate[] certs, String authType) {
                        }
                    }
            };

            SSLContext sc = SSLContext.getInstance("TLS");
            sc.init(null, trustAllCerts, new java.security.SecureRandom());
            HttpsURLConnection.setDefaultSSLSocketFactory(sc.getSocketFactory());
            HttpsURLConnection.setDefaultHostnameVerifier((hostname, session) -> true);
        } catch (Exception e) {
            throw new RuntimeException("Failed to disable certificate validation", e);
        }
    }
}
</file>

<file path="velocity/src/main/java/dev/consti/commandbridge/velocity/command/CommandDispatcher.java">
package dev.consti.commandbridge.velocity.command;

import java.util.Optional;
import java.util.UUID;

import com.velocitypowered.api.proxy.Player;
import com.velocitypowered.api.proxy.ProxyServer;

import dev.consti.commandbridge.velocity.core.Runtime;
import dev.consti.commandbridge.velocity.util.ProxyUtils;
import dev.consti.foundationlib.json.MessageParser;
import dev.consti.foundationlib.logging.Logger;

public class CommandDispatcher {
    private final ProxyServer proxy;
    private final Logger logger;

    public CommandDispatcher() {
        this.proxy = ProxyUtils.getProxyServer();
        this.logger = Runtime.getInstance().getLogger();
    }

    public void dispatchCommand(String message) {
        MessageParser parser = new MessageParser(message);
        String command = parser.getBodyValueAsString("command");
        String target = parser.getBodyValueAsString("target");
        logger.info("Dispatching command: '{}' for target: {}", command, target);

        switch (target.toLowerCase()) {
            case "console" -> executeConsoleCommand(command);
            case "player" -> executePlayerCommand(parser, command);
            default -> logger.warn("Invalid target: {}", target);
        }
    }

    private void executeConsoleCommand(String command) {
        logger.debug("Executing command '{}' as console", command);
        proxy.getCommandManager()
                .executeAsync(proxy.getConsoleCommandSource(), command)
                .whenComplete((result, throwable) -> {
                    if (throwable != null) {
                        logger.error("Error executing console command: {}", throwable);
                    }
                });
    }

    private void executePlayerCommand(MessageParser parser, String command) {
        logger.debug("Executing command '{}' as player", command);
        String uuidStr = parser.getBodyValueAsString("uuid");
        String name = parser.getBodyValueAsString("name");

        try {
            UUID playerUuid = UUID.fromString(uuidStr);
            Optional<Player> playerOptional = proxy.getPlayer(playerUuid);

            if (playerOptional.isPresent()) {
                Player player = playerOptional.get();
                proxy.getCommandManager()
                        .executeAsync(player, command)
                        .whenComplete((result, throwable) -> {
                            if (throwable != null) {
                                logger.error("Error executing console command: {}", throwable);
                            }
                        });
            } else {
                logger.warn("Player '{}' not found or offline", name);
            }
        } catch (Exception e) {
            logger.error("Error while processing player: {}",
                    logger.getDebug() ? e : e.getMessage()
            );
        }
    }
}
</file>

<file path="velocity/src/main/java/dev/consti/commandbridge/velocity/util/ScriptUtils.java">
package dev.consti.commandbridge.velocity.util;

import dev.consti.commandbridge.velocity.command.CommandRegistrar;
import dev.consti.commandbridge.velocity.core.Runtime;
import dev.consti.foundationlib.logging.Logger;
import dev.consti.foundationlib.utils.ScriptManager;

public class ScriptUtils extends ScriptManager {
    private final Logger logger;
    private final CommandRegistrar registrar;

    public ScriptUtils(Logger logger, String pluginName) {
        super(logger, pluginName);
        this.logger = logger;
        this.registrar = Runtime.getInstance().getRegistrar();
    }

    @Override
    public void onFileProcessed(String fileName, ScriptConfig scriptConfig) {
        if (scriptConfig.isEnabled()) {
            logger.info("Loaded script: {}", fileName);
            try {
                registrar.registerCommand(getScriptConfig(fileName));
                logger.debug("Registered command: {}", scriptConfig.getName());
            } catch (Exception e) {
                logger.error("Failed to register script '{}' : {}",
                        scriptConfig.getName(),
                        logger.getDebug() ? e : e.getMessage()
                );
            }
        } else {
            logger.info("Skipped disabled script: {}", scriptConfig.getName());
        }
    }
}
</file>

<file path="wiki/getting-started/installation.md">
---
description: >-
  Installing CommandBridge is quick and simple. Follow these steps to get
  started
---

# 📩 Installation

### Setup **the Plugin**

1. Download the latest `CommandBridge-xxx-all.jar` from the [releases page](https://modrinth.com/plugin/commandbridge/versions).
2. Place the JAR file into the `plugins` folder on **both your Velocity and Paper servers**.
3. Restart **both** the **Velocity and Paper** server and let the plugin generate its configs.&#x20;

{% hint style="success" %}
No need for separate JARs - CommandBridge will automatically detect whether it’s running on Velocity or Paper.
{% endhint %}

***

### **Upgrading to Version 2.0.0**

If you’re upgrading from an older version of CommandBridge to version **2.0.0 or above**, follow these additional steps:

1. **Convert Scripts Manually**:
   * The script format has changed. You’ll need to manually convert your old scripts to the new format. You can see how to write the scripts [here](broken-reference).
2. **Regenerate `config.yml`**:
   * Delete your old `config.yml`.
   * Start the server to let the plugin generate a new configuration file.
   * Follow the [guide](broken-reference) on how to configure the plugin.

{% hint style="info" %}
Future updates will include an automatic script converter for easier upgrades.
{% endhint %}
</file>

<file path="wiki/getting-started/plugin-setup.md">
---
description: >-
  After installing the CommandBridge plugin and restarting your servers, follow
  this guide to configure it properly. This guide assumes you have restarted all
  servers with the plugin installed.
---

# ⚙️ Plugin setup

### **Important Information**

<table><thead><tr><th width="165">Clients</th><th width="161">Server</th></tr></thead><tbody><tr><td>Paper Servers</td><td>Velocity Server</td></tr></tbody></table>

In this guide, when referring to "clients," it means all the Paper servers connected to your Velocity server.

***

### **Verify File Generation**

After restarting your servers, the following files and folders should be generated:

**Paper Servers**

```markdown
paper/
└── plugins/
    └── CommandBridge/
        ├── config.yml             # Main configuration file for the Paper server
        └── scripts/               # Folder for script configurations
            └── example.yml        # Example script configuration
```

**Velocity Server**

<pre class="language-markdown"><code class="lang-markdown"><strong>velocity/
</strong>└── plugins/
    └── CommandBridge/
        ├── config.yml             # Main configuration file for the Velocity server
        ├── secret.key             # Secret key for authentication (only on Velocity)
        └── scripts/               # Folder for script configurations
            └── example.yml        # Example script configuration
</code></pre>

#### Key Notes:

* The `secret.key` file is **only generated on the Velocity server**
* Both Velocity and Paper servers have:
  * `config.yml`: Configuration file specific to each server
  * `scripts/`: A folder containing the `example.yml` script template

If these files and folders match your setup, proceed to the next steps. Otherwise, ensure the plugin is installed correctly.

***

### **Step 1: Setup the Secret Key**

1. **Open the `secret.key` file** in the Velocity `plugins/CommandBridge` folder.
2.  Copy the key and paste it into the `secret` field in the `config.yml` file of **all Paper** servers:

    ```yaml
    secret: "CHANGE_ME"
    ```

    Replace `"CHANGE_ME"` with the value from `secret.key`.

{% hint style="danger" %}
Do not share this key. Anyone with access to the key can connect to your CommandBridge server and execute commands.
{% endhint %}

***

### **Step 2: Set Up Client and Server IDs**

Each Paper server is a client and needs a unique identifier.

**On Paper**

*   In `config.yml`, set the `client-id` for each Paper server.\
    Ensure each client has a unique identifier. For example, if the server is called "lobby," set the `client-id` to `lobby`:

    ```yaml
    client-id: "lobby"
    ```

**On Velocity**

* In `config.yml`, set the `server-id`.\
  By default, this is set to `main`. You can leave this as is unless you’re connecting additional servers.

***

### **Step 3: Configure Velocity**

1. **Set the Host**
   * Open on Velocity `config.yml`.
   * Locate the `host` field. By default, this is set to `0.0.0.0`.
   * If you’re using a hosting provider, leave it as is.
   * If self-hosting, you can set it to `127.0.0.1` (localhost) if the server and clients run on the same machine.
2. **Open a Port**
   * Choose an unused **TCP port** for CommandBridge.
   *   Update the `port` field in `config.yml` with the open port.\
       Example:

       ```yaml
       port: 3000
       ```
   * **Self-Hosting:** Open the port on your machine. This depends on your OS and network configuration.
   * **Hosting Providers:** Use their control panel to open an additional port.
3. **Set the SAN (Subject Alternative Name)**
   * Locate the `san` field in `config.yml`.
   *   Add the **IP address** of your Velocity server or the domain name (without the port).\
       Example:

       ```yaml
       san: "152.248.198.124"
       ```

{% hint style="warning" %}
Do not include the **port** in the SAN value. For example, `152.248.198.124:3000` is incorrect.
{% endhint %}

***

### **Step 4: Configure Paper Clients**

1. **Set the Remote and Port**
   *   Set the `remote` field to the **IP address of the Velocity server** (without the port).\
       Example:

       ```yaml
       remote: "152.248.198.124"
       ```
   * Set the `port` field to match the port configured in the Velocity `config.yml`.

***

### **Step 5: Restart Servers**

Restart your servers in the following order:

1. **Restart Velocity first**.
2. Then, restart all connected Paper servers.

***

### **Validation**

While the servers are starting, check the Velocity console for logs like these:

```
[21:10:10 INFO] [CommandBridge]: New connection attempt from /127.0.0.1:42918
[21:10:10 INFO] [CommandBridge]: Client authenticated successfully: /127.0.0.1:42918
[21:10:10 INFO] [CommandBridge]: Added connected client: lobby
```

If these logs appear, your configuration is successful. If not, review the configuration files for errors.
</file>

<file path="wiki/getting-started/requirements.md">
---
description: >-
  Before installing CommandBridge, ensure that your server setup meets the
  following requirements. The plugin has specific dependencies and version
  requirements to function correctly.
---

# 📘 Requirements

[#summary-for-lazy-people](requirements.md#summary-for-lazy-people "mention")

{% hint style="warning" %}
For older plugin versions, please refer to the [legacy wiki](https://docs.old.huraxdax.club).
{% endhint %}

### **Java Requirements**

| Plugin version      | Java version |
| ------------------- | ------------ |
| 2.0.0 and above     | 21           |
| below 2.0.0 (1.8.4) | 17           |

### Minecraft Compatibility

| Plugin version      | Minecraft version |
| ------------------- | ----------------- |
| 2.0.0 and above     | 1.20.x - 1.21.x   |
| below 2.0.0 (1.8.4) | 1.20.x - 1.21.1   |

***

### **Permission Management**

CommandBridge requires a **permission plugin** to manage command execution effectively.

* **Recommended**: [LuckPerms](https://luckperms.net/) (highly compatible and actively maintained).
* **Required Setup**:
  * Install a permission plugin **on both the Velocity and Paper servers**.
  * Any permission plugin will work, but ensure it’s installed on both platforms.

***

### **Plugin Compatibility**

CommandBridge is a **cross-compatible plugin** designed to run on both **Velocity** and **Paper** servers using the same JAR file. Below are the specific compatibility details:

| Server Type                            | Compatibility       | Notes                                                                  |
| -------------------------------------- | ------------------- | ---------------------------------------------------------------------- |
| Velocity                               | ✅ Supported         | Fully supported. Designed for Velocity plugin loader.                  |
| Paper                                  | ✅ Supported         | Fully supported. Built on the Paper API.                               |
| Spigot                                 | ✅ Supported         | Supported via Paper compatibility.                                     |
| Bukkit                                 | ✅ Supported         | Supported via Paper compatibility.                                     |
| Folia (Paper Fork)                     | ✅ Supported         | Folia adds regionized multithreading. Supported, but may contain bugs. |
| Purpur (Paper Fork)                    | ⚠️ Not Fully Tested | Should work based on Paper, but not officially tested.                 |
| Tuinity (Paper Fork)                   | ⚠️ Not Fully Tested | May work, but not officially tested or guaranteed.                     |
| Cross-loaders (e.g., Velocity + Paper) | ⚠️ Not Tested       | May work, but cross-loader support is not officially tested.           |
| Modloaders (Forge/Fabric etc.)         | ❌ Not Supported     | Only plugin loaders are supported. No modloader compatibility.         |

### **Summary (for lazy people)**

| Requirement                 | Details                                                                                        |
| --------------------------- | ---------------------------------------------------------------------------------------------- |
| **Java Version**            | Java 21 (for 2.0.0+). For older plugin versions, use Java 17.                                  |
| **Minecraft Version**       | Supports Minecraft 1.20.x - 1.21.x. Older versions require the legacy plugin (latest: 1.8.4).  |
| **Permission Plugin**       | Required on both Velocity and Paper servers. Recommended: [LuckPerms](https://luckperms.net/). |
| **Server Type**             | Paper and Velocity servers are fully supported. Bukkit and Spigot are **not supported**.       |
| **Paper API Compatibility** | Ensure the server runs a compatible API version (1.21.x for 2.0.0+).                           |
| **Velocity and Forks**      | Fully supported without requiring a separate JAR file.                                         |
</file>

<file path="wiki/other/contribution-guidelines.md">
# 👨‍💻 Contribution Guidelines
</file>

<file path="wiki/other/data-collection.md">
# 🔢 Data collection
</file>

<file path="wiki/troubleshooting/common-issues.md">
# ❌ Common issues
</file>

<file path="wiki/troubleshooting/support-resources.md">
# 📭 Support resources
</file>

<file path="wiki/README.md">
---
description: >-
  Welcome to my documentation! This guide will help you install and configure
  the CommandBridge plugin.
---

# 👋 Welcome

{% hint style="warning" %}
This documentation applies **only to CommandBridge plugin versions 2.0.0 and above**.

If you are using an earlier version, please refer to the [legacy documentation](https://docs.old.huraxdax.club/).
{% endhint %}

### What This Documentation Covers

* [x] Quick Installation
* [x] Configuration Guide
* [x] Troubleshooting
* [ ] How to escape vim



### Why use CommandBridge?

CommandBridge is the easiest way to enable **real-time, cross-server communication** between Velocity and Paper servers.\
Seamlessly manage commands, automate tasks, and create a unified server experience.
</file>

<file path="wiki/use-cases.md">
---
description: >-
  CommandBridge shines in scenarios where you need cross-server communication to
  execute commands seamlessly. Below are practical scenarios where CommandBridge
  can be a game-changer.
---

# 🤖 Use cases

### <mark style="color:orange;">Example 1:</mark> Global `/hub` Command with Additional Actions

**Scenario**:\
You want to implement a global `/hub` command that works on **any server in your network**. When a player types `/hub`, they are:

1. **Teleported to the hub server** (handled by Velocity).
2. Once in the hub, a **Paper plugin plays background music** using the `/music` command.

**Problem**:

* The `/hub` command isn’t natively available on Paper servers.
* The `/music` command can only be executed on the hub server.

**Solution with CommandBridge**:\
CommandBridge lets you define the `/hub` command as follows:

1. The **player types `/hub`** on any server (Paper or Velocity).
2. **CommandBridge triggers the teleport** to the hub server using Velocity’s `/server hub` command.
3. Once the player is on the hub server, **CommandBridge automatically executes `/music`** as the player.

| Step                   | Action                                                 | Executed On        |
| ---------------------- | ------------------------------------------------------ | ------------------ |
| **Player runs `/hub`** | CommandBridge receives and processes the command.      | Velocity           |
| **Teleport to hub**    | Executes Velocity's `/server hub` command to teleport. | Velocity           |
| **Play music**         | Executes `/music` for the player after teleporting.    | Hub (Paper plugin) |

**Why Use CommandBridge?**

* **Global availability**: `/hub` works from any server in your network.
* **Multi-step execution**: Executes commands in sequence, even across servers.
* **Automation**: Automatically triggers the `/music` command without user intervention.

***

### <mark style="color:orange;">**Example 2:**</mark>**&#x20;Timed Gameplay with Return to Lobby**

**Scenario**:\
You have a **minigame server** where players have **15 minutes** to play. After their time is up, they must:

1. **Teleport back to the main lobby** (handled by Velocity).
2. A message should appear announcing their return, triggered on the minigame server.

**Problem**:

* Paper doesn’t support Velocity’s `/server` commands natively.
* The minigame server needs to trigger global actions without direct access to Velocity commands.

**Solution with CommandBridge**:

1. A **Paper plugin** on the minigame server triggers a CommandBridge-defined command, e.g., `/end-session`.
2. CommandBridge teleports the player to the lobby using Velocity’s `/server lobby`.
3. CommandBridge executes a follow-up `/broadcast` command on the minigame server, announcing their departure.

| Step                       | Action                                              | Executed On      |
| -------------------------- | --------------------------------------------------- | ---------------- |
| **Trigger `/end-session`** | Minigame plugin triggers the CommandBridge command. | Minigame (Paper) |
| **Teleport to lobby**      | Executes Velocity’s `/server lobby` command.        | Velocity         |
| **Announce return**        | Broadcasts a farewell message to players.           | Minigame (Paper) |

**Why Use CommandBridge?**

* **Seamless teleportation**: Coordinates actions across Velocity and Paper.
* **Custom workflows**: Chains actions like teleporting and messaging.

***

### <mark style="color:orange;">**Example 3:**</mark>**&#x20;Centralized Rewards with Conditional Actions**

**Scenario**:\
You’re running a **network-wide event** where players can earn rewards. After claiming their reward:

1. They are **teleported to a “rewards room” server**.
2. The server **gives them a diamond** automatically.
3. An announcement is broadcast **only on the rewards server**.

**Problem**:

* Bukkit plugins can’t trigger Velocity’s `/server` commands directly.
* Rewards actions need to be automated and localized.

**Solution with CommandBridge**:

1. Define a CommandBridge command, e.g., `/claim-reward`.
2. The command:
   * Teleports the player to the “rewards room” using Velocity’s `/server rewards`.
   * Executes `/give {player} diamond` on the rewards server (Paper).
   * Sends a local announcement using `/say {player} claimed their reward!`.

| Step                            | Action                                       | Executed On     |
| ------------------------------- | -------------------------------------------- | --------------- |
| **Player runs `/claim-reward`** | CommandBridge triggers the sequence.         | Any server      |
| **Teleport to rewards server**  | Executes `/server rewards`.                  | Velocity        |
| **Give diamond**                | Runs `/give {player} diamond`.               | Rewards (Paper) |
| **Local announcement**          | Sends `/say {player} claimed their reward!`. | Rewards (Paper) |

**Why Use CommandBridge?**

* **Cross-server coordination**: Automates actions across multiple servers.
* **Localized commands**: Keeps announcements server-specific while managing rewards globally.

***

### **When Should You Use CommandBridge?**&#x20;

CommandBridge is ideal if you:

* **Need global commands** that work on every server in your network.
* **Automate multi-step workflows**, such as teleportation and follow-up actions.
* **Coordinate cross-server actions** seamlessly between Velocity and Paper.
</file>

<file path=".gitignore">
.gradle
build/
!gradle/wrapper/gradle-wrapper.jar
!**/src/main/**/build/
!**/src/test/**/build/

### IntelliJ IDEA ###
.idea/modules.xml
.idea/jarRepositories.xml
.idea/compiler.xml
.idea/libraries/
.idea/workspace.xml
*.iws
*.iml
*.ipr
out/
!**/src/main/**/out/
!**/src/test/**/out/

### Eclipse ###
.apt_generated
.classpath
.factorypath
.project
.settings
.springBeans
.sts4-cache
bin/
!**/src/main/**/bin/
!**/src/test/**/bin/

### NetBeans ###
/nbproject/private/
/nbbuild/
/dist/
/nbdist/
/.nb-gradle/

### VS Code ###
.vscode/

### Mac OS ###
.DS_Store


kls_database.db
</file>

<file path="README.md">
### **CommandBridge**

This plugin connects **Velocity** and **Paper** servers seamlessly, enabling **cross-server command execution**. Here's what it does exactly:

- **Custom Scripts**: Define commands in scripts for both server types.  
- **Two-Way Communication**:  
   - Run a command on Velocity → Matching commands execute on Paper.  
   - Run a command on Paper → Matching commands execute on Velocity.  
- **WebSocket-Powered**: Ensures fast, reliable and **realtime** communication between servers.  
- **Placeholders Supported**: Use placeholders for dynamic command execution.  

With this plugin, you can create **global gameplay experiences** that feel smooth and connected!

---

### Requirements

**CommandBridge** v2.0.0 introduces new requirements and updates:  

- **Java 21 Required**: The server must run on Java 21.  
- **Minecraft Compatibility**: Fully compatible with Minecraft 1.21.x.  
- **Single JAR File**: Only download `CommandBridge-XXX-all.jar`.  
- **Dual Placement**: The JAR must be placed in both the target Paper server and the Velocity server to function.  
- **Plugin Compatibility**: Built for Paper servers, though it may work on other software (not tested).  

> **Important**: These requirements apply only to versions **2.0.0** and above.

---

### News

The **2.0.0 release** brings major updates and improvements:  

- **Rewritten Code**: Cleaner, faster, and more reliable.  
- **WebSocket Technology**: Replaces plugin messaging to fix issues where messages could not be sent if no players were online.  
- **Alpha Release**: Still in early stages, so expect some rough edges.  

---

### Installation (Short Version)

For detailed instructions, visit the [wiki](https://docs.old.huraxdax.club/) (currently outdated but new one is in progress, but the configuration is mostly the same). New one is in progess, you can read it [tho](https://docs.huraxdax.club).

1. **Add the JAR**: Place the plugin JAR in the `plugins` folder of both the Paper and Velocity servers.  
2. **Restart Servers**: Restart both servers. After the restart, a `secret.key` file will be generated in the Velocity server's `plugins/CommandBridge` folder.  
3. **Secure the Key**:  
   - Open `secret.key` on the Velocity server.  
   - Copy the key and paste it into the `secret` field in the `config.yml` of all Paper servers.  
   - **Do not share this key.**  
4. **Open a Port**:  
   - Choose an unused port for the Velocity server.  
   - Configure this port in the `config.yml` of both Velocity and Paper servers.  
5. **Set Server IP**:  
   - Find your Velocity server's IP address (plain IP, no domain).  
   - Update the `host` field in Velocity's `config.yml` and the `remote` field in all Paper servers with this IP.  
6. **Set Identifiers**:  
   - In Velocity: Set a `server-id` (any name you prefer).  
   - In Paper: Set a matching `client-id`.  
7. **Restart Order**: Restart the Velocity server **before** the Paper servers.  

After setup, you should see logs like this in the Velocity console:  
```plaintext
[21:10:10 INFO] [CommandBridge]: New connection attempt from /127.0.0.1:42918
[21:10:10 INFO] [CommandBridge]: Client authenticated successfully: /127.0.0.1:42918
[21:10:10 INFO] [CommandBridge]: Added connected client: lobby
```

Now you're ready to create scripts!  

---

### What Comes in the Future

Exciting features and improvements are planned for **CommandBridge**:

- **Multiple Velocity Server Support**: Connect additional Velocity servers to act as clients.  
- **PlaceholderAPI (PAPI) Support**: Unlock even more placeholders for greater flexibility.  
- **GUI Menu for Scripts**: Create and manage scripts with an easy-to-use graphical interface.  
- **Bug Fixes**: Continuous improvements to ensure stability and performance.  
- **Better Documentation**: Expanded guides and tutorials for easier setup and usage.  
- **Dump Command & Tools**: Integration with a website and Discord bot for troubleshooting and support.  
- **And More!**  

Stay tuned for updates and new features! 🎉  

---

### Help or Issues

- Report issues on [GitHub](https://github.com/72-S/CommandBridge/issues).  
- Join the [Discord server](https://discord.gg/QPqBYb44ce) for support.  

---

### Metrics Collection

This plugin collects anonymous server statistics via [bStats](https://bstats.org/), an open-source statistics service for Minecraft plugins. You can disable this in `plugins/bStats/config.yml`.  

![bStats](https://bstats.org/signatures/velocity/CommandBridge.svg)

---

### Contributing

Join the [Discord server](https://discord.gg/QPqBYb44ce) or visit the [GitHub](https://github.com/72-S/CommandBridge) for more information on contributing to the project.
</file>

<file path="paper/src/main/java/dev/consti/commandbridge/paper/utils/ScriptUtils.java">
package dev.consti.commandbridge.paper.utils;

import dev.consti.commandbridge.paper.Main;
import dev.consti.commandbridge.paper.command.CommandRegistrar;
import dev.consti.commandbridge.paper.core.Runtime;
import dev.consti.foundationlib.logging.Logger;
import dev.consti.foundationlib.utils.ScriptManager;

public class ScriptUtils extends ScriptManager {
    private final Logger logger;
    private final CommandRegistrar registrar;

    public ScriptUtils(Logger logger, String pluginName) {
        super(logger, pluginName);
        this.logger = logger;
        this.registrar = Runtime.getInstance().getRegistrar();
    }

    @Override
    public void onFileProcessed(String fileName, ScriptConfig scriptConfig) {
        if (scriptConfig.isEnabled()) {
            logger.info("Loaded script: {}", fileName);
            try {
                registrar.registerCommand(getScriptConfig(fileName));
                logger.debug("Registered command: {}", scriptConfig.getName());
            } catch (Exception e) {
                logger.error("Failed to register script '{}' : {}",
                        scriptConfig.getName(),
                        logger.getDebug() ? e : e.getMessage()
                );
            }
        } else {
            logger.info("Skipped disabled script: {}", scriptConfig.getName());
        }
    }

    public void unloadCommands(Runnable callback) {
        new SchedulerAdapter(Main.getInstance())
                .run(
                        () -> {
                            logger.debug("Running on thread (unload): {}", Thread.currentThread().getName());
                            Runtime.getInstance().getRegistrar().unregisterAllCommands();
                            logger.debug("All commands have been unloaded");
                            callback.run();
                });
    }




}
</file>

<file path="velocity/src/main/java/dev/consti/commandbridge/velocity/helper/command/StartCommand.java">
package dev.consti.commandbridge.velocity.helper.command;

import com.mojang.brigadier.builder.LiteralArgumentBuilder;
import com.velocitypowered.api.command.CommandSource;
import dev.consti.commandbridge.velocity.core.Runtime;
import dev.consti.foundationlib.logging.Logger;
import net.kyori.adventure.text.Component;
import net.kyori.adventure.text.format.NamedTextColor;


public class StartCommand {
    public static LiteralArgumentBuilder<CommandSource> build(Logger logger) {
        return LiteralArgumentBuilder.<CommandSource>literal("start")
                .executes(context -> {
                    CommandSource source = context.getSource();
                    if (!source.hasPermission("commandbridge.admin")) {
                        source.sendMessage(Component.text("You do not have permission to start the WebSocket server", NamedTextColor.RED));
                        return 0;
                    }
                    Runtime.getInstance().getServer().startServer(
                    Integer.parseInt(Runtime.getInstance().getConfig().getKey("config.yml", "port")),
                    Runtime.getInstance().getConfig().getKey("config.yml", "host"),
                    Runtime.getInstance().getConfig().getKey("config.yml", "san")
            );

                    source.sendMessage(Component.text("WebSocket Server started").color(NamedTextColor.GREEN));
                    return 1;
                });
    }
}
</file>

<file path="velocity/src/main/java/dev/consti/commandbridge/velocity/helper/command/VersionCommand.java">
package dev.consti.commandbridge.velocity.helper.command;

import com.mojang.brigadier.builder.LiteralArgumentBuilder;
import com.velocitypowered.api.command.CommandSource;
import dev.consti.commandbridge.velocity.Main;
import dev.consti.foundationlib.logging.Logger;
import dev.consti.foundationlib.utils.VersionChecker;
import net.kyori.adventure.text.Component;
import net.kyori.adventure.text.event.ClickEvent;
import net.kyori.adventure.text.format.NamedTextColor;
import net.kyori.adventure.text.format.TextDecoration;


public class VersionCommand {
    public static LiteralArgumentBuilder<CommandSource> build(Logger logger) {
        return LiteralArgumentBuilder.<CommandSource>literal("version")
                .executes(context -> {
                    CommandSource source = context.getSource();
                    if (!source.hasPermission("commandbridge.admin")) {
                        source.sendMessage(Component.text("You do not have permission to check the version", NamedTextColor.RED));
                        return 0;
                    }

                    String currentVersion = Main.getVersion();
                    source.sendMessage(Component.text("Checking for updates...").color(NamedTextColor.YELLOW));
                    logger.debug("VersionCommand executed by: {}", source);

                    new Thread(() -> {
                        String latestVersion = VersionChecker.getLatestVersion();

                        if (latestVersion == null) {
                            source.sendMessage(
                                    Component.text("Unable to check for updates").color(NamedTextColor.RED));
                            logger.warn("Failed to retrieve latest version for update check");
                            return;
                        }

                        logger.debug("Current version: {}, Latest version: {}", currentVersion, latestVersion);

                        if (VersionChecker.isNewerVersion(latestVersion, currentVersion)) {
                            source.sendMessage(
                                    Component.text("A new version is available: " + latestVersion)
                                            .color(NamedTextColor.RED));
                            source.sendMessage(
                                    Component.text("Please download the latest release: ")
                                            .append(
                                                    Component.text("here")
                                                            .color(NamedTextColor.BLUE)
                                                            .decorate(TextDecoration.UNDERLINED)
                                                            .clickEvent(ClickEvent.openUrl(VersionChecker.getDownloadUrl()))));
                            logger.warn("A newer version is available: {}", latestVersion);
                        } else {
                            source.sendMessage(
                                    Component.text("You are running the latest version: " + currentVersion)
                                            .color(NamedTextColor.GREEN));
                        }
                    }).start();

                    return 1;
                });
    }
}
</file>

<file path="velocity/src/main/java/dev/consti/commandbridge/velocity/helper/StatusManager.java">
package dev.consti.commandbridge.velocity.helper;

import dev.consti.commandbridge.velocity.core.Runtime;
import dev.consti.foundationlib.logging.Logger;

import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;

public class StatusManager {
    private final Logger logger;
    private final Map<String, String> statusMap = new HashMap<>();
    private final Set<String> connectedClients = Runtime.getInstance().getServer().getConnectedClients();

    public StatusManager(Logger logger) {
        this.logger = logger;
    }

    public void addClientToStatus(String clientId, String status) {
        statusMap.put(clientId, status);
        logger.debug("Updated statusMap: {}", statusMap);
    }

    public void clearStatusMap() {
        statusMap.clear();
    }

    public String checkForFailures() {
        logger.debug("Checking for failures...");

        List<String> missingClients = connectedClients.stream()
                .filter(client -> !statusMap.containsKey(client))
                .toList();

        if (!missingClients.isEmpty()) {
            String missingClientString = String.join(", ", missingClients);
            logger.warn("Waiting for responses from clients: {}", missingClientString);
            return "Missing responses from: " + missingClientString;
        }

        String failedClients = statusMap.entrySet().stream()
                .filter(entry -> !"success".equals(entry.getValue()))
                .map(Map.Entry::getKey)
                .reduce((a, b) -> a + ", " + b)
                .orElse(null);

        if (failedClients != null) {
            logger.error("Failure detected on clients: {}", failedClients);
            return "Failure detected on: " + failedClients;
        }

        logger.debug("No failures detected. All clients are operational");
        return null;
    }
}
</file>

<file path="velocity/src/main/java/dev/consti/commandbridge/velocity/util/GeneralUtils.java">
package dev.consti.commandbridge.velocity.util;

import com.velocitypowered.api.command.CommandMeta;
import com.velocitypowered.api.command.CommandSource;
import com.velocitypowered.api.proxy.ProxyServer;
import dev.consti.commandbridge.velocity.Main;
import dev.consti.commandbridge.velocity.core.Runtime;
import dev.consti.commandbridge.velocity.helper.InternalRegistrar;
import dev.consti.commandbridge.velocity.helper.FailureChecker;
import dev.consti.commandbridge.velocity.helper.StatusManager;
import dev.consti.foundationlib.logging.Logger;

import java.util.Set;
import java.util.concurrent.TimeUnit;

public class GeneralUtils {
    private final Logger logger;
    private final ProxyServer proxy;
    private final Main plugin;
    private final StatusManager statusManager;
    private final Set<String> connectedClients;
    private CommandMeta meta;

    public GeneralUtils(Logger logger) {
        this.logger = logger;
        this.proxy = ProxyUtils.getProxyServer();
        this.plugin = Main.getInstance();
        this.connectedClients = Runtime.getInstance().getServer().getConnectedClients();
        this.statusManager = new StatusManager(logger);
    }

    public void addClientToStatus(String clientId, String status) {
        statusManager.addClientToStatus(clientId, status);
    }

    public void startFailureCheck(CommandSource source) {
        statusManager.clearStatusMap();
        FailureChecker checkTask = new FailureChecker(logger, proxy, plugin, statusManager, source);
        try {
            proxy.getScheduler().buildTask(plugin, checkTask).delay(1, TimeUnit.SECONDS).schedule();
        } catch (Exception e) {
            logger.error("Failed to schedule the reload check task: {}", logger.getDebug() ? e : e.getMessage());
            source.sendMessage(
                    net.kyori.adventure.text.Component.text("Reload command failed: Unable to start the failure check")
                            .color(net.kyori.adventure.text.format.NamedTextColor.RED));
        }
    }

    public void registerCommands() {
        InternalRegistrar registrar = new InternalRegistrar(logger, proxy, plugin, connectedClients);
        registrar.registerCommands();
    }

    public CommandMeta getMeta() {
        return meta;
    }

    public void setMeta(CommandMeta commandMeta) {
        meta = commandMeta;
    }

    public void unregisterCommands() {
        proxy.getCommandManager().unregister(meta);
    }
}
</file>

<file path="velocity/src/main/java/dev/consti/commandbridge/velocity/util/ProxyUtils.java">
package dev.consti.commandbridge.velocity.util;

import com.velocitypowered.api.proxy.ProxyServer;

import dev.consti.commandbridge.velocity.core.Runtime;
import dev.consti.foundationlib.logging.Logger;

public class ProxyUtils {
    private static ProxyServer proxyServer;
    private static final Logger logger = Runtime.getInstance().getLogger();

    private ProxyUtils() {
    }

    public static synchronized void setProxyServer(ProxyServer server) {
        if (proxyServer == null) {
            proxyServer = server;
        } else {
            logger.error("Attempted to set ProxyServer instance more than once!");
            throw new IllegalStateException("Proxy instance is already set!");
        }
    }

    public static synchronized ProxyServer getProxyServer() {
        if (proxyServer == null) {
            logger.error("Attempted to retrieve ProxyServer instance before initialization!");
            throw new IllegalStateException("Proxy instance is not initialized!");
        }
        return proxyServer;
    }
}
</file>

<file path="velocity/src/main/java/dev/consti/commandbridge/velocity/websocket/HttpServer.java">
package dev.consti.commandbridge.velocity.websocket;

import dev.consti.foundationlib.logging.Logger;
import io.netty.channel.ChannelHandlerContext;
import io.netty.channel.SimpleChannelInboundHandler;
import io.netty.channel.ChannelHandler.Sharable;
import io.netty.handler.codec.http.DefaultFullHttpResponse;
import io.netty.handler.codec.http.FullHttpRequest;
import io.netty.handler.codec.http.FullHttpResponse;
import io.netty.handler.codec.http.HttpHeaderNames;
import io.netty.handler.codec.http.HttpResponseStatus;
import static io.netty.handler.codec.http.HttpResponseStatus.*;
import static io.netty.handler.codec.http.HttpVersion.HTTP_1_1;


@Sharable
public class HttpServer extends SimpleChannelInboundHandler<FullHttpRequest>{
    private Logger logger;

    
    public HttpServer(Logger logger) {
        this.logger = logger;
    }


    @Override
    protected void channelRead0(ChannelHandlerContext ctx, FullHttpRequest msg) {
        String uri = msg.uri();
        logger.debug("Incoming HTTP request to: {}", uri);

        if ("/ping".equalsIgnoreCase(uri)) {
            sendTextResponse(ctx, OK, "pong");
        } else if ("websocket".equalsIgnoreCase(msg.headers().get(HttpHeaderNames.UPGRADE))) {
            ctx.fireChannelRead(msg.retain());
        } else {
            sendTextResponse(ctx, NOT_FOUND, "Not Found");
        }
    }

    private void sendTextResponse(ChannelHandlerContext ctx, HttpResponseStatus status, String content) {
        FullHttpResponse response = new DefaultFullHttpResponse(
            HTTP_1_1,
            status,
            ctx.alloc().buffer().writeBytes(content.getBytes())
        );
        response.headers().set(HttpHeaderNames.CONTENT_TYPE, "text/plain");
        response.headers().set(HttpHeaderNames.CONTENT_LENGTH, response.content().readableBytes());
        ctx.writeAndFlush(response);
    }

    @Override
    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {
        logger.error("Error in HttpServer handler: {}", logger.getDebug() ? cause : cause.getMessage());
        ctx.close();
    }

}
</file>

<file path="gradlew.bat">
@rem
@rem Copyright 2015 the original author or authors.
@rem
@rem Licensed under the Apache License, Version 2.0 (the "License");
@rem you may not use this file except in compliance with the License.
@rem You may obtain a copy of the License at
@rem
@rem      https://www.apache.org/licenses/LICENSE-2.0
@rem
@rem Unless required by applicable law or agreed to in writing, software
@rem distributed under the License is distributed on an "AS IS" BASIS,
@rem WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@rem See the License for the specific language governing permissions and
@rem limitations under the License.
@rem
@rem SPDX-License-Identifier: Apache-2.0
@rem

@if "%DEBUG%"=="" @echo off
@rem ##########################################################################
@rem
@rem  Gradle startup script for Windows
@rem
@rem ##########################################################################

@rem Set local scope for the variables with windows NT shell
if "%OS%"=="Windows_NT" setlocal

set DIRNAME=%~dp0
if "%DIRNAME%"=="" set DIRNAME=.
@rem This is normally unused
set APP_BASE_NAME=%~n0
set APP_HOME=%DIRNAME%

@rem Resolve any "." and ".." in APP_HOME to make it shorter.
for %%i in ("%APP_HOME%") do set APP_HOME=%%~fi

@rem Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
set DEFAULT_JVM_OPTS="-Xmx64m" "-Xms64m"

@rem Find java.exe
if defined JAVA_HOME goto findJavaFromJavaHome

set JAVA_EXE=java.exe
%JAVA_EXE% -version >NUL 2>&1
if %ERRORLEVEL% equ 0 goto execute

echo. 1>&2
echo ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH. 1>&2
echo. 1>&2
echo Please set the JAVA_HOME variable in your environment to match the 1>&2
echo location of your Java installation. 1>&2

goto fail

:findJavaFromJavaHome
set JAVA_HOME=%JAVA_HOME:"=%
set JAVA_EXE=%JAVA_HOME%/bin/java.exe

if exist "%JAVA_EXE%" goto execute

echo. 1>&2
echo ERROR: JAVA_HOME is set to an invalid directory: %JAVA_HOME% 1>&2
echo. 1>&2
echo Please set the JAVA_HOME variable in your environment to match the 1>&2
echo location of your Java installation. 1>&2

goto fail

:execute
@rem Setup the command line

set CLASSPATH=%APP_HOME%\gradle\wrapper\gradle-wrapper.jar


@rem Execute Gradle
"%JAVA_EXE%" %DEFAULT_JVM_OPTS% %JAVA_OPTS% %GRADLE_OPTS% "-Dorg.gradle.appname=%APP_BASE_NAME%" -classpath "%CLASSPATH%" org.gradle.wrapper.GradleWrapperMain %*

:end
@rem End local scope for the variables with windows NT shell
if %ERRORLEVEL% equ 0 goto mainEnd

:fail
rem Set variable GRADLE_EXIT_CONSOLE if you need the _script_ return code instead of
rem the _cmd.exe /c_ return code!
set EXIT_CODE=%ERRORLEVEL%
if %EXIT_CODE% equ 0 set EXIT_CODE=1
if not ""=="%GRADLE_EXIT_CONSOLE%" exit %EXIT_CODE%
exit /b %EXIT_CODE%

:mainEnd
if "%OS%"=="Windows_NT" endlocal

:omega
</file>

<file path="gradle/wrapper/gradle-wrapper.properties">
distributionBase=GRADLE_USER_HOME
distributionPath=wrapper/dists
distributionUrl=https\://services.gradle.org/distributions/gradle-8.10-bin.zip
networkTimeout=10000
validateDistributionUrl=true
zipStoreBase=GRADLE_USER_HOME
zipStorePath=wrapper/dists
</file>

<file path="paper/src/main/java/dev/consti/commandbridge/paper/command/CommandExecutor.java">
package dev.consti.commandbridge.paper.command;

import java.util.Optional;
import java.util.UUID;

import org.bukkit.Bukkit;
import org.bukkit.command.CommandSender;
import org.bukkit.entity.Player;

import dev.consti.commandbridge.paper.Main;
import dev.consti.commandbridge.paper.core.Runtime;
import dev.consti.commandbridge.paper.utils.CommandUtils;
import dev.consti.commandbridge.paper.utils.SchedulerAdapter;
import dev.consti.foundationlib.json.MessageParser;
import dev.consti.foundationlib.logging.Logger;

public class CommandExecutor {
    private final Main plugin;
    private final Logger logger;

    public CommandExecutor() {
        this.plugin = Main.getInstance();
        this.logger = Runtime.getInstance().getLogger();
    }

    public void dispatchCommand(String message) {
        MessageParser parser = new MessageParser(message);
        String serverId = Runtime.getInstance().getConfig().getKey("config.yml", "client-id");
        if (!parser.getBodyValueAsString("client").equals(serverId)) {
            logger.debug("Message not intended for this client: {}", serverId);
            return;
        }
        String command = parser.getBodyValueAsString("command");
        String target = parser.getBodyValueAsString("target");
        logger.info("Dispatching command '{}' for executor: {}", command, target);

        switch (target) {
            case "console" -> executeConsoleCommand(command);
            case "player" -> executePlayerCommand(parser, command);
            default -> logger.warn("Invalid target: {}", target);
        }
    }

    private void executeConsoleCommand(String command) {
        logger.debug("Executing command '{}' as console", command);

        if (CommandUtils.isCommandValid(command)) {
            logger.warn("Invalid command: {}", command);
            Runtime.getInstance().getClient().sendError("Invalid command: " + command);
            return;
        }

        CommandSender console = Bukkit.getConsoleSender();
        new SchedulerAdapter(plugin).run(() -> {
            boolean status = Bukkit.dispatchCommand(console, command);
            logResult("console", command, status);
        });
   }

    private void executePlayerCommand(MessageParser parser, String command) {
        logger.debug("Executing command '{}' as player", command);
        String uuidStr = parser.getBodyValueAsString("uuid");
        String name = parser.getBodyValueAsString("name");

        try {
            UUID uuid = UUID.fromString(uuidStr);
            Optional<Player> playerOptional = Optional.ofNullable(Bukkit.getPlayer(uuid));

            playerOptional.ifPresentOrElse(player -> handlePlayerCommand(player, command),
                    () -> logger.warn("Player '{}' not found or offline", name));
        } catch (Exception e) {
            logger.error("Error while processing player: {}",
                    logger.getDebug() ? e : e.getMessage()
                    );
            Runtime.getInstance().getClient().sendError("Error while processing player: " + e.getMessage());
        }
   }

private void handlePlayerCommand(Player player, String command) {
    if (CommandUtils.isCommandValid(command)) {
        logger.warn("Invalid command: {}", command);
        Runtime.getInstance().getClient().sendError("Invalid command: " + command);
        player.sendMessage("§cThe command '" + command + "' is invalid");
        return;
    }

    new SchedulerAdapter(plugin).run(() -> {
      boolean status = Bukkit.dispatchCommand(player, command);
      logResult("player", command, status);
    });
}


// private boolean isCommandValid(String command) {
//     String baseCommand = command.split(" ")[0];
//     PluginCommand pluginCommand = Bukkit.getPluginCommand(baseCommand);
//     if (pluginCommand != null) {
//         return false;
//     }
//     return Bukkit.getServer().getCommandMap().getCommand(baseCommand) == null;
// }
//
private void logResult(String target, String command, boolean status) {
    if (status) {
        logger.info("Successfully executed command '{}' as {}", command, target);
    } else {
        logger.warn("Failed to execute command '{}' as {}", command, target);
        Runtime.getInstance().getClient().sendError("Failed to execute command '" + command + "' as " + target);
    }
}

}
</file>

<file path="paper/src/main/resources/bukkit-config.yml">
# Client Configuration File

# General debug mode.
# Set to true to enable detailed logs and diagnostics for troubleshooting,
# or false for standard logging.
debug: false

# Unique identifier for the client.
# This is used to distinguish this client from others in the network.
# Example: client-id: "lobby" for a lobby client.
client-id: "lobby"

# The address of the remote server this client will connect to.
# Use "127.0.0.1" for local connections or the server's IP for remote access.
# Example: remote: "192.168.1.100" for a server on the local network.
remote: "127.0.0.1"

# The port number the client will use to connect to the remote server.
# Ensure this matches the port configured on the server side.
port: 8080

# Time in seconds to keep trying to reconnect after server shutdown.
# After this, use /cbc reconnect to retry manually.
timeout: 120

# A shared secret key used for authentication between the client and the server.
# This ensures secure communication.
# The key is stored securely in the secret.key file located in the server's plugin folder.
secret: "CHANGE_ME"
</file>

<file path="paper/src/main/resources/bukkit-example.yml">
##########################################################################
# EXAMPLE CONFIGURATION
# This file demonstrates how to dispatch a command to the Bukkit server
# or servers, where the command gets executed on the Velocity server.
##########################################################################

# The name of the command to be dispatched.
# This is the identifier for the command configuration.
name: examplebukkit

# Enable or disable this command.
# Set to true to allow the command to be executed, or false to disable it.
enabled: true

# Ignore permission checks for this command.
# Set to true to bypass permission validation, or false to enforce it.
ignore-permission-check: false

# Hide permission warnings when the executor does not have the required permissions.
# Set to true to suppress warnings, or false to show them.
hide-permission-warning: false

# A list of commands to execute on the server.
commands:
  # Command 1
  - command: 'velocity info' # The command string to be executed.
    delay: 0                     # Delay (in seconds) before executing the command.
    target-executor: 'player'    # Who executes the command: 'player' or 'console'.
    check-if-executor-is-player: true  # If true, ensures the executor is a player.
    check-if-executor-is-on-server: true # If true, ensures the executor is online.

  # Command 2
  - command: 'velocity plugins' # The command string to be executed.
    delay: 0                      # Delay (in seconds) before executing the command.
    target-executor: 'console'    # Who executes the command: 'player' or 'console'.
    check-if-executor-is-player: false  # If true, ensures the executor is a player.
    check-if-executor-is-on-server: false # If true, ensures the executor is online.
</file>

<file path="velocity/src/main/java/dev/consti/commandbridge/velocity/core/Runtime.java">
package dev.consti.commandbridge.velocity.core;


import dev.consti.commandbridge.velocity.Main;
import dev.consti.commandbridge.velocity.command.CommandDispatcher;
import dev.consti.commandbridge.velocity.command.CommandForwarder;
import dev.consti.commandbridge.velocity.command.CommandRegistrar;
import dev.consti.commandbridge.velocity.util.GeneralUtils;
import dev.consti.commandbridge.velocity.util.ScriptUtils;
import dev.consti.commandbridge.velocity.websocket.HttpServer;
import dev.consti.commandbridge.velocity.websocket.Server;
import dev.consti.foundationlib.logging.Logger;
import dev.consti.foundationlib.utils.ConfigManager;

public class Runtime {
    private static Runtime instance;
    private Logger logger;
    private ConfigManager config;
    private ScriptUtils scriptUtils;
    private Server server;
    private Startup startup;
    private CommandForwarder helper;
    private CommandRegistrar registrar;
    private GeneralUtils generalUtils;
    private CommandDispatcher commandDispatcher;
    private HttpServer httpServer;

    private Runtime() {}

    public static synchronized Runtime getInstance() {
        if (instance == null) {
            instance = new Runtime();
            instance.getLogger().debug("Runtime singleton instance initialized.");
        }
        return instance;
    }

    public synchronized Logger getLogger() {
        if (logger == null) {
            logger = new Logger("CommandBridge");
            logger.debug("Logger initialized.");
        }
        return logger;
    }

    public synchronized ConfigManager getConfig() {
        if (config == null) {
            config = new ConfigManager(getLogger(), "CommandBridge");
            getLogger().debug("ConfigManager initialized.");
        }
        return config;
    }

    public synchronized ScriptUtils getScriptUtils() {
        if (scriptUtils == null) {
            scriptUtils = new ScriptUtils(getLogger(), "CommandBridge");
            getLogger().debug("ScriptUtils initialized.");
        }
        return scriptUtils;
    }

    public synchronized Server getServer() {
        if (server == null) {
            server = new Server(getLogger(), getConfig().getSecret());
            getLogger().debug("Server initialized.");
        }
        return server;
    }

    public synchronized Startup getStartup() {
        if (startup == null) {
            startup = new Startup(getLogger());
            getLogger().debug("Startup initialized.");
        }
        return startup;
    }

    public synchronized CommandForwarder getHelper() {
        if (helper == null) {
            helper = new CommandForwarder(getLogger(), Main.getInstance());
            getLogger().debug("CommandForwarder initialized.");
        }
        return helper;
    }

    public synchronized CommandRegistrar getRegistrar() {
        if (registrar == null) {
            registrar = new CommandRegistrar(getLogger());
            getLogger().debug("InternalRegistrar initialized.");
        }
        return registrar;
    }

    public synchronized GeneralUtils getGeneralUtils() {
        if (generalUtils == null) {
            generalUtils = new GeneralUtils(getLogger());
            getLogger().debug("GeneralUtils initialized.");
        }
        return generalUtils;
    }

    public synchronized CommandDispatcher getCommandExecutor() {
        if (commandDispatcher == null) {
            commandDispatcher = new CommandDispatcher();
            getLogger().debug("CommandDispatcher initialized.");
        }
        return commandDispatcher;
    }

    public synchronized HttpServer getHttpServer() {
        if (httpServer == null) {
            httpServer = new HttpServer(logger);
            getLogger().debug("HttpServer initialized.");
        }
        return httpServer;
    }
}
</file>

<file path="velocity/src/main/java/dev/consti/commandbridge/velocity/helper/command/StopCommand.java">
package dev.consti.commandbridge.velocity.helper.command;

import com.mojang.brigadier.builder.LiteralArgumentBuilder;
import com.velocitypowered.api.command.CommandSource;
import dev.consti.commandbridge.velocity.core.Runtime;
import dev.consti.foundationlib.logging.Logger;
import net.kyori.adventure.text.Component;
import net.kyori.adventure.text.format.NamedTextColor;


public class StopCommand {
    public static LiteralArgumentBuilder<CommandSource> build(Logger logger) {
        return LiteralArgumentBuilder.<CommandSource>literal("stop")
                .executes(context -> {
                    CommandSource source = context.getSource();
                    if (!source.hasPermission("commandbridge.admin")) {
                        source.sendMessage(Component.text("You do not have permission to stop the WebSocket server", NamedTextColor.RED));
                        return 0;
                    }

                    Runtime.getInstance().getStartup().stop();
                    source.sendMessage(Component.text("WebSocket Server stopped").color(NamedTextColor.YELLOW));
                    return 1;
                });
    }
}
</file>

<file path="velocity/src/main/java/dev/consti/commandbridge/velocity/helper/HelpCommand.java">
package dev.consti.commandbridge.velocity.helper;

import com.mojang.brigadier.builder.LiteralArgumentBuilder;
import com.velocitypowered.api.command.CommandSource;
import dev.consti.foundationlib.logging.Logger;
import net.kyori.adventure.text.Component;
import net.kyori.adventure.text.event.ClickEvent;
import net.kyori.adventure.text.format.NamedTextColor;
import net.kyori.adventure.text.format.TextDecoration;

public class HelpCommand {
    public static LiteralArgumentBuilder<CommandSource> build(Logger logger) {
        return LiteralArgumentBuilder.<CommandSource>literal("help")
                .executes(context -> sendHelpMessage(context.getSource(), logger));
    }

    public static int sendHelpMessage(CommandSource source, Logger logger) {
        logger.debug("Sending help message to: {}", source);

        source.sendMessage(Component.text("==== CommandBridge Help ====").color(NamedTextColor.GOLD));
        source.sendMessage(Component.text(""));

        source.sendMessage(Component.text("Available Commands:").color(NamedTextColor.YELLOW));

        source.sendMessage(formatCommand("help", "Displays this help message", false));
        source.sendMessage(formatCommand("list", "Lists connected clients", false));
        source.sendMessage(formatCommand("reload", "Reloads all configs and scripts", false));
        source.sendMessage(formatCommand("version", "Displays the current version", false));

        source.sendMessage(Component.text(""));
        source.sendMessage(Component.text("Debug Commands (Debug mode only):").color(NamedTextColor.RED));
        source.sendMessage(formatCommand("stop", "Stops the cb server", false));
        source.sendMessage(formatCommand("start", "Starts the cb server", false));

        source.sendMessage(Component.text(""));
        source.sendMessage(Component.text("Client Commands (/cbc):").color(NamedTextColor.AQUA));
        source.sendMessage(formatCommand("reconnect", "Reconnects the current client", true));

        source.sendMessage(Component.text(""));
        source.sendMessage(Component.text("Documentation: ")
                .append(Component.text("https://docs.commandbridge.72s.dev")
                        .color(NamedTextColor.LIGHT_PURPLE)
                        .decorate(TextDecoration.UNDERLINED)
                        .clickEvent(ClickEvent.openUrl("https://72-s.github.io/CommandBridge/"))));

        source.sendMessage(Component.text(""));
        source.sendMessage(Component.text("============================").color(NamedTextColor.GOLD));
        return 1;
    }

    private static Component formatCommand(String command, String description, boolean client) {
        String alias = client ? "/cbc " : "/cb ";
        return Component.text("  - ")
                .append(Component.text(alias + command).color(NamedTextColor.GREEN))
                .append(Component.text(" - " + description).color(NamedTextColor.WHITE));
    }
}
</file>

<file path="wiki/SUMMARY.md">
# Table of contents

* [👋 Welcome](README.md)
* [🤖 Use cases](use-cases.md)

## Getting Started

* [📘 Requirements](getting-started/requirements.md)
* [📩 Installation](getting-started/installation.md)
* [⚙️ Plugin setup](getting-started/plugin-setup.md)

## SCRIPTS

* [Page 1](scripts/page-1.md)

## Troubleshooting

* [❌ Common issues](troubleshooting/common-issues.md)
* [📭 Support resources](troubleshooting/support-resources.md)

## Other

* [👨‍💻 Contribution Guidelines](other/contribution-guidelines.md)
* [🔢 Data collection](other/data-collection.md)
</file>

<file path="gradlew">
#!/bin/sh

#
# Copyright © 2015-2021 the original authors.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      https://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#
# SPDX-License-Identifier: Apache-2.0
#

##############################################################################
#
#   Gradle start up script for POSIX generated by Gradle.
#
#   Important for running:
#
#   (1) You need a POSIX-compliant shell to run this script. If your /bin/sh is
#       noncompliant, but you have some other compliant shell such as ksh or
#       bash, then to run this script, type that shell name before the whole
#       command line, like:
#
#           ksh Gradle
#
#       Busybox and similar reduced shells will NOT work, because this script
#       requires all of these POSIX shell features:
#         * functions;
#         * expansions «$var», «${var}», «${var:-default}», «${var+SET}»,
#           «${var#prefix}», «${var%suffix}», and «$( cmd )»;
#         * compound commands having a testable exit status, especially «case»;
#         * various built-in commands including «command», «set», and «ulimit».
#
#   Important for patching:
#
#   (2) This script targets any POSIX shell, so it avoids extensions provided
#       by Bash, Ksh, etc; in particular arrays are avoided.
#
#       The "traditional" practice of packing multiple parameters into a
#       space-separated string is a well documented source of bugs and security
#       problems, so this is (mostly) avoided, by progressively accumulating
#       options in "$@", and eventually passing that to Java.
#
#       Where the inherited environment variables (DEFAULT_JVM_OPTS, JAVA_OPTS,
#       and GRADLE_OPTS) rely on word-splitting, this is performed explicitly;
#       see the in-line comments for details.
#
#       There are tweaks for specific operating systems such as AIX, CygWin,
#       Darwin, MinGW, and NonStop.
#
#   (3) This script is generated from the Groovy template
#       https://github.com/gradle/gradle/blob/HEAD/platforms/jvm/plugins-application/src/main/resources/org/gradle/api/internal/plugins/unixStartScript.txt
#       within the Gradle project.
#
#       You can find Gradle at https://github.com/gradle/gradle/.
#
##############################################################################

# Attempt to set APP_HOME

# Resolve links: $0 may be a link
app_path=$0

# Need this for daisy-chained symlinks.
while
    APP_HOME=${app_path%"${app_path##*/}"}  # leaves a trailing /; empty if no leading path
    [ -h "$app_path" ]
do
    ls=$( ls -ld "$app_path" )
    link=${ls#*' -> '}
    case $link in             #(
      /*)   app_path=$link ;; #(
      *)    app_path=$APP_HOME$link ;;
    esac
done

# This is normally unused
# shellcheck disable=SC2034
APP_BASE_NAME=${0##*/}
# Discard cd standard output in case $CDPATH is set (https://github.com/gradle/gradle/issues/25036)
APP_HOME=$( cd -P "${APP_HOME:-./}" > /dev/null && printf '%s
' "$PWD" ) || exit

# Use the maximum available, or set MAX_FD != -1 to use that value.
MAX_FD=maximum

warn () {
    echo "$*"
} >&2

die () {
    echo
    echo "$*"
    echo
    exit 1
} >&2

# OS specific support (must be 'true' or 'false').
cygwin=false
msys=false
darwin=false
nonstop=false
case "$( uname )" in                #(
  CYGWIN* )         cygwin=true  ;; #(
  Darwin* )         darwin=true  ;; #(
  MSYS* | MINGW* )  msys=true    ;; #(
  NONSTOP* )        nonstop=true ;;
esac

CLASSPATH=$APP_HOME/gradle/wrapper/gradle-wrapper.jar


# Determine the Java command to use to start the JVM.
if [ -n "$JAVA_HOME" ] ; then
    if [ -x "$JAVA_HOME/jre/sh/java" ] ; then
        # IBM's JDK on AIX uses strange locations for the executables
        JAVACMD=$JAVA_HOME/jre/sh/java
    else
        JAVACMD=$JAVA_HOME/bin/java
    fi
    if [ ! -x "$JAVACMD" ] ; then
        die "ERROR: JAVA_HOME is set to an invalid directory: $JAVA_HOME

Please set the JAVA_HOME variable in your environment to match the
location of your Java installation."
    fi
else
    JAVACMD=java
    if ! command -v java >/dev/null 2>&1
    then
        die "ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.

Please set the JAVA_HOME variable in your environment to match the
location of your Java installation."
    fi
fi

# Increase the maximum file descriptors if we can.
if ! "$cygwin" && ! "$darwin" && ! "$nonstop" ; then
    case $MAX_FD in #(
      max*)
        # In POSIX sh, ulimit -H is undefined. That's why the result is checked to see if it worked.
        # shellcheck disable=SC2039,SC3045
        MAX_FD=$( ulimit -H -n ) ||
            warn "Could not query maximum file descriptor limit"
    esac
    case $MAX_FD in  #(
      '' | soft) :;; #(
      *)
        # In POSIX sh, ulimit -n is undefined. That's why the result is checked to see if it worked.
        # shellcheck disable=SC2039,SC3045
        ulimit -n "$MAX_FD" ||
            warn "Could not set maximum file descriptor limit to $MAX_FD"
    esac
fi

# Collect all arguments for the java command, stacking in reverse order:
#   * args from the command line
#   * the main class name
#   * -classpath
#   * -D...appname settings
#   * --module-path (only if needed)
#   * DEFAULT_JVM_OPTS, JAVA_OPTS, and GRADLE_OPTS environment variables.

# For Cygwin or MSYS, switch paths to Windows format before running java
if "$cygwin" || "$msys" ; then
    APP_HOME=$( cygpath --path --mixed "$APP_HOME" )
    CLASSPATH=$( cygpath --path --mixed "$CLASSPATH" )

    JAVACMD=$( cygpath --unix "$JAVACMD" )

    # Now convert the arguments - kludge to limit ourselves to /bin/sh
    for arg do
        if
            case $arg in                                #(
              -*)   false ;;                            # don't mess with options #(
              /?*)  t=${arg#/} t=/${t%%/*}              # looks like a POSIX filepath
                    [ -e "$t" ] ;;                      #(
              *)    false ;;
            esac
        then
            arg=$( cygpath --path --ignore --mixed "$arg" )
        fi
        # Roll the args list around exactly as many times as the number of
        # args, so each arg winds up back in the position where it started, but
        # possibly modified.
        #
        # NB: a `for` loop captures its iteration list before it begins, so
        # changing the positional parameters here affects neither the number of
        # iterations, nor the values presented in `arg`.
        shift                   # remove old arg
        set -- "$@" "$arg"      # push replacement arg
    done
fi


# Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
DEFAULT_JVM_OPTS='"-Xmx64m" "-Xms64m"'

# Collect all arguments for the java command:
#   * DEFAULT_JVM_OPTS, JAVA_OPTS, JAVA_OPTS, and optsEnvironmentVar are not allowed to contain shell fragments,
#     and any embedded shellness will be escaped.
#   * For example: A user cannot expect ${Hostname} to be expanded, as it is an environment variable and will be
#     treated as '${Hostname}' itself on the command line.

set -- \
        "-Dorg.gradle.appname=$APP_BASE_NAME" \
        -classpath "$CLASSPATH" \
        org.gradle.wrapper.GradleWrapperMain \
        "$@"

# Stop when "xargs" is not available.
if ! command -v xargs >/dev/null 2>&1
then
    die "xargs is not available"
fi

# Use "xargs" to parse quoted args.
#
# With -n1 it outputs one arg per line, with the quotes and backslashes removed.
#
# In Bash we could simply go:
#
#   readarray ARGS < <( xargs -n1 <<<"$var" ) &&
#   set -- "${ARGS[@]}" "$@"
#
# but POSIX shell has neither arrays nor command substitution, so instead we
# post-process each arg (as a line of input to sed) to backslash-escape any
# character that might be a shell metacharacter, then use eval to reverse
# that process (while maintaining the separation between arguments), and wrap
# the whole thing up as a single "set" statement.
#
# This will of course break if any of these variables contains a newline or
# an unmatched quote.
#

eval "set -- $(
        printf '%s\n' "$DEFAULT_JVM_OPTS $JAVA_OPTS $GRADLE_OPTS" |
        xargs -n1 |
        sed ' s~[^-[:alnum:]+,./:=@_]~\\&~g; ' |
        tr '\n' ' '
    )" '"$@"'

exec "$JAVACMD" "$@"
</file>

<file path="paper/src/main/java/dev/consti/commandbridge/paper/utils/GeneralUtils.java">
package dev.consti.commandbridge.paper.utils;

import java.util.ArrayList;
import java.util.List;

import org.bukkit.ChatColor;

import dev.consti.commandbridge.paper.Main;
import dev.consti.foundationlib.logging.Logger;
import dev.jorel.commandapi.CommandAPICommand;
import dev.jorel.commandapi.arguments.Argument;
import dev.jorel.commandapi.arguments.ArgumentSuggestions;
import dev.jorel.commandapi.arguments.StringArgument;
import dev.consti.commandbridge.paper.core.Runtime;

public class GeneralUtils {
    private final Logger logger;

    public GeneralUtils(Logger logger) {
        this.logger = logger;
    }

    public void reloadAll() {
        new SchedulerAdapter(Main.getInstance())
                .run(
                        () -> {
                            logger.debug("Running on thread (reload): {}", Thread.currentThread().getName());
                            try {
                                Runtime.getInstance().getConfig().reload();
                                logger.debug("All configs have been reloaded");
                                logger.setDebug(Boolean
                                        .parseBoolean(Runtime.getInstance().getConfig().getKey("config.yml", "debug")));
                                logger.info("Debug mode set to: {}",
                                        Runtime.getInstance().getConfig().getKey("config.yml", "debug"));
                                Runtime.getInstance().getScriptUtils().reload();
                                logger.debug("All scripts have been reloaded");
                                logger.info("Everything Reloaded!");
                                Runtime.getInstance().getClient().sendTask("reload", "success");
                            } catch (Exception e) {
                                logger.error("Error occurred while reloading: {}",
                                        logger.getDebug() ? e : e.getMessage());
                                Runtime.getInstance().getClient().sendTask("reload", "failure");
                            }
                        });
    }

    public void registerCommands() {
        List<Argument<?>> arguments = new ArrayList<>();
        arguments.add(new StringArgument("arguments").replaceSuggestions(ArgumentSuggestions.strings("reconnect")));
        new CommandAPICommand("commandbridgeclient")
                .withArguments(arguments)
                .withAliases("cbc")
                .withPermission("commandbridge.admin")
                .executes((sender, args) -> {
                    String opt = (String) args.get("arguments");
                    if (opt.matches("reconnect")) {
                        Runtime.getInstance().getClient().disconnect();
                        try {
                            Runtime.getInstance().getClient().connect(
                                    Runtime.getInstance().getConfig().getKey("config.yml", "remote"),
                                    Integer.parseInt(Runtime.getInstance().getConfig().getKey("config.yml", "port")));
                            sender.sendMessage(ChatColor.GREEN + "Client reconnected successfully");
                        } catch (Exception e) {
                            logger.error("Client reconnection failed: ", e);
                            sender.sendMessage(ChatColor.RED + "Failed to reconnect");
                        }
                    }
                })
                .register();
    }

}
</file>

<file path="paper/src/main/java/dev/consti/commandbridge/paper/websocket/Client.java">
package dev.consti.commandbridge.paper.websocket;

import dev.consti.commandbridge.paper.Main;
import dev.consti.commandbridge.paper.core.Runtime;
import dev.consti.commandbridge.paper.utils.SchedulerAdapter;
import dev.consti.foundationlib.json.MessageBuilder;
import dev.consti.foundationlib.json.MessageParser;
import dev.consti.foundationlib.logging.Logger;
import dev.consti.foundationlib.websocket.SimpleWebSocketClient;
import org.bukkit.entity.Player;

public class Client extends SimpleWebSocketClient {
    private final Logger logger;

    public Client(Logger logger, String secret) {
        super(logger, secret);
        this.logger = logger;
    }

    @Override
    protected void onMessage(String message) {
        MessageParser parser = new MessageParser(message);
        logger.debug("Received payload: {}", message);
        try {
            String type = parser.getType();
            switch (type) {
                case "command" -> handleCommandRequest(message);
                case "system" -> handleSystemRequest(message);
                default -> {
                    logger.warn("Invalid type: {}", type);
                    sendError("Invalid type: " + type);
                }
            }
        } catch (Exception e) {
            logger.error("Error while processing message: {}",
                    logger.getDebug() ? e : e.getMessage());
            sendError("Internal client error: " + e.getMessage());
        }
    }

    @Override
    protected void afterAuth() {
        logger.debug("Sending server information's...");
        MessageBuilder builder = new MessageBuilder("system");
        builder.addToBody("channel", "name");
        builder.addToBody("name", Runtime.getInstance().getConfig().getKey("config.yml", "client-id"));
        logger.debug("Sending payload: {}", builder.build().toString());
        sendMessage(builder.build());
    }

    private void handleCommandRequest(String message) {
        logger.debug("Handling command response");
        Runtime.getInstance().getCommandExecutor().dispatchCommand(message);
    }

    private void handleSystemRequest(String message) {
        logger.debug("Handling system request");
        MessageParser parser = new MessageParser(message);
        String channel = parser.getBodyValueAsString("channel");
        String status = parser.getStatus();

        switch (channel) {
            case "error" -> logger.warn("Error from server '{}' : {}", parser.getBodyValueAsString("server"), status);
            case "info" -> logger.info("Info from server '{}' : {}", parser.getBodyValueAsString("server"), status);
            case "task" -> systemTask(parser, status);
            default -> logger.warn("Invalid channel: {}", channel);
        }
    }

    private void systemTask(MessageParser parser, String status) {
        String task = parser.getBodyValueAsString("task");
        switch (task) {
            case "reload" ->
                Runtime.getInstance().getScriptUtils().unloadCommands(() -> new SchedulerAdapter(Main.getInstance())
                        .runLater(Runtime.getInstance().getGeneralUtils()::reloadAll, 10L));
            case "reconnect" -> Ping.reconnect(logger);
            default -> logger.warn("Invalid task: {}", task);
        }
    }

    public void sendError(String errorMessage) {
        MessageBuilder builder = new MessageBuilder("system");
        builder.addToBody("channel", "error").withStatus(errorMessage).addToBody("client",
                Runtime.getInstance().getConfig().getKey("config.yml", "client-id"));
        sendMessage(builder.build());
    }

    public void sendInfo(String infoMessage) {
        MessageBuilder builder = new MessageBuilder("system");
        builder.addToBody("channel", "info").withStatus(infoMessage).addToBody("client",
                Runtime.getInstance().getConfig().getKey("config.yml", "client-id"));
        sendMessage(builder.build());
    }

    public void sendTask(String task, String status) {
        MessageBuilder builder = new MessageBuilder("system");
        builder.addToBody("channel", "task").addToBody("task", task)
                .addToBody("client", Runtime.getInstance().getConfig().getKey("config.yml", "client-id"))
                .withStatus(status);
        sendMessage(builder.build());
    }

    public void sendCommand(String command, String client, String target, Player executor) {
        MessageBuilder builder = new MessageBuilder("command");
        builder.addToBody("command", command).addToBody("client", client).addToBody("target", target);

        if (target.equals("player")) {
            builder.addToBody("name", executor.getName()).addToBody("uuid", executor.getUniqueId());
        }
        logger.info("Sending command '{}' to server", command);
        logger.debug("Sending payload: {}", builder.build().toString());
        sendMessage(builder.build());
    }
}
</file>

<file path="velocity/src/main/java/dev/consti/commandbridge/velocity/helper/command/ListCommand.java">
package dev.consti.commandbridge.velocity.helper.command;

import com.mojang.brigadier.builder.LiteralArgumentBuilder;
import com.velocitypowered.api.command.CommandSource;
import dev.consti.foundationlib.logging.Logger;
import net.kyori.adventure.text.Component;
import net.kyori.adventure.text.format.NamedTextColor;

import java.util.Set;

public class ListCommand {
    public static LiteralArgumentBuilder<CommandSource> build(Set<String> connectedClients, Logger logger) {
        return LiteralArgumentBuilder.<CommandSource>literal("list")
                .executes(context -> {
                    CommandSource source = context.getSource();

                    if (!source.hasPermission("commandbridge.admin")) {
                        source.sendMessage(Component.text("You do not have permission to list connected clients", NamedTextColor.RED));
                        return 0;
                    }

                    if (connectedClients.isEmpty()) {
                        source.sendMessage(
                                Component.text("No clients are currently connected").color(NamedTextColor.RED));
                    } else {
                        String clientsString = String.join(", ", connectedClients);
                        source.sendMessage(Component.text("===== Connected Clients =======").color(NamedTextColor.GOLD));
                        source.sendMessage(Component.text(clientsString).color(NamedTextColor.GREEN));
                        source.sendMessage(Component.text("============================").color(NamedTextColor.GOLD));
                    }
                    return 1;
                });
    }
}
</file>

<file path="velocity/src/main/java/dev/consti/commandbridge/velocity/helper/FailureChecker.java">
package dev.consti.commandbridge.velocity.helper;

import com.velocitypowered.api.command.CommandSource;
import com.velocitypowered.api.proxy.ProxyServer;
import dev.consti.commandbridge.velocity.Main;
import dev.consti.commandbridge.velocity.core.Runtime;
import dev.consti.foundationlib.logging.Logger;
import net.kyori.adventure.text.Component;
import net.kyori.adventure.text.format.NamedTextColor;

import java.util.concurrent.TimeUnit;

public class FailureChecker implements Runnable {
    private final Logger logger;
    private final ProxyServer proxy;
    private final Main plugin;
    private final StatusManager statusManager;
    private final CommandSource source;
    private final int maxRetries;
    private final int[] retries;

    public FailureChecker(Logger logger, ProxyServer proxy, Main plugin, StatusManager statusManager, CommandSource source) {
        this.logger = logger;
        this.proxy = proxy;
        this.plugin = plugin;
        this.statusManager = statusManager;
        this.source = source;
        this.maxRetries = Integer.parseInt(Runtime.getInstance().getConfig().getKey("config.yml", "timeout"));
        this.retries = new int[]{0};
    }

    @Override
    public void run() {
        retries[0]++;
        logger.debug("Failure check attempt {}/{}", retries[0], maxRetries);

        try {
            String failedClients = statusManager.checkForFailures();

            if (failedClients == null) {
                source.sendMessage(
                        Component.text("Everything has reloaded successfully!")
                                .color(NamedTextColor.GREEN)
                );
                logger.info("Scripts reloaded successfully");
                statusManager.clearStatusMap();
            } else if (retries[0] >= maxRetries) {
                // Timeout after 8 seconds
                source.sendMessage(
                        Component.text("ReloadCommand failed: " + failedClients)
                                .color(NamedTextColor.RED)
                );
                logger.error("Reload command failed '{}'", failedClients);
                statusManager.clearStatusMap();
            } else {
                proxy.getScheduler().buildTask(plugin, this).delay(1, TimeUnit.SECONDS).schedule();
            }
        } catch (Exception e) {
            logger.error("An error occurred during the reload process: {}", logger.getDebug() ? e : e.getMessage());
            source.sendMessage(
                    Component.text("Reload command failed due to an internal error. Check logs for details")
                            .color(NamedTextColor.RED)
            );
        }
    }
}
</file>

<file path="velocity/src/main/java/dev/consti/commandbridge/velocity/helper/InternalRegistrar.java">
package dev.consti.commandbridge.velocity.helper;

import com.mojang.brigadier.builder.LiteralArgumentBuilder;
import com.mojang.brigadier.tree.LiteralCommandNode;
import com.velocitypowered.api.command.BrigadierCommand;
import com.velocitypowered.api.command.CommandSource;
import com.velocitypowered.api.proxy.ProxyServer;
import dev.consti.commandbridge.velocity.Main;
import dev.consti.commandbridge.velocity.core.Runtime;
import dev.consti.commandbridge.velocity.helper.command.ListCommand;
import dev.consti.commandbridge.velocity.helper.command.ReloadCommand;
import dev.consti.commandbridge.velocity.helper.command.StartCommand;
import dev.consti.commandbridge.velocity.helper.command.StopCommand;
import dev.consti.commandbridge.velocity.helper.command.VersionCommand;
import dev.consti.foundationlib.logging.Logger;
import net.kyori.adventure.text.Component;
import net.kyori.adventure.text.format.NamedTextColor;

import java.util.Set;

public class InternalRegistrar {
    private final Logger logger;
    private final ProxyServer proxy;
    private final Main plugin;
    private final Set<String> connectedClients;

    public InternalRegistrar(Logger logger, ProxyServer proxy, Main plugin, Set<String> connectedClients) {
        this.logger = logger;
        this.proxy = proxy;
        this.plugin = plugin;
        this.connectedClients = connectedClients;
    }

    public void registerCommands() {
        logger.info("Registering commands for CommandBridge...");
        try {
            // Build the main command
            LiteralArgumentBuilder<CommandSource> commandBridgeBuilder = LiteralArgumentBuilder
                    .<CommandSource>literal("commandbridge")
                    .executes(context -> {
                        // Default action, for example show help
                        if (context.getSource().hasPermission("commandbridge.admin")) {
                            return HelpCommand.sendHelpMessage(context.getSource(), logger);
                        }
                        context.getSource().sendMessage(
                                Component.text("You do not have permission to use this command", NamedTextColor.RED));
                        return 0;
                    });

            // Append subcommands
            commandBridgeBuilder.then(ReloadCommand.build(Runtime.getInstance().getGeneralUtils(), logger));
            commandBridgeBuilder.then(VersionCommand.build(logger));
            commandBridgeBuilder.then(HelpCommand.build(logger));
            commandBridgeBuilder.then(ListCommand.build(connectedClients, logger));
            if (logger.getDebug()) {
                commandBridgeBuilder.then(StopCommand.build(logger));
                commandBridgeBuilder.then(StartCommand.build(logger));
            }

            LiteralCommandNode<CommandSource> commandBridgeNode = commandBridgeBuilder.build();

             Runtime.getInstance().getGeneralUtils().setMeta(proxy.getCommandManager()
                    .metaBuilder("commandbridge")
                    .aliases("cb")
                    .plugin(plugin)
                    .build());

            BrigadierCommand brigadierCommand = new BrigadierCommand(commandBridgeNode);
            proxy.getCommandManager().register(Runtime.getInstance().getGeneralUtils().getMeta(), brigadierCommand);
            logger.info("CommandBridge commands registered successfully");
        } catch (Exception e) {
            logger.error("Failed to register CommandBridge commands: {}", logger.getDebug() ? e : e.getMessage());
        }
    }

}
</file>

<file path="paper/src/main/java/dev/consti/commandbridge/paper/command/CommandForwarder.java">
package dev.consti.commandbridge.paper.command;

import org.bukkit.ChatColor;
import org.bukkit.command.CommandSender;
import org.bukkit.entity.Player;

import dev.consti.commandbridge.paper.Main;
import dev.consti.commandbridge.paper.core.Runtime;
import dev.consti.commandbridge.paper.utils.SchedulerAdapter;
import dev.consti.foundationlib.logging.Logger;
import dev.consti.foundationlib.utils.ScriptManager;
import dev.consti.foundationlib.utils.StringParser;
import me.clip.placeholderapi.PlaceholderAPI;

public class CommandForwarder {
    private final Logger logger;
    private final Main plugin;

    public CommandForwarder(Logger logger, Main plugin) {
        this.logger = logger;
        this.plugin = plugin;
    }

    public int executeScriptCommands(CommandSender sender, ScriptManager.ScriptConfig script, String[] args) {
        if (isPermissionDenied(sender, script)) {
            return 0;
        }

        for (ScriptManager.Command cmd : script.getCommands()) {
            logger.debug("Processing command: {}", cmd.getCommand());

            switch (cmd.getTargetExecutor().toLowerCase()) {
                case "player" -> handlePlayerExecutor(cmd, sender, args);
                case "console" -> handleConsoleExecutor(cmd, args);
                default -> logger.warn("Unknown target executor for command: {}", cmd.getCommand());
            }
        }

        return 1;
    }

    private boolean isPermissionDenied(CommandSender sender, ScriptManager.ScriptConfig script) {
        if (!script.shouldIgnorePermissionCheck()
                && !sender.hasPermission("commandbridge.command." + script.getName())) {
            logger.warn("Sender '{}' has no permission to use this command", sender);
            if (!script.shouldHidePermissionWarning()) {
                sender.sendMessage(ChatColor.RED + "You do not have permission to use this command.");
            }
            return true;
        }
        return false;
    }

    private void handlePlayerExecutor(ScriptManager.Command cmd, CommandSender sender, String[] args) {
        if (cmd.isCheckIfExecutorIsPlayer() && !(sender instanceof Player)) {
            logger.warn("This command requires a player as executor, but sender is not a player.");
            sender.sendMessage(
                    ChatColor.RED + "This command requires a player as executor, but source is not a player object");
            return;
        }

        Player player = (Player) sender;
        String parsedCommand = parseCommand(cmd, args, player);

        if (parsedCommand == null)
            return;

        if (cmd.getDelay() > 0) {
            scheduleCommand(cmd, parsedCommand, player);
        } else {
            sendCommand(cmd, parsedCommand, player);
        }
    }

    private void handleConsoleExecutor(ScriptManager.Command cmd, String[] args) {
        String parsedCommand = parseCommand(cmd, args, null);

        if (parsedCommand == null)
            return;

        if (cmd.getDelay() > 0) {
            scheduleCommand(cmd, parsedCommand, null);
        } else {
            sendCommand(cmd, parsedCommand, null);
        }
    }

    private String parseCommand(ScriptManager.Command cmd, String[] args, Player player) {
        StringParser parser = StringParser.create();

        if (player != null && cmd.getTargetExecutor().equals("player")) {
            addPlayerPlaceholders(parser, player);
        } else {
            return parser.parsePlaceholders(cmd.getCommand(), args);
        }

        try {
            String parsedCommand = parser.parsePlaceholders(cmd.getCommand(), args);
            if (Runtime.getInstance().getStartup().isPlaceholderAPI()) {
                parsedCommand = PlaceholderAPI.setPlaceholders(player, parsedCommand);
            }
            return parsedCommand;

        } catch (Exception e) {
            logger.error("Error occurred while parsing command: {}", logger.getDebug() ? e : e.getMessage());
            if (player != null) {
                player.sendMessage(ChatColor.RED + "Error occurred while parsing command");
            }
            Runtime.getInstance().getClient().sendError("Error occurred while parsing commands");
        }

        return null;
    }

    private void addPlayerPlaceholders(StringParser parser, Player player) {
        logger.debug("Adding placeholders for player: {}", player.getName());
        parser.addPlaceholder("%cb_player%", player.getName());
        parser.addPlaceholder("%cb_uuid%", player.getUniqueId().toString());
        parser.addPlaceholder("%cb_world%", player.getWorld().getName());
    }

    private void scheduleCommand(ScriptManager.Command cmd, String command, Player player) {
        logger.debug("Scheduling command '{}' with delay: {} seconds", cmd.getCommand(), cmd.getDelay());
        if (player != null) {
            player.sendMessage("Scheduling command with '" + cmd.getDelay() + "' seconds");
        }
        new SchedulerAdapter(plugin).runLater(() -> sendCommand(cmd, command, player), cmd.getDelay() * 20L);
    }

    private void sendCommand(ScriptManager.Command cmd, String command, Player player) {
        // List<String> targetServers = cmd.getTargetServerIds();
        //
        // if (targetServers.isEmpty()) {
        // logger.warn("No target servers defined for command: {}", cmd.getCommand());
        // return;
        // }
        //
        // for (String serverId : targetServers) {
        // try {
        // logger.info("Sending command to server '{}' as {}", serverId, player == null
        // ? "console" : "player");
        // Runtime.getInstance().getClient().sendCommand(command, serverId,
        // cmd.getTargetExecutor(), player);
        // } catch (Exception e) {
        // logger.error("Failed to send command to server '{}': {}", serverId,
        // e.getMessage());
        // }
        // }

        logger.info("Sending command to server as {}", player == null ? "console" : "player");
        Runtime.getInstance().getClient().sendCommand(command, "", cmd.getTargetExecutor(), player);
    }
}
</file>

<file path="paper/src/main/java/dev/consti/commandbridge/paper/core/Startup.java">
package dev.consti.commandbridge.paper.core;

import org.bukkit.Bukkit;

import dev.consti.commandbridge.paper.Main;
import dev.consti.commandbridge.paper.utils.SchedulerAdapter;
import dev.consti.foundationlib.logging.Logger;
import dev.consti.foundationlib.utils.VersionChecker;

public class Startup {
    private final Logger logger;
    private final Runtime runtime;
    private boolean placeholderAPI = false;

    public Startup(Logger logger) {
        this.logger = logger;
        this.runtime = Runtime.getInstance();
    }

    public void start() {
        try {
            runtime.getConfig().copyConfig("bukkit-config.yml", "config.yml");
            runtime.getConfig().loadAllConfigs();

            boolean debugMode = Boolean.parseBoolean(runtime.getConfig().getKey("config.yml", "debug"));
            logger.setDebug(debugMode);
            if (SchedulerAdapter.isFolia()) {
                logger.info("Running on Folia!");
            } else {
                logger.info("Running on Paper!");
            }
            logger.info("Debug mode set to: {}", debugMode);

            logger.debug("Copying default scripts...");
            runtime.getScriptUtils().copyDefaultScript("bukkit-example.yml", "example.yml");
            runtime.getScriptUtils().loadAllScripts();

            logger.debug("Connecting to WebSocket server...");
            runtime.getClient().connect(
                    runtime.getConfig().getKey("config.yml", "remote"),
                    Integer.parseInt(runtime.getConfig().getKey("config.yml", "port")));

            logger.debug("Setting up version checker...");
            VersionChecker.setProjectId("wIuI4ru2");

            logger.debug("Checking for updates...");
            checkForUpdates();

            logger.debug("Registering internal commands...");
            runtime.getGeneralUtils().registerCommands();

            if (Bukkit.getPluginManager().isPluginEnabled("PlaceholderAPI")) {
                logger.info("Hooked into PlaceholderAPI — external placeholders enabled");
                placeholderAPI = true;
            } else {
                logger.warn("PlaceholderAPI not found — using internal placeholder system only");
                placeholderAPI = false;
            }
        } catch (Exception e) {
            logger.error("Failed to initialize CommandBridge: {}",
                    logger.getDebug() ? e : e.getMessage());
        }
    }

    public boolean isPlaceholderAPI() {
        return placeholderAPI;
    }

    public void stop() {
        try {
            logger.debug("Disconnecting from WebSocket server...");
            runtime.getClient().disconnect();
        } catch (Exception e) {
            logger.error("Failed to stop CommandBridge: {}",
                    logger.getDebug() ? e : e.getMessage());
        }
    }

    private void checkForUpdates() {
        String currentVersion = Main.getVersion();
        logger.debug("Current version: {}", currentVersion);
        new Thread(() -> {
            try {
                String latestVersion = VersionChecker.getLatestVersion();
                if (latestVersion == null) {
                    logger.warn("Unable to check for updates");
                    return;
                }
                if (VersionChecker.isNewerVersion(latestVersion, currentVersion)) {
                    logger.warn("A new version is available: {}", latestVersion);
                    logger.warn("Please download the latest release: {}", VersionChecker.getDownloadUrl());
                    runtime.getClient().sendError("Please update CommandBridge");
                } else {
                    logger.info("You are running the latest version: {}", currentVersion);
                }
            } catch (Exception e) {
                logger.error("Error while checking for updates: {}",
                        logger.getDebug() ? e : e.getMessage());
            }
        }).start();
    }
}
</file>

<file path="paper/src/main/java/dev/consti/commandbridge/paper/Main.java">
package dev.consti.commandbridge.paper;

import java.io.InputStream;
import java.util.Properties;

import org.bukkit.plugin.java.JavaPlugin;

import dev.consti.commandbridge.paper.core.Runtime;
import dev.consti.foundationlib.logging.Logger;
import dev.jorel.commandapi.CommandAPI;
import dev.jorel.commandapi.CommandAPIBukkitConfig;

public class Main extends JavaPlugin {
    private static Main instance;
    private final Logger logger;

    public Main() {
        instance = this;
        logger = Runtime.getInstance().getLogger();
    }
    
    public static String getVersion() {
        try (InputStream input = Main.class.getClassLoader().getResourceAsStream("plugin.properties")) {
            if (input == null) {
                return "Unknown";
            }
            Properties properties = new Properties();
            properties.load(input);
            return properties.getProperty("plugin.version", "Unknown");
        } catch (Exception e) {
            e.printStackTrace();
            return "Unknown";
        }
    }

    public static Main getInstance() {
        return instance;
    }


    @Override
    public void onLoad() {
        CommandAPI.onLoad(new CommandAPIBukkitConfig(this).verboseOutput(false).usePluginNamespace().silentLogs(true).skipReloadDatapacks(true).shouldHookPaperReload(false));
    }
    @Override
    public void onEnable() {
        CommandAPI.onEnable();
        logger.info("Initializing CommandBridge...");
        Runtime.getInstance().getStartup().start();
    }

    @Override
    public void onDisable() {
        CommandAPI.onDisable();
        logger.info("Stopping CommandBridge...");
        Runtime.getInstance().getStartup().stop();
    }

}
</file>

<file path="paper/src/main/resources/plugin.yml">
name: CommandBridge
version: 2.2.1
main: dev.consti.commandbridge.paper.Main
author: 72-S
api-version: '1.20'
folia-supported: true
softdepend:
- PlaceholderAPI
</file>

<file path="velocity/src/main/resources/velocity-example.yml">
##########################################################################
# EXAMPLE CONFIGURATION
# This file demonstrates how to dispatch a command to the Velocity server,
# where the commands are executed on the Bukkit servers.
##########################################################################

# The name of the command to be dispatched.
# This is the identifier for the command configuration.
name: examplecommand

# Enable or disable this command.
# Set to true to allow the command to be executed, or false to disable it.
enabled: true

# Ignore permission checks for this command.
# Set to true to bypass permission validation, or false to enforce it.
ignore-permission-check: false

# Hide permission warnings when the executor does not have the required permissions.
# Set to true to suppress warnings, or false to show them.
hide-permission-warning: false

# A list of commands to execute on the target servers.
commands:
  # Command 1
  - command: 'say Hello, world!'  # The command string to be executed (use single quotes).
    delay: 0                      # Delay (in seconds) before executing the command.
    target-client-ids:            # List of target server IDs where the command will be executed.
      - 'lobby'
      - 'survival'
    target-executor: 'player'     # Who executes the command: 'player' or 'console'.
    wait-until-player-is-online: true  # If true, waits until the player is online to execute.
    check-if-executor-is-player: true  # If true, ensures the executor is a player.
    check-if-executor-is-on-server: true # If true, ensures the executor is online on the server.

  # Command 2
  - command: 'say I love Coding!' # The command string to be executed (use single quotes).
    delay: 0                      # Delay (in seconds) before executing the command.
    target-client-ids:            # List of target server IDs where the command will be executed.
      - 'lobby'
    target-executor: 'player'     # Who executes the command: 'player' or 'console'.
    wait-until-player-is-online: true  # If true, waits until the player is online to execute.
    check-if-executor-is-player: false # If true, ensures the executor is a player.
    check-if-executor-is-on-server: false # If true, ensures the executor is online on the server.
</file>

<file path="server.sh">
#!/bin/bash

# Server paths
SERVER1_DIR="/mnt/Storage/Server-TEST/CommandBridge/Velocity/"
SERVER2_DIR="/mnt/Storage/Server-TEST/CommandBridge/Paper/"

# Server JAR files
SERVER1_JAR="velocity-3.3.0-SNAPSHOT-436.jar"
SERVER2_JAR="paper-1.20-17.jar"

# Function to run a server
run_server() {
  local server_dir=$1
  local server_jar=$2
  local extra_args=$3
  cd "$server_dir" || exit
  java -Xmx1024M -Xms1024M -jar "$server_jar" $extra_args
}

# Start the first server in the current terminal
echo "Starting Velocity server in the current terminal..."
run_server "$SERVER1_DIR" "$SERVER1_JAR" &

# Start the second server in a new Kitty terminal with nogui flag
echo "Starting Bukkit server in a new Kitty terminal..."
kitty bash -c "cd '$SERVER2_DIR' && java -Xmx1024M -Xms1024M -jar '$SERVER2_JAR' nogui; exec bash"

# Wait for the first server to complete
wait
</file>

<file path="velocity/src/main/resources/velocity-config.yml">
# Server Configuration File

# General debug mode.
# Set to true for detailed logs and diagnostics, or false for standard logging.
debug: false

# Unique identifier for the server.
# This helps distinguish between multiple servers in a network setup.
server-id: "main"

# The host address the server will bind to.
# You can use "127.0.0.1" to bind to the localhost interface (local connections only),
# or "0.0.0.0" to bind to all available network interfaces (accepts connections from all IPs).
# Change only if you know what you're doing.
host: "0.0.0.0"

# Server Address Name (SAN).
# Specify your server's public IP or domain name here if accessible from external networks.
# Example: san: "152.248.198.124"
san: ""

# The port number the server will listen on.
# Ensure this port is open and not used by another service.
port: 8080

# Timeout for the reload command.
# Specifies the time (in seconds) for clients to respond during a reload operation.
# Each second represents one retry for the client to send a successful request.
# If the client does not respond successfully within the timeout duration, the operation will fail.
# Example: timeout: 8 means clients have up to 8 seconds (or 8 tries) to respond.
timeout: 8
</file>

<file path="velocity/src/main/java/dev/consti/commandbridge/velocity/command/CommandRegistrar.java">
package dev.consti.commandbridge.velocity.command;

import java.util.HashMap;
import java.util.Map;

import com.mojang.brigadier.arguments.StringArgumentType;
import com.mojang.brigadier.builder.LiteralArgumentBuilder;
import com.mojang.brigadier.builder.RequiredArgumentBuilder;
import com.velocitypowered.api.command.BrigadierCommand;
import com.velocitypowered.api.command.CommandMeta;
import com.velocitypowered.api.command.CommandSource;
import com.velocitypowered.api.proxy.ProxyServer;

import dev.consti.commandbridge.velocity.core.Runtime;
import dev.consti.commandbridge.velocity.util.ProxyUtils;
import dev.consti.foundationlib.logging.Logger;
import dev.consti.foundationlib.utils.ScriptManager;

public class CommandRegistrar {
    private final Logger logger;
    private final ProxyServer proxy;
    private final CommandForwarder helper;
    private final Map<String, CommandMeta> registeredCommands = new HashMap<>();

    public CommandRegistrar(Logger logger) {
        this.logger = logger;
        this.proxy = ProxyUtils.getProxyServer();
        this.helper = Runtime.getInstance().getHelper();
    }


    public void unregisterAllCommands() {
        for (String command : registeredCommands.keySet()) {
            try {
                CommandMeta commandMeta = registeredCommands.get(command);
                proxy.getCommandManager().unregister(commandMeta);
                logger.debug("Unregistered command: {}", command);
            } catch (Exception e) {
                logger.error("Failed to unregister command '{}' : {}",
                        command,
                        logger.getDebug() ? e : e.getMessage()
                );
            }
        }
        registeredCommands.clear();
        logger.info("All registered commands have been unregistered.");
    }


    public void registerCommand(ScriptManager.ScriptConfig script) {
        String commandName = script.getName();
        try {
            LiteralArgumentBuilder<CommandSource> commandBuilder = LiteralArgumentBuilder.<CommandSource>literal(commandName)
                    .executes(context -> {
                        logger.debug("Executing base command: {}", commandName);
                        return helper.executeScriptCommands(context.getSource(), script, new String[0]);
                    });
            RequiredArgumentBuilder<CommandSource, String> argsArgument =
                    RequiredArgumentBuilder.<CommandSource, String>argument("args", StringArgumentType.greedyString())
                            .executes(context -> {
                                String argsString = context.getArgument("args", String.class);
                                logger.debug("Command '{}' called with arguments: {}", commandName, argsString);
                                String[] args = argsString.split(" ");
                                return helper.executeScriptCommands(context.getSource(), script, args);
                            });
            commandBuilder.then(argsArgument);

            // LiteralCommandNode<CommandSource> rootNode = commandBuilder.build();
            BrigadierCommand brigadierCommand = new BrigadierCommand(commandBuilder.build());
            CommandMeta commandMeta = proxy.getCommandManager().metaBuilder(commandName).build();

            proxy.getCommandManager().register(commandMeta, brigadierCommand);
            registeredCommands.put(commandName, commandMeta);
        } catch (Exception e) {
            logger.error(
                    "Failed to register command '{}' : {}",
                    commandName,
                    logger.getDebug() ? e : e.getMessage()
            );
        }
    }


}
</file>

<file path="velocity/src/main/java/dev/consti/commandbridge/velocity/helper/command/ReloadCommand.java">
package dev.consti.commandbridge.velocity.helper.command;

import com.mojang.brigadier.builder.LiteralArgumentBuilder;
import com.velocitypowered.api.command.CommandSource;
import dev.consti.commandbridge.velocity.core.Runtime;
import dev.consti.commandbridge.velocity.util.GeneralUtils;
import dev.consti.foundationlib.json.MessageBuilder;
import dev.consti.foundationlib.logging.Logger;
import net.kyori.adventure.text.Component;
import net.kyori.adventure.text.format.NamedTextColor;

public class ReloadCommand {

    public static LiteralArgumentBuilder<CommandSource> build(GeneralUtils utils, Logger logger) {
        return LiteralArgumentBuilder.<CommandSource>literal("reload")
                .executes(context -> {
                    CommandSource source = context.getSource();
                    if (!source.hasPermission("commandbridge.admin")) {
                        source.sendMessage(
                                Component.text("You do not have permission to reload the plugin", NamedTextColor.RED));
                        return 0;
                    }

                    try {
                        // Logic from original reload command
                        Runtime.getInstance().getRegistrar().unregisterAllCommands();
                        logger.debug("All commands have been unregistered");

                        Runtime.getInstance().getConfig().reload();
                        logger.debug("Configuration files have been reloaded");

                        logger.setDebug(
                                Boolean.parseBoolean(Runtime.getInstance().getConfig().getKey("config.yml", "debug")));
                        logger.info("Debug mode set to: {}", Runtime.getInstance().getConfig().getKey("config.yml", "debug"));

                        Runtime.getInstance().getScriptUtils().reload();
                        logger.debug("Scripts have been reloaded");

                        Runtime.getInstance().getGeneralUtils().unregisterCommands();
                        logger.debug("Internal commands have been unregistered");

                        Runtime.getInstance().getGeneralUtils().registerCommands();
                        logger.debug("Internal commands have been registered");

                        MessageBuilder builder = new MessageBuilder("system");
                        builder.addToBody("channel", "task").addToBody("task", "reload").addToBody("server",
                                Runtime.getInstance().getConfig().getKey("config.yml", "server-id"));

                        Runtime.getInstance().getServer().broadcastServerMessage(builder.build());
                        logger.debug("Sending payload: {}", builder.build());
                        source.sendMessage(
                                Component.text("Waiting for clients to respond...")
                                        .color(NamedTextColor.YELLOW));
                        logger.debug("Waiting for clients to respond...");
                        utils.startFailureCheck(source);
                        return 1;
                    } catch (Exception e) {
                        logger.error("An error occurred during the reload process: {}", e.getMessage(), e);
                        source.sendMessage(
                                Component.text("ReloadCommand failed due to an internal error. Check logs for details")
                                        .color(NamedTextColor.RED));
                    }
                    return 1;

                });
    }
}
</file>

<file path="velocity/src/main/java/dev/consti/commandbridge/velocity/core/Startup.java">
package dev.consti.commandbridge.velocity.core;


import dev.consti.commandbridge.velocity.Main;
import dev.consti.commandbridge.velocity.websocket.Server;
import dev.consti.foundationlib.logging.Logger;
import dev.consti.foundationlib.utils.VersionChecker;

public class Startup {
    private final Logger logger;
    private final Runtime runtime;
    private boolean placeholderAPI = false;

    public Startup(Logger logger) {
        this.logger = logger;
        this.runtime = Runtime.getInstance();
    }

    public void start() {
        try {
            runtime.getConfig().copyConfig("velocity-config.yml", "config.yml");
            runtime.getConfig().loadAllConfigs();
            runtime.getConfig().loadSecret();

            boolean debugMode = Boolean.parseBoolean(runtime.getConfig().getKey("config.yml", "debug"));
            logger.setDebug(debugMode);
            logger.debug("Debug mode set to: {}", debugMode);

            logger.debug("Copying default scripts...");
            runtime.getScriptUtils().copyDefaultScript("velocity-example.yml", "example.yml");
            runtime.getScriptUtils().loadAllScripts();

            logger.debug("Starting WebSocket server...");
            runtime.getServer().startServer(
                    Integer.parseInt(runtime.getConfig().getKey("config.yml", "port")),
                    runtime.getConfig().getKey("config.yml", "host"),
                    runtime.getConfig().getKey("config.yml", "san")
            );

            logger.debug("Setting up version checker...");
            VersionChecker.setProjectId("wIuI4ru2");

            logger.debug("Checking for updates...");
            checkForUpdates();

            logger.debug("Registering internal commands...");
            runtime.getGeneralUtils().registerCommands();

            if (Main.getInstance().proxy.getPluginManager().getPlugin("papiproxybridge").isPresent()) {
                logger.info("Hooked into PapiProxyBridge — PlaceholderAPI placeholders enabled");
                placeholderAPI = true;
            } else {
                logger.warn("PapiProxyBridge not found — using internal placeholder system only");
                placeholderAPI = false;
            }
        } catch (Exception e) {
            logger.error("Failed to initialize CommandBridge: {}",
                    logger.getDebug() ? e : e.getMessage()
            );
        }
    }

    public boolean isPlaceholderAPI() {
        return placeholderAPI;
    }

    public void stop() {
        try {
            Server server = runtime.getServer();
            logger.debug("Stopping WebSocket server...");
            for (String conn : server.getConnectedClients()) {
                runtime.getServer().sendTask(server.getWebSocket(conn), "reconnect", "closed");
            }
            runtime.getServer().stopServer(0);
        } catch (Exception e) {
            logger.error("Failed to stop CommandBridge: {}", logger.getDebug() ? e : e.getMessage());
        }
    }

    private void checkForUpdates() {
        String currentVersion = Main.getVersion();
        logger.debug("Current version: {}", currentVersion);
        new Thread(() -> {
            try {
                String latestVersion = VersionChecker.getLatestVersion();
                if (latestVersion == null) {
                    logger.warn("Unable to check for updates");
                    return;
                }
                if (VersionChecker.isNewerVersion(latestVersion, currentVersion)) {
                    logger.warn("A new version is available: {}", latestVersion);
                    logger.warn("Please download the latest release: {}", VersionChecker.getDownloadUrl());
                } else {
                    logger.info("You are running the latest version: {}", currentVersion);
                }
            } catch (Exception e) {
                logger.error("Error while checking for updates: {}", logger.getDebug() ? e : e.getMessage());
            }
        }).start();
    }
}
</file>

<file path="velocity/src/main/java/dev/consti/commandbridge/velocity/command/CommandForwarder.java">
package dev.consti.commandbridge.velocity.command;

import java.util.List;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.TimeUnit;

import com.velocitypowered.api.command.CommandSource;
import com.velocitypowered.api.proxy.Player;
import com.velocitypowered.api.proxy.ProxyServer;

import dev.consti.commandbridge.velocity.Main;
import dev.consti.commandbridge.velocity.core.Runtime;
import dev.consti.commandbridge.velocity.util.ProxyUtils;
import dev.consti.foundationlib.logging.Logger;
import dev.consti.foundationlib.utils.ScriptManager;
import dev.consti.foundationlib.utils.StringParser;
import net.kyori.adventure.text.Component;
import net.kyori.adventure.text.format.NamedTextColor;
import net.william278.papiproxybridge.api.PlaceholderAPI;

public class CommandForwarder {
    private final Logger logger;
    private final ProxyServer proxy;
    private final Main plugin;

    public CommandForwarder(Logger logger, Main plugin) {
        this.logger = logger;
        this.proxy = ProxyUtils.getProxyServer();
        this.plugin = plugin;
    }

    public int executeScriptCommands(CommandSource source, ScriptManager.ScriptConfig script, String[] args) {
        logger.debug("Executing script commands for script: {}", script.getName());

        if (isPermissionDenied(source, script)) {
            return 0;
        }

        for (ScriptManager.Command cmd : script.getCommands()) {
            logger.debug("Processing command: {}", cmd.getCommand());

            switch (cmd.getTargetExecutor().toLowerCase()) {
                case "player" -> handlePlayerExecutor(cmd, source, args);
                case "console" -> handleConsoleExecutor(cmd, source, args);
                default -> logger.warn("Unknown target executor for command: {}", cmd.getCommand());
            }
        }

        logger.info("Script commands executed successfully for command: {}", script.getName());
        return com.mojang.brigadier.Command.SINGLE_SUCCESS;
    }

    private boolean isPermissionDenied(CommandSource source, ScriptManager.ScriptConfig script) {
        if (!script.shouldIgnorePermissionCheck()
                && !source.hasPermission("commandbridge.command." + script.getName())) {
            logger.warn("Sender '{}' has no permission to use this command", source);
            if (!script.shouldHidePermissionWarning()) {
                source.sendMessage(
                        Component.text("You do not have permission to use this command", NamedTextColor.RED));
            }
            return true;
        }
        return false;
    }

    private void handlePlayerExecutor(ScriptManager.Command cmd, CommandSource source, String[] args) {
        if (cmd.isCheckIfExecutorIsPlayer() && !(source instanceof Player)) {
            logger.warn("This command requires a player as executor, but source is not a player");
            source.sendMessage(
                    Component.text("This command requires a player as executor, but source is not a player object",
                            NamedTextColor.RED));
            return;
        }

        Player player = (Player) source;

        // Check if the player is on the required server if needed
        if (cmd.isCheckIfExecutorIsOnServer() && !isPlayerOnTargetServer(player, cmd)) {
            logger.warn("Player '{}' is not on the required server for this command.", player.getUsername());
            source.sendMessage(Component.text("Player " + player.getUsername() + " is not on the required server",
                    NamedTextColor.YELLOW));
            return;
        }

        parseCommand(cmd, args, player).thenAccept(parsedCommand -> {
            if (parsedCommand == null)
                return;

            if (cmd.getDelay() > 0) {
                scheduleCommand(cmd, parsedCommand, args, player, 0);
            } else {
                sendCommand(cmd, parsedCommand, args, player, 0);
            }
        });

    }

    private void handleConsoleExecutor(ScriptManager.Command cmd, CommandSource source, String[] args) {

        parseCommand(cmd, args, null).thenAccept(parsedCommand -> {
            if (parsedCommand == null)
                return;

            if (cmd.getDelay() > 0) {
                scheduleCommand(cmd, parsedCommand, args, null, 0);
            } else {
                sendCommand(cmd, parsedCommand, args, null, 0);
            }
        });

    }

    private boolean isPlayerOnTargetServer(Player player, ScriptManager.Command cmd) {
        return player.getCurrentServer()
                .map(serverConn -> cmd.getTargetClientIds().contains(serverConn.getServerInfo().getName()))
                .orElse(false);
    }

    private CompletableFuture<String> parseCommand(ScriptManager.Command cmd, String[] args, Player player) {
        StringParser parser = StringParser.create();

        if (player != null && cmd.getTargetExecutor().equals("player")) {
            addPlayerPlaceholders(parser, player);
        } else {
            return CompletableFuture.completedFuture(parser.parsePlaceholders(cmd.getCommand(), args));
        }

        try {
            String parsedCommand = parser.parsePlaceholders(cmd.getCommand(), args);

            if (Runtime.getInstance().getStartup().isPlaceholderAPI()) {
                return PlaceholderAPI.createInstance()
                        .formatPlaceholders(parsedCommand, player.getUniqueId())
                        .exceptionally(e -> {
                            logger.error("PlaceholderAPI error: {}", logger.getDebug() ? e : e.getMessage());
                            return parsedCommand; // Fallback
                        });
            }

            return CompletableFuture.completedFuture(parsedCommand);
        } catch (Exception e) {
            logger.error("Error occurred while parsing command: {}", logger.getDebug() ? e : e.getMessage());
            if (player != null) {
                player.sendMessage(Component.text("Error occurred while parsing command").color(NamedTextColor.RED));
            }
            for (String conn : cmd.getTargetClientIds()) {
                Runtime.getInstance().getServer().sendError(
                        Runtime.getInstance().getServer().getWebSocket(conn),
                        "Error occurred while parsing commands");
            }

            return CompletableFuture.completedFuture(null);
        }
    }

    private void addPlayerPlaceholders(StringParser parser, Player player) {
        logger.debug("Adding placeholders for player: {}", player.getUsername());
        parser.addPlaceholder("%player%", player.getUsername());
        parser.addPlaceholder("%uuid%", player.getUniqueId().toString());
        parser.addPlaceholder("%server%", player.getCurrentServer()
                .map(srv -> srv.getServerInfo().getName())
                .orElse("defaultServerName"));
    }

    private void scheduleCommand(ScriptManager.Command cmd, String command, String[] args, Player player,
            int retryCount) {
        logger.debug("Scheduling command '{}' with delay: {} seconds", cmd.getCommand(), cmd.getDelay());
        proxy.getScheduler().buildTask(plugin, () -> sendCommand(cmd, command, args, player, retryCount))
                .delay(cmd.getDelay(), TimeUnit.SECONDS)
                .schedule();
    }

    private void sendCommand(ScriptManager.Command cmd, String command, String[] args, Player player, int retryCount) {
        logger.debug("Executing command: {} with retryCount: {}", cmd.getCommand(), retryCount);

        // Prevent infinite loops
        if (retryCount >= 30) {
            logger.warn("Max retries reached for command: {}", cmd.getCommand());
            if (player != null) {
                player.sendMessage(Component.text("Max retries reached", NamedTextColor.YELLOW));
            }
            return;
        }

        // If we need the player to be online, check it here
        if (cmd.shouldWaitUntilPlayerIsOnline() && "player".equalsIgnoreCase(cmd.getTargetExecutor())) {
            if (player == null || !player.isActive()) {
                logger.warn("Player is not online. Retrying command: {}", cmd.getCommand());
                player.sendMessage(Component.text("Player is not online. Retrying command", NamedTextColor.YELLOW));
                proxy.getScheduler().buildTask(plugin, () -> sendCommand(cmd, command, args, player, retryCount + 1))
                        .delay(1, TimeUnit.SECONDS)
                        .schedule();
                return;
            }
        }

        List<String> targetClients = cmd.getTargetClientIds();
        if (targetClients.isEmpty()) {
            logger.warn("No target clients defined for command: {}", cmd.getCommand());
            if (player != null) {
                player.sendMessage(
                        Component.text("No target clients are defined for this command", NamedTextColor.RED));
            }
            return;
        }

        for (String clientId : targetClients) {
            if (Runtime.getInstance().getServer().isServerConnected(clientId)) {
                logger.info("Sending command to client '{}' as {}", clientId, player == null ? "console" : "player");
                Runtime.getInstance().getServer().sendCommand(command, clientId, cmd.getTargetExecutor(), player);
            } else {
                logger.warn("Client '{}' not found", clientId);
                if (player != null) {
                    player.sendMessage(Component.text("Client '" + clientId + "' not found", NamedTextColor.RED));
                }
            }
        }
    }
}
</file>

<file path="velocity/src/main/java/dev/consti/commandbridge/velocity/websocket/Server.java">
package dev.consti.commandbridge.velocity.websocket;

import java.util.*;

import com.velocitypowered.api.proxy.Player;

import dev.consti.commandbridge.velocity.core.Runtime;
import dev.consti.foundationlib.json.MessageBuilder;
import dev.consti.foundationlib.json.MessageParser;
import dev.consti.foundationlib.logging.Logger;
import dev.consti.foundationlib.websocket.SimpleWebSocketServer;
import io.netty.channel.Channel;

public class Server extends SimpleWebSocketServer {
    private final Logger logger;
    private final Map<String, Channel> clientConnections = new HashMap<>();

    public Server(Logger logger, String secret) {
        super(logger, secret);
        super.addHttpHandler(Runtime.getInstance().getHttpServer());
        this.logger = logger;
    }

    @Override
    protected void onMessage(Channel webSocket, String message) {
        MessageParser parser = new MessageParser(message);
        logger.debug("Received message: {}", message);
        try {
            String type = parser.getType();
            switch (type) {
                case "command" -> handleCommandRequest(webSocket, message);
                case "system" -> handleSystemRequest(webSocket, message);
                default -> {
                    logger.warn("Invalid type: {}", type);
                    sendError(webSocket, "Invalid type: " + type);
                }
            }
        } catch (Exception e) {
            logger.error("Error while processing message: {}",
                    logger.getDebug() ? e : e.getMessage());
            sendError(webSocket, "Internal server error: " + e.getMessage());
        }
    }

    @Override
    protected void onConnectionClose(Channel conn, int code, String reason) {
        String clientAddress = conn.remoteAddress().toString();

        if (getConnections().contains(conn)) {
            String disconnectedClientName = clientConnections.entrySet().stream()
                    .filter(entry -> entry.getValue().equals(conn))
                    .map(Map.Entry::getKey)
                    .findFirst()
                    .orElse(null);

            logger.info("Client '{}' disconnected", clientAddress);
            if (disconnectedClientName != null) {
                clientConnections.remove(disconnectedClientName);
                logger.debug("Removed disconnected client: {}", disconnectedClientName);
            } else {
                logger.warn("Disconnected WebSocket client '{}' not found in client connections map.", clientAddress);
            }
        } 
    }

    private void handleCommandRequest(Channel webSocket, String message) {
        logger.debug("Handling command request");
        Runtime.getInstance().getCommandExecutor().dispatchCommand(message);
    }

    private void handleSystemRequest(Channel webSocket, String message) {
        logger.debug("Handling system request");
        MessageParser parser = new MessageParser(message);
        String channel = parser.getBodyValueAsString("channel");
        String name = parser.getBodyValueAsString("name");
        String client = parser.getBodyValueAsString("client");
        String status = parser.getStatus();

        switch (channel) {
            case "name" -> {
                if (name != null) {
                    clientConnections.put(name, webSocket);
                    logger.info("Added connected client: {}", name);
                } else {
                    logger.warn("Client did not provide 'name' in system request");
                }
            }
            case "error" -> logger.warn("Error Message from client '{}' : {}", client, status);
            case "info" -> logger.info("Info from client '{}' : {}", client, status);
            case "task" -> systemTask(parser, status, client);
            default -> logger.warn("Invalid channel: {}", channel);
        }
    }

    private void systemTask(MessageParser parser, String status, String client) {
        String task = parser.getBodyValueAsString("task");
        switch (task) {
            case "reload" -> Runtime.getInstance().getGeneralUtils().addClientToStatus(client, parser.getStatus());
            default -> logger.warn("Invalid task: {}", task);
        }
    }

    public void sendError(Channel webSocket, String errorMessage) {
        MessageBuilder builder = new MessageBuilder("system");
        builder.addToBody("channel", "error")
                .addToBody("server", Runtime.getInstance().getConfig().getKey("config.yml", "server-id"))
                .withStatus(errorMessage);
        sendMessage(builder.build(), webSocket);
    }

    public void sendInfo(Channel webSocket, String infoMessage) {
        MessageBuilder builder = new MessageBuilder("system");
        builder.addToBody("channel", "info")
                .addToBody("server", Runtime.getInstance().getConfig().getKey("config.yml", "server-id"))
                .withStatus(infoMessage);
        sendMessage(builder.build(), webSocket);
    }

    public void sendTask(Channel webSocket, String task, String status) {
        MessageBuilder builder = new MessageBuilder("system");
        builder.addToBody("channel", "task").addToBody("task", task)
                .addToBody("server", Runtime.getInstance().getConfig().getKey("config.yml", "server-id"))
                .withStatus(status);
        sendMessage(builder.build(), webSocket);
    }

    public void sendCommand(String command, String client, String target, Player executor) {
        Channel conn = clientConnections.get(client);
        if (conn == null) {
            logger.warn("Client '{}' is not connected, cannot send message.", client);
            return;
        }

        MessageBuilder builder = new MessageBuilder("command");
        builder.addToBody("command", command).addToBody("client", client).addToBody("target", target);

        if (target.equals("player")) {
            builder.addToBody("name", executor.getUsername()).addToBody("uuid", executor.getUniqueId());
        }
        logger.info("Sending command '{}' to client: {}", command, client);
        logger.debug("Sending payload: {}", builder.build().toString());
        sendMessage(builder.build(), conn);
    }

    public boolean isServerConnected(String clientName) {
        boolean exists = clientConnections.containsKey(clientName);
        logger.debug("Checking if client '{}' is connected: {}", clientName, exists);
        return exists;
    }

    public Set<String> getConnectedClients() {
        return clientConnections.keySet();
    }

    public Channel getWebSocket(String client) {
        return clientConnections.get(client);
    }

}
</file>

<file path="CHANGELOG.md">
**[v2.2.1] - 2025-04-25**

- Fixed issues with the Metrics class causing runtime errors.
- Resolved an "Internal Server Error" when players lacked permission.
- Added full support for Folia, ensuring compatibility and improved performance.
</file>

<file path="velocity/src/main/java/dev/consti/commandbridge/velocity/Main.java">
package dev.consti.commandbridge.velocity;

import java.io.InputStream;
import java.util.Properties;

import org.bstats.velocity.Metrics;

import com.google.inject.Inject;
import com.velocitypowered.api.event.Subscribe;
import com.velocitypowered.api.event.connection.PostLoginEvent;
import com.velocitypowered.api.event.proxy.ProxyInitializeEvent;
import com.velocitypowered.api.event.proxy.ProxyShutdownEvent;
import com.velocitypowered.api.plugin.Plugin;
import com.velocitypowered.api.proxy.Player;
import com.velocitypowered.api.proxy.ProxyServer;

import dev.consti.commandbridge.velocity.core.Runtime;
import dev.consti.commandbridge.velocity.util.ProxyUtils;
import dev.consti.foundationlib.logging.Logger;
import dev.consti.foundationlib.utils.VersionChecker;
import net.kyori.adventure.text.Component;
import net.kyori.adventure.text.event.ClickEvent;
import net.kyori.adventure.text.format.NamedTextColor;
import net.kyori.adventure.text.format.TextDecoration;

@Plugin(id = "commandbridge", name = "CommandBridge", version = "Unknown", authors = "72-S")
public class Main {
    private static Main instance;
    public final ProxyServer proxy;
    private final Logger logger;
    private final Metrics.Factory metricsFactory;

    @Inject
    public Main(ProxyServer proxy, Logger bLogger, Metrics.Factory metricsFactory) {
        this.proxy = proxy;
        this.logger = Runtime.getInstance().getLogger();
        instance = this;
        this.metricsFactory = metricsFactory;
        ProxyUtils.setProxyServer(proxy);
    }

    public static Main getInstance() {
        return instance;
    }

    public static String getVersion() {
        try (InputStream input = Main.class.getClassLoader().getResourceAsStream("plugin.properties")) {
            if (input == null) {
                return "Unknown";
            }
            Properties properties = new Properties();
            properties.load(input);
            return properties.getProperty("plugin.version", "Unknown");
        } catch (Exception e) {
            e.printStackTrace();
            return "Unknown";
        }
    }

    @Subscribe
    public void onProxyInitialization(ProxyInitializeEvent event) {
        logger.info("Initializing CommandBridge...");
        Runtime.getInstance().getStartup().start();
        int pluginId = 22008;
        metricsFactory.make(this, pluginId);

    }

    @Subscribe
    public void onProxyShutdown(ProxyShutdownEvent event) {
        logger.info("Stopping CommandBridge...");
        Runtime.getInstance().getStartup().stop();
    }

    @Subscribe
    public void onPlayerJoin(PostLoginEvent event) {
        Player player = event.getPlayer();
        if (player == null) {
            logger.warn("PostLoginEvent triggered with a null player object.");
            return;
        }

        if (player.hasPermission("commandbridge.admin")) {
            logger.debug("Player '{}' has admin permissions. Checking for updates...", player.getUsername());

            proxy.getScheduler().buildTask(this, () -> {
                String currentVersion = Main.getVersion();
                String latestVersion = VersionChecker.getLatestVersion();

                if (latestVersion == null) {
                    player.sendMessage(Component.text("Unable to check for updates.").color(NamedTextColor.RED));
                    logger.warn("Update check failed: Unable to retrieve the latest version.");
                    return;
                }

                if (VersionChecker.isNewerVersion(latestVersion, currentVersion)) {
                    player.sendMessage(Component.text("A new version of CommandBridge is available: " + latestVersion)
                            .color(NamedTextColor.RED));
                    player.sendMessage(Component.text("Please download the latest release: ")
                            .append(Component.text("here")
                                    .color(NamedTextColor.BLUE)
                                    .decorate(TextDecoration.UNDERLINED)
                                    .clickEvent(ClickEvent.openUrl(VersionChecker.getDownloadUrl()))));
                    logger.debug("Notified player '{}' about the new version: {}", player.getUsername(), latestVersion);
                } else {
                    logger.debug("Player '{}' is running the latest version: {}", player.getUsername(), currentVersion);
                }
            }).schedule();
        } else {
            logger.debug("Player {} does not have admin permissions. No update check performed.", player.getUsername());
        }
    }
}
</file>

<file path="paper/src/main/resources/paper-plugin.yml">
name: CommandBridge
version: 2.2.1
main: dev.consti.commandbridge.paper.Main
author: 72-S
api-version: '1.20'
folia-supported: true
dependencies:
  server:
    PlaceholderAPI:
      load: BEFORE
      required: false
</file>

<file path="paper/build.gradle.kts">
buildscript {
    repositories {
      mavenCentral()
    }
    dependencies {
        classpath("org.yaml:snakeyaml:2.3")

    }
}

import org.yaml.snakeyaml.DumperOptions
import org.yaml.snakeyaml.Yaml

plugins {
    id("java")
    id("com.gradleup.shadow") version "8.3.3"
}

val pversion: String by gradle.extra

group = "dev.consti"
version = pversion

repositories {
    mavenCentral()
    maven { url = uri("https://repo.papermc.io/repository/maven-public/") }
    maven { url = uri("https://repo.codemc.org/repository/maven-public/") }
    maven { url = uri("https://hub.spigotmc.org/nexus/content/repositories/snapshots/")}
    maven { url = uri("https://repo.extendedclip.com/releases/")}
    maven {
        name = "GitHubPackages"
        url = uri("https://maven.pkg.github.com/72-S/FoundationLib")
        credentials {
            username = "72-S"
            password = System.getenv("GITHUB_TOKEN")
        }
    }
}

java {
    toolchain {
        languageVersion.set(JavaLanguageVersion.of(21))
    }
}

dependencies {
    // compileOnly("io.papermc.paper:paper-api:1.20-R0.1-SNAPSHOT")
    // compileOnly("org.spigotmc:spigot-api:1.20-R0.1-SNAPSHOT")
    compileOnly("dev.folia:folia-api:1.20.1-R0.1-SNAPSHOT")
    implementation("org.ow2.asm:asm:9.7")
    implementation("dev.consti:foundationlib:2.2.3")
    implementation("dev.jorel:commandapi-bukkit-shade:9.7.0")
    compileOnly("dev.jorel:commandapi-annotations:9.7.0")
    compileOnly("me.clip:placeholderapi:2.11.6")
    annotationProcessor("dev.jorel:commandapi-annotations:9.7.0")
}


tasks.register("modifyPaperPluginYaml") {
    doLast {
        
        val yamlFile = file("src/main/resources/paper-plugin.yml") 

        if (yamlFile.exists()) {
            println("Found paper-plugin.yml")

            val options = DumperOptions().apply {
                defaultFlowStyle = DumperOptions.FlowStyle.BLOCK
            }
            val yaml = Yaml(options)

            val yamlContent = yaml.load<Map<String, Any>>(yamlFile.reader()).toMutableMap()

            yamlContent["version"] = pversion

            yamlFile.writer().use { writer ->
                yaml.dump(yamlContent, writer)
            }

            println("paper-plugin.yml updated successfully with version ${pversion}")
        } else {
            println("paper-plugin.yml not found!")
        }
    }
}

tasks.register("modifyLegacyPluginYaml") {
    doLast {
        
        val yamlFile = file("src/main/resources/plugin.yml") 

        if (yamlFile.exists()) {
            println("Found legacy plugin.yml")

            val options = DumperOptions().apply {
                defaultFlowStyle = DumperOptions.FlowStyle.BLOCK
            }
            val yaml = Yaml(options)

            val yamlContent = yaml.load<Map<String, Any>>(yamlFile.reader()).toMutableMap()

            yamlContent["version"] = pversion

            yamlFile.writer().use { writer ->
                yaml.dump(yamlContent, writer)
            }

            println("legacy plugin.yml updated successfully with version ${pversion}")
        } else {
            println("legacy plugin.yml not found!")
        }
    }
}

tasks.named("processResources") {
    dependsOn("modifyPaperPluginYaml")
    dependsOn("modifyLegacyPluginYaml")
}
</file>

<file path="settings.gradle.kts">
rootProject.name = "CommandBridge"
include("paper", "velocity")


gradle.extra["pversion"] = "2.2.1"


gradle.extra["pluginType"] = "release"

gradle.extra["pluginVersions"] = listOf("1.20", "1.20.1", "1.20.2", "1.20.3", "1.20.4", "1.20.5", "1.20.6", "1.21", "1.21.1", "1.21.2", "1.21.3", "1.21.4")

gradle.extra["pluginLoaders"] = listOf("folia", "paper", "purpur", "velocity", "bukkit", "spigot", "waterfall")
</file>

<file path="velocity/build.gradle.kts">
import com.google.gson.JsonObject
import com.google.gson.JsonParser
import java.nio.file.Files

plugins {
    id("java")
}

val pversion: String by gradle.extra

group = "dev.consti"
version = pversion

repositories {
    mavenCentral()
    maven { url = uri("https://repo.papermc.io/repository/maven-public/") }
    maven { url = uri("https://repo.william278.net/releases/") }
    maven {
        name = "GitHubPackages"
        url = uri("https://maven.pkg.github.com/72-S/FoundationLib")
        credentials {
            username = "72-S"
            password = System.getenv("GITHUB_TOKEN")
        }
    }
}

java {
    toolchain {
        languageVersion.set(JavaLanguageVersion.of(21))
    }
}

dependencies {
    compileOnly("com.velocitypowered:velocity-api:3.4.0-SNAPSHOT")
    annotationProcessor("com.velocitypowered:velocity-api:3.4.0-SNAPSHOT")
    implementation("dev.consti:foundationlib:2.2.3")
    compileOnly("net.william278:papiproxybridge:1.7.2")
    implementation("org.bstats:bstats-velocity:3.1.0")
}


tasks.register("modifyVelocityPluginJson") {
    doLast {
        val jsonFile = layout.buildDirectory.file("classes/java/main/velocity-plugin.json").get().asFile
        if (jsonFile.exists()) {
            println("Found velocity-plugin.json")

            val jsonContent = Files.readString(jsonFile.toPath())
            val jsonObject = JsonParser.parseString(jsonContent).asJsonObject

            jsonObject.addProperty("version", pversion)

            Files.writeString(jsonFile.toPath(), jsonObject.toString())
            println("velocity-plugin.json updated successfully with version ${pversion}")
        } else {
            println("velocity-plugin.json not found")
        }
    }
}

tasks.register("generatePluginProperties") {
    doLast {
        println("Generating plugin.properties file")

        val propertiesFile = layout.buildDirectory.file("resources/main/plugin.properties").get().asFile
        propertiesFile.parentFile.mkdirs()
        propertiesFile.writeText("""
            plugin.version=${pversion}
        """.trimIndent())

        println("Successfully generated plugin.properties file")
    }
}


tasks.named("processResources") {
    dependsOn("generatePluginProperties")
    finalizedBy("modifyVelocityPluginJson")
}
</file>

<file path="build.gradle.kts">
plugins {
    id("java")
    id("com.gradleup.shadow") version "8.3.3"
    id("maven-publish")
    id("com.modrinth.minotaur") version "2.+"
}

val pversion: String by gradle.extra
val pluginType: String by gradle.extra
val pluginVersions: List<String> by gradle.extra
val pluginLoaders: List<String> by gradle.extra

group = "dev.consti"

version = pversion

repositories {
    mavenCentral()
    maven {
        name = "GitHubPackages"
        url = uri("https://maven.pkg.github.com/72-S/FoundationLib")
        credentials {
            username = "72-S"
            password = System.getenv("GITHUB_TOKEN")
        }
    }
    maven { url = uri("https://repo.william278.net/releases/") }
    maven { url = uri("https://repo.extendedclip.com/releases/") }
}

dependencies {
    implementation(project(":paper"))
    implementation(project(":velocity"))
}

java { toolchain { languageVersion.set(JavaLanguageVersion.of(21)) } }

tasks {
    // Configure the existing shadowJar task, don't register a new one
    shadowJar {
        dependsOn(":paper:shadowJar")
        manifest { attributes["paperweight-mappings-namespace"] = "spigot" }

        relocate("dev.jorel.commandapi", "dev.consti.commandbridge.commandapi")
        relocate("org.bstats", "dev.consti.commandbridge.bstats")

        // Include the compiled outputs of core, paper, and velocity
        from(
                project(":paper")
                        .takeIf { it.plugins.hasPlugin("java") }
                        ?.sourceSets
                        ?.main
                        ?.get()
                        ?.output
                        ?: files()
        )
        from(
                project(":velocity")
                        .takeIf { it.plugins.hasPlugin("java") }
                        ?.sourceSets
                        ?.main
                        ?.get()
                        ?.output
                        ?: files()
        )

        configurations = listOf(project.configurations.runtimeClasspath.get())
        mergeServiceFiles()
    }

    val copyToPaperPlugins by
            registering(Copy::class) {
                dependsOn(shadowJar)
                from(shadowJar.get().outputs.files)
                into("/mnt/Storage/Server-TEST/CommandBridge/Paper/plugins")
            }

    val copyToVelocityPlugins by
            registering(Copy::class) {
                dependsOn(shadowJar)
                from(shadowJar.get().outputs.files)
                into("/mnt/Storage/Server-TEST/CommandBridge/Velocity/plugins")
            }

    register("dev") { dependsOn(copyToPaperPlugins, copyToVelocityPlugins) }
}

afterEvaluate {
    modrinth {
        token.set(System.getenv("MODRINTH_TOKEN"))
        projectId.set("wIuI4ru2")
        versionName.set("CommandBridge $pversion")
        changelog.set(rootProject.file("CHANGELOG.md").readText())
        versionNumber.set(pversion)
        versionType.set(pluginType)
        uploadFile.set(tasks.shadowJar)
        gameVersions.set(pluginVersions)
        loaders.set(pluginLoaders)
        debugMode.set(false)
    }
}
</file>

</files>
