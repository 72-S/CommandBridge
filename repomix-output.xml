This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
gradle/
  wrapper/
    gradle-wrapper.properties
paper/
  src/
    main/
      java/
        dev/
          consti/
            commandbridge/
              paper/
                command/
                  CommandExecutor.java
                  CommandForwarder.java
                  CommandRegistrar.java
                core/
                  Runtime.java
                  Startup.java
                utils/
                  CommandUtils.java
                  GeneralUtils.java
                  SchedulerAdapter.java
                  ScriptUtils.java
                websocket/
                  Client.java
                  Ping.java
                Main.java
      resources/
        bukkit-config.yml
        bukkit-example.yml
        paper-plugin.yml
        plugin.yml
  build.gradle.kts
velocity/
  src/
    main/
      java/
        dev/
          consti/
            commandbridge/
              velocity/
                command/
                  CommandDispatcher.java
                  CommandForwarder.java
                  CommandRegistrar.java
                core/
                  Runtime.java
                  Startup.java
                helper/
                  command/
                    ListCommand.java
                    ReloadCommand.java
                    StartCommand.java
                    StopCommand.java
                    VersionCommand.java
                  FailureChecker.java
                  HelpCommand.java
                  InternalRegistrar.java
                  StatusManager.java
                util/
                  GeneralUtils.java
                  ProxyUtils.java
                  ScriptUtils.java
                websocket/
                  HttpServer.java
                  Server.java
                Main.java
      resources/
        velocity-config.yml
        velocity-example.yml
  build.gradle.kts
wiki/
  getting-started/
    installation.md
    plugin-setup.md
    requirements.md
  other/
    contribution-guidelines.md
    data-collection.md
  scripts/
    guide.md
  troubleshooting/
    common-issues.md
    support-resources.md
  README.md
  SUMMARY.md
  use-cases.md
.gitignore
build.gradle.kts
CHANGELOG.md
gradlew
gradlew.bat
README.md
server.sh
settings.gradle.kts
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="paper/src/main/java/dev/consti/commandbridge/paper/command/CommandRegistrar.java">
package dev.consti.commandbridge.paper.command;

import java.util.ArrayList;
import java.util.List;

import dev.consti.commandbridge.paper.core.Runtime;
import dev.consti.foundationlib.logging.Logger;
import dev.consti.foundationlib.utils.ScriptManager;
import dev.jorel.commandapi.CommandAPI;
import dev.jorel.commandapi.CommandAPICommand;
import dev.jorel.commandapi.arguments.GreedyStringArgument;

public class CommandRegistrar {
    private final Logger logger;
    private final CommandForwarder forwarder;
    private final List<String> registeredCommands = new ArrayList<>();

    public CommandRegistrar(Logger logger) {
        this.logger = logger;
        this.forwarder = Runtime.getInstance().getForwarder();
    }

    

public void unregisterAllCommands() {
        for (String command : registeredCommands) {
            try {
                CommandAPI.unregister(command);
                logger.debug("Unregistered command: {}", command);
            } catch (Exception e) {
                logger.error("Failed to unregister command '{}' : {}",
                        command,
                        logger.getDebug() ? e : e.getMessage()
                );
            }
        }
        registeredCommands.clear();
        logger.info("All registered commands have been unregistered.");
    
}

public void registerCommand(ScriptManager.ScriptConfig script) {
        String commandName = script.getName();
        try {
            CommandAPICommand command = new CommandAPICommand(commandName)
                    .withOptionalArguments(new GreedyStringArgument("args"))
                            .executes((sender, args) -> {
                                String argsString = (String) args.get("args");
                                logger.debug("Command '{}' called with arguments: {}", commandName, argsString);
                                String[] splitArgs = argsString != null ? argsString.split(" ") : new String[0];
                                return forwarder.executeScriptCommands(sender, script, splitArgs);
                            });
            command.register();
            registeredCommands.add(commandName);
        } catch (Exception e) {
            logger.error(
                    "Failed to register command '{}' : {}",
                    commandName,
                    logger.getDebug() ? e : e.getMessage()
            );
        }
}

}
</file>

<file path="paper/src/main/java/dev/consti/commandbridge/paper/core/Runtime.java">
package dev.consti.commandbridge.paper.core;

import dev.consti.commandbridge.paper.Main;
import dev.consti.commandbridge.paper.command.CommandRegistrar;
import dev.consti.commandbridge.paper.utils.GeneralUtils;
import dev.consti.commandbridge.paper.utils.ScriptUtils;
import dev.consti.commandbridge.paper.websocket.Client;
import dev.consti.foundationlib.logging.Logger;
import dev.consti.foundationlib.utils.ConfigManager;
import dev.consti.commandbridge.paper.command.CommandExecutor;
import dev.consti.commandbridge.paper.command.CommandForwarder;

public class Runtime {
    private static Runtime instance;
    private Logger logger;
    private ConfigManager config;
    private ScriptUtils scriptUtils;
    private Client client;
    private Startup startup;
    private CommandForwarder forwarder;
    private CommandRegistrar registrar;
    private GeneralUtils generalUtils;
    private CommandExecutor commandExecutor;

    private Runtime() {}

    public static synchronized Runtime getInstance() {
        if (instance == null) {
            instance = new Runtime();
            instance.getLogger().debug("Runtime singleton instance initialized.");
        }
        return instance;
    }

    public synchronized Logger getLogger() {
        if (logger == null) {
            logger = new Logger("CommandBridge");
            logger.debug("Logger initialized.");
        }
        return logger;
    }

    public synchronized ConfigManager getConfig() {
        if (config == null) {
            config = new ConfigManager(getLogger(), "CommandBridge");
            getLogger().debug("ConfigManager initialized.");
        }
        return config;
    }

    public synchronized ScriptUtils getScriptUtils() {
        if (scriptUtils == null) {
            scriptUtils = new ScriptUtils(getLogger(), "CommandBridge");
            getLogger().debug("ScriptUtils initialized.");
        }
        return scriptUtils;
    }

    public synchronized Client getClient() {
        if (client == null) {
            client = new Client(getLogger(), getConfig().getKey("config.yml", "secret"));
            getLogger().debug("Server initialized.");
        }
        return client;
    }

    public synchronized Startup getStartup() {
        if (startup == null) {
            startup = new Startup(getLogger());
            getLogger().debug("Startup initialized.");
        }
        return startup;
    }

    public synchronized CommandForwarder getForwarder() {
        if (forwarder == null) {
            forwarder = new CommandForwarder(getLogger(), Main.getInstance());
            getLogger().debug("CommandHelper initialized.");
        }
        return forwarder;
    }

    public synchronized CommandRegistrar getRegistrar() {
        if (registrar == null) {
            registrar = new CommandRegistrar(getLogger());
            getLogger().debug("CommandRegistrar initialized.");
        }
        return registrar;
    }

    public synchronized GeneralUtils getGeneralUtils() {
        if (generalUtils == null) {
            generalUtils = new GeneralUtils(getLogger());
            getLogger().debug("GeneralUtils initialized.");
        }
        return generalUtils;
    }

    public synchronized CommandExecutor getCommandExecutor() {
        if (commandExecutor == null) {
            commandExecutor = new CommandExecutor();
            getLogger().debug("CommandExecutor initialized.");
        }
        return commandExecutor;
    }
}
</file>

<file path="paper/src/main/java/dev/consti/commandbridge/paper/utils/CommandUtils.java">
package dev.consti.commandbridge.paper.utils;

import java.lang.reflect.Field;

import org.bukkit.Bukkit;
import org.bukkit.command.Command;
import org.bukkit.command.CommandMap;
import org.bukkit.command.PluginCommand;

import dev.consti.commandbridge.paper.core.Runtime;

public class CommandUtils {
    private static CommandMap getCommandMap() {
        try {
            Field commandMapField = Bukkit.getServer().getClass().getDeclaredField("commandMap");
            commandMapField.setAccessible(true);
            return (CommandMap) commandMapField.get(Bukkit.getServer());
        } catch (Exception e) {
            Runtime.getInstance().getLogger().error("Error while accessing commandMap: {}", e);
            return null;
        }
    }

    public static boolean isCommandValid(String command) {
        String baseCommand = command.split(" ")[0];
        PluginCommand pluginCommand = Bukkit.getPluginCommand(baseCommand);
        if (pluginCommand != null) {
            return false;
        }

        CommandMap commandMap = getCommandMap();
        if (commandMap == null) {
            return false;
        }

        Command cmd = commandMap.getCommand(baseCommand);
        return cmd == null;
    }


}
</file>

<file path="paper/src/main/java/dev/consti/commandbridge/paper/utils/SchedulerAdapter.java">
package dev.consti.commandbridge.paper.utils;

import java.util.function.Consumer;

import org.bukkit.Bukkit;
import org.bukkit.plugin.java.JavaPlugin;
import org.jetbrains.annotations.NotNull;

import io.papermc.paper.threadedregions.scheduler.ScheduledTask;

public class SchedulerAdapter {
    private final JavaPlugin plugin;

    public SchedulerAdapter(JavaPlugin plugin) {
        this.plugin = plugin;
    }

    public void run(Runnable task) {
        if (isFolia()) {
            Bukkit.getGlobalRegionScheduler().execute(plugin, task);
        } else {
            Bukkit.getScheduler().runTask(plugin, task);
        }
    }

    public void runLater(Runnable task, long delayTicks) {
        if (isFolia()) {
            Bukkit.getGlobalRegionScheduler().runDelayed(plugin, (@NotNull Consumer<ScheduledTask>) task, delayTicks);
        } else {
            Bukkit.getScheduler().runTaskLater(plugin, task, delayTicks);
        }
    }

    public static boolean isFolia() {
        try {
            Class.forName("io.papermc.paper.threadedregions.RegionizedServer");
            return true;
        } catch (ClassNotFoundException e) {
            return false;
        }
    }
}
</file>

<file path="paper/src/main/java/dev/consti/commandbridge/paper/websocket/Ping.java">
package dev.consti.commandbridge.paper.websocket;

import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.net.URL;
import java.util.Timer;
import java.util.TimerTask;

import javax.net.ssl.HttpsURLConnection;
import javax.net.ssl.SSLContext;
import javax.net.ssl.TrustManager;
import javax.net.ssl.X509TrustManager;

import dev.consti.commandbridge.paper.core.Runtime;
import dev.consti.foundationlib.logging.Logger;
import dev.consti.foundationlib.utils.ConfigManager;

public class Ping {
    private static void startPing(Logger logger, Runnable onPong, String url, int port, int maxAttempts) {
        final int millis = 4000;

        Timer timer = new Timer();

        disableCertificateValidation();

        timer.scheduleAtFixedRate(new TimerTask() {
            int attempts = 0;

            @Override
            public void run() {
                attempts++;
                if (attempts > maxAttempts) {
                    logger.warn("Max reconnect attempts reached. Reconnect manual by running '/cbc reconnect'");
                    timer.cancel();
                    return;
                }

                try {
                    URL targetUrl = new URL("https://" + url + ":" + port + "/ping");
                    HttpsURLConnection conn = (HttpsURLConnection) targetUrl.openConnection();
                    conn.setRequestMethod("GET");
                    conn.setConnectTimeout(1500);
                    conn.setReadTimeout(1500);

                    logger.debug("Pinging WebsocketServer");

                    int responseCode = conn.getResponseCode();
                    if (responseCode == 200) {
                        BufferedReader in = new BufferedReader(new InputStreamReader(conn.getInputStream()));
                        String response = in.readLine();
                        in.close();

                        if ("pong".equalsIgnoreCase(response)) {
                            logger.info("Attempting to reconnect to the server!");
                            onPong.run();
                            timer.cancel();
                        }
                    }
                } catch (Exception e) {
                    // logger.error("Ping error: {}", e);
                }
            }
        }, 0, millis);
    }

    public static void reconnect(Logger logger) {
        ConfigManager config = Runtime.getInstance().getConfig();
        int attempts;
        try {
            attempts = Integer.parseInt(config.getKey("config.yml", "timeout")) / 4;
        } catch (RuntimeException e) {
            attempts = 120 / 4;
        }

        startPing(logger, () -> {
            Runtime.getInstance().getClient().disconnect();

            String host = config.getKey("config.yml", "remote");
            int port = Integer.parseInt(config.getKey("config.yml", "port"));

            try {
                Runtime.getInstance().getClient().connect(host, port);
                logger.info("Client reconnected successfully to {}:{}", host, port);
            } catch (Exception e) {
                logger.error("Client reconnection failed (but ping succeeded):", e);
            }

        }, config.getKey("config.yml", "remote"),
                Integer.parseInt(config.getKey("config.yml", "port")),
                attempts);
    }

    private static void disableCertificateValidation() {
        try {
            TrustManager[] trustAllCerts = new TrustManager[] {
                    new X509TrustManager() {
                        public java.security.cert.X509Certificate[] getAcceptedIssuers() {
                            return new java.security.cert.X509Certificate[0];
                        }

                        public void checkClientTrusted(java.security.cert.X509Certificate[] certs, String authType) {
                        }

                        public void checkServerTrusted(java.security.cert.X509Certificate[] certs, String authType) {
                        }
                    }
            };

            SSLContext sc = SSLContext.getInstance("TLS");
            sc.init(null, trustAllCerts, new java.security.SecureRandom());
            HttpsURLConnection.setDefaultSSLSocketFactory(sc.getSocketFactory());
            HttpsURLConnection.setDefaultHostnameVerifier((hostname, session) -> true);
        } catch (Exception e) {
            throw new RuntimeException("Failed to disable certificate validation", e);
        }
    }
}
</file>

<file path="velocity/src/main/java/dev/consti/commandbridge/velocity/command/CommandDispatcher.java">
package dev.consti.commandbridge.velocity.command;

import java.util.Optional;
import java.util.UUID;

import com.velocitypowered.api.proxy.Player;
import com.velocitypowered.api.proxy.ProxyServer;

import dev.consti.commandbridge.velocity.core.Runtime;
import dev.consti.commandbridge.velocity.util.ProxyUtils;
import dev.consti.foundationlib.json.MessageParser;
import dev.consti.foundationlib.logging.Logger;

public class CommandDispatcher {
    private final ProxyServer proxy;
    private final Logger logger;

    public CommandDispatcher() {
        this.proxy = ProxyUtils.getProxyServer();
        this.logger = Runtime.getInstance().getLogger();
    }

    public void dispatchCommand(String message) {
        MessageParser parser = new MessageParser(message);
        String command = parser.getBodyValueAsString("command");
        String target = parser.getBodyValueAsString("target");
        logger.info("Dispatching command: '{}' for target: {}", command, target);

        switch (target.toLowerCase()) {
            case "console" -> executeConsoleCommand(command);
            case "player" -> executePlayerCommand(parser, command);
            default -> logger.warn("Invalid target: {}", target);
        }
    }

    private void executeConsoleCommand(String command) {
        logger.debug("Executing command '{}' as console", command);
        proxy.getCommandManager()
                .executeAsync(proxy.getConsoleCommandSource(), command)
                .whenComplete((result, throwable) -> {
                    if (throwable != null) {
                        logger.error("Error executing console command: {}", throwable);
                    }
                });
    }

    private void executePlayerCommand(MessageParser parser, String command) {
        logger.debug("Executing command '{}' as player", command);
        String uuidStr = parser.getBodyValueAsString("uuid");
        String name = parser.getBodyValueAsString("name");

        try {
            UUID playerUuid = UUID.fromString(uuidStr);
            Optional<Player> playerOptional = proxy.getPlayer(playerUuid);

            if (playerOptional.isPresent()) {
                Player player = playerOptional.get();
                proxy.getCommandManager()
                        .executeAsync(player, command)
                        .whenComplete((result, throwable) -> {
                            if (throwable != null) {
                                logger.error("Error executing console command: {}", throwable);
                            }
                        });
            } else {
                logger.warn("Player '{}' not found or offline", name);
            }
        } catch (Exception e) {
            logger.error("Error while processing player: {}",
                    logger.getDebug() ? e : e.getMessage()
            );
        }
    }
}
</file>

<file path="velocity/src/main/java/dev/consti/commandbridge/velocity/util/ScriptUtils.java">
package dev.consti.commandbridge.velocity.util;

import dev.consti.commandbridge.velocity.command.CommandRegistrar;
import dev.consti.commandbridge.velocity.core.Runtime;
import dev.consti.foundationlib.logging.Logger;
import dev.consti.foundationlib.utils.ScriptManager;

public class ScriptUtils extends ScriptManager {
    private final Logger logger;
    private final CommandRegistrar registrar;

    public ScriptUtils(Logger logger, String pluginName) {
        super(logger, pluginName);
        this.logger = logger;
        this.registrar = Runtime.getInstance().getRegistrar();
    }

    @Override
    public void onFileProcessed(String fileName, ScriptConfig scriptConfig) {
        if (scriptConfig.isEnabled()) {
            logger.info("Loaded script: {}", fileName);
            try {
                registrar.registerCommand(getScriptConfig(fileName));
                logger.debug("Registered command: {}", scriptConfig.getName());
            } catch (Exception e) {
                logger.error("Failed to register script '{}' : {}",
                        scriptConfig.getName(),
                        logger.getDebug() ? e : e.getMessage()
                );
            }
        } else {
            logger.info("Skipped disabled script: {}", scriptConfig.getName());
        }
    }
}
</file>

<file path="wiki/scripts/guide.md">
---
description: >-
  Comprehensive guide to CommandBridge's script system, including configuration format, options, and examples.
---

# üìú Scripts Guide

After installation and setup, you are ready to create scripts! CommandBridge‚Äôs **script system** allows you to define custom commands that bridge your Velocity proxy and Paper servers.

Each script is defined in a YAML file located in the `CommandBridge/scripts/` folder of your server. Velocity and Paper each maintain their own set of script files:
- **Velocity scripts** (in the Velocity plugin folder) handle commands executed on the proxy that affect one or more Paper servers.
- **Paper scripts** (in each Paper server‚Äôs plugin folder) handle commands executed on that Paper server that may trigger actions on the Velocity proxy (or possibly other servers via the proxy).

## Script File Structure

A script configuration file consists of a top-level structure with these main keys:

```yaml
name: "<command_name>"
enabled: <true|false>
ignore-permission-check: <true|false>
hide-permission-warning: <true|false>
commands:
  - command: "<command_to_execute_1>"
    delay: <seconds>
    target-executor: "<player|console>"
    [target-client-ids: 
      - "<server_id1>"
      - "<server_id2>"]
    [wait-until-player-is-online: <true|false>]
    check-if-executor-is-player: <true|false>
    check-if-executor-is-on-server: <true|false>
  - command: "<command_to_execute_2>"
    ... (same structure as above)
```

**Field explanations:**

- **`name`**: The name of the command players will use (without the slash). This will register as `/name`. For example, `name: hub` defines a `/hub` command.  
- **`enabled`**: Whether this script is active. If `false`, the command will not be registered or usable.  
- **`ignore-permission-check`**: If `false`, CommandBridge will require the executor to have permission `commandbridge.command.<name>` to use this command. If `true`, anyone can use the command regardless of permissions. *(Even if ignored here, you can still use a permissions plugin to restrict the actual in-game command as needed.)*  
- **`hide-permission-warning`**: If `false`, a player without permission will receive a "no permission" message when trying the command. If `true`, no warning is shown (the command will appear non-functional if they lack permission). Typically used in combination with `ignore-permission-check`.  
- **`commands`**: A list of one or more actions to execute when the custom command is run. Each action has several sub-fields:
  - **`command`**: The exact command string to run (do **not** include the leading `/`). For example, `say Hello` or `server hub`. You can include placeholders here (see **Placeholders** below).  
  - **`delay`**: Delay in seconds before executing this command after the previous action. Use `0` for no delay (all commands run in immediate succession). This can be used to space out sequential actions.  
  - **`target-executor`**: Who will execute the command on the target side. Options are:
    - `"player"`: execute as the player who triggered the script.  
    - `"console"`: execute as the server console.
  - **`target-client-ids`** (**Velocity scripts only**): A list of target Paper server IDs on which to execute this command. This field **only applies in Velocity‚Äôs script files**, since Velocity can dispatch commands to any connected Paper servers. For example, specifying two IDs will run the command on both servers. If this field is present, the command will be sent to those remote servers. If this field is omitted (or in a Paper script), the command will be executed on the same platform where it‚Äôs triggered.
  - **`wait-until-player-is-online`** (**Velocity scripts only**): If `true`, for each target server listed, the plugin will wait until the player is actually online on that target server before executing the command there. This is useful if the previous action moves the player to another server (e.g., using a Velocity `/server` command to teleport). Setting this ensures the next command (perhaps on the destination server) runs only after the player arrives.  
  - **`check-if-executor-is-player`**: If `true`, the script will only run if the command executor is a player (not console). If `false`, it doesn‚Äôt check ‚Äì meaning console or command blocks could trigger it.  
  - **`check-if-executor-is-on-server`**: If `true`, ensures that the command executor is currently online (connected) when triggering the script. Usually this should be `true` for player-triggered commands to avoid issues if a player disconnects. Set `false` if you want the command to run even if the triggering entity is not a player or not online.

**Note:** *Velocity vs Paper scripts:* The YAML structure is the same on both, but **Velocity-specific fields** (`target-client-ids` and `wait-until-player-is-online`) are only used in Velocity‚Äôs context. Paper scripts do not need those because a Paper server only forwards commands to the Velocity proxy (single target). In a Paper script, any command listed will be executed on the Velocity side by default (since Velocity is the only connection target). Conversely, in a Velocity script, commands can be executed on one or many connected Paper servers via `target-client-ids`. 

## Creating a Simple Script (Basic Example)

Let's create a simple script on the Velocity side that broadcasts a message to all servers. Suppose we want a command `/alert` that makes all servers announce a warning.

**On Velocity (proxy):** Create a file `plugins/CommandBridge/scripts/alert.yml` with the following content:

```yaml
name: alert
enabled: true
ignore-permission-check: false
hide-permission-warning: false
commands:
  - command: 'broadcast Attention: Maintenance in 5 minutes!'
    delay: 0
    target-client-ids:
      - 'lobby'
      - 'survival'
      - 'minigame'
    target-executor: 'console'
    wait-until-player-is-online: false
    check-if-executor-is-player: false
    check-if-executor-is-on-server: false
```

In this example:
- We define a new command `/alert` (since `name: alert`).  
- It's enabled and will require the executor to have permission `commandbridge.command.alert` (because we left `ignore-permission-check: false`).  
- When someone with permission runs `/alert` on Velocity, the plugin will execute one action: run the `broadcast ...` command on the console of three target servers (`lobby`, `survival`, `minigame`). Each of those Paper servers will broadcast the maintenance message to their players.  
- We didn‚Äôt need any delay or waiting, since it‚Äôs a direct broadcast. We also allowed console execution (so even the Velocity console could run `/alert`).

Because this script is on Velocity, players on Paper servers **cannot** directly use `/alert` unless you also create a corresponding script on each Paper server (or you run it from the Velocity console or as an admin on Velocity). For a command that should be usable from anywhere, see the next example.

## Advanced Script Example

For a more complex scenario, let‚Äôs implement the **global** `/hub` command described in the use-cases (Example 1), which involves multiple sequential actions across servers:

**Goal:** `/hub` will teleport the player to the hub server (via Velocity) and then play music on that hub server (via a Paper plugin command).

We will create a **Velocity script** for `/hub` because Velocity can coordinate both the teleport and issuing the next command on the hub server:

```yaml
name: hub
enabled: true
ignore-permission-check: false
hide-permission-warning: false
commands:
  - command: 'server hub'
    delay: 0
    target-executor: 'player'
    # (No target-client-ids here, because 'server hub' is a Velocity command executed by the player on Velocity)
    check-if-executor-is-player: true
    check-if-executor-is-on-server: true

  - command: 'music'
    delay: 0
    target-client-ids:
      - 'hub'
    target-executor: 'player'
    wait-until-player-is-online: true
    check-if-executor-is-player: true
    check-if-executor-is-on-server: true
```

Breaking down what happens when a player uses `/hub` on **any server**:
1. If run on a Paper server, the Paper plugin will forward the request to Velocity (because `/hub` is not a known Paper command but is known to the proxy). If run on Velocity directly, it just triggers there. Either way, Velocity receives the command trigger from the player.  
2. **First action:** Velocity runs its built-in `/server hub` command **as the player**, teleporting that player to the `hub` server. The plugin immediately moves to the next action.  
3. **Second action:** The plugin sends the `music` command to the `hub` server‚Äôs CommandBridge client. Because `wait-until-player-is-online: true`, CommandBridge will **wait** until the player is actually connected to the `hub` server before executing `music` as that player on the hub server. This ensures the `/music` command runs at the right time (after teleport).  
4. The player hears the music on the hub server. The sequence is complete.

With this one script on Velocity, players can use `/hub` from any server. The Paper servers don‚Äôt even need their own `/hub` script file in this case‚Äîany unknown command on Paper is passed to Velocity, and if Velocity recognizes it (which it will, since we made a script for it), it handles the rest. However, if you prefer, you could also create a matching script on each Paper server for `/hub` that simply forwards to Velocity (e.g., using a `velocity ...` command), but it's not necessary due to how Velocity proxies player commands.

{% hint style="info" %}  
**Tip:** To make a command truly global (usable on both Velocity and Paper), define it on Velocity as shown. Velocity will catch the command from players on any connected server. Ensure that the players have the necessary permission if required (e.g., `commandbridge.command.hub` in our example) on whichever platform they might execute it.  
{% endhint %}

## Placeholders in Scripts

CommandBridge supports placeholders to make your scripts dynamic. By default, the plugin provides a few **built-in placeholders** that you can use in your command strings:

- **%cb_player%** ‚Äì The name of the player who triggered the script.  
- **%cb_uuid%** ‚Äì That player‚Äôs UUID.  
- **%cb_world%** ‚Äì (*Paper only*) The name of the world the player is currently in (if applicable).

These placeholders will be replaced with the actual values at runtime. For example, a command entry:
```yaml
- command: "say %cb_player% has initiated the event!"
  target-executor: "console"
  ...
``` 
would broadcast ‚Äú<playername> has initiated the event!‚Äù on the target server.

If you have **PlaceholderAPI** installed on your Paper servers, CommandBridge will automatically hook into it on the Paper side. This means you can use any PAPI placeholders in your script commands that are executed on Paper servers. Similarly, if you have **PapiProxyBridge** on Velocity, PlaceholderAPI placeholders can work in commands executed on Velocity or passed through Velocity.

{% hint style="info" %}  
**Note on PlaceholderAPI:** When PlaceholderAPI is present, CommandBridge will detect it and log ‚ÄúHooked into PlaceholderAPI‚Äù (or PapiProxyBridge on Velocity) on startup. You can then include placeholders like `%server_time%` or any custom placeholders from your plugins in the `command` strings, and they will be parsed. If PAPI is not installed, only the built-in `%cb_...%` placeholders will work.  
{% endhint %}

With the script system configured, you can design a wide variety of cross-server commands to suit your network‚Äôs needs ‚Äì from simple one-step forwards to complex multi-step orchestrations. Be sure to test each script thoroughly and use the `debug` mode in configs (set `debug: true`) if you need detailed logs for troubleshooting script behavior.
</file>

<file path=".gitignore">
.gradle
build/
!gradle/wrapper/gradle-wrapper.jar
!**/src/main/**/build/
!**/src/test/**/build/

### IntelliJ IDEA ###
.idea/modules.xml
.idea/jarRepositories.xml
.idea/compiler.xml
.idea/libraries/
.idea/workspace.xml
*.iws
*.iml
*.ipr
out/
!**/src/main/**/out/
!**/src/test/**/out/

### Eclipse ###
.apt_generated
.classpath
.factorypath
.project
.settings
.springBeans
.sts4-cache
bin/
!**/src/main/**/bin/
!**/src/test/**/bin/

### NetBeans ###
/nbproject/private/
/nbbuild/
/dist/
/nbdist/
/.nb-gradle/

### VS Code ###
.vscode/

### Mac OS ###
.DS_Store


kls_database.db
</file>

<file path="README.md">
### **CommandBridge**

This plugin connects **Velocity** and **Paper** servers seamlessly, enabling **cross-server command execution**. Here's what it does exactly:

- **Custom Scripts**: Define commands in scripts for both server types.  
- **Two-Way Communication**:  
   - Run a command on Velocity ‚Üí Matching commands execute on Paper.  
   - Run a command on Paper ‚Üí Matching commands execute on Velocity.  
- **WebSocket-Powered**: Ensures fast, reliable and **realtime** communication between servers.  
- **Placeholders Supported**: Use placeholders for dynamic command execution.  

With this plugin, you can create **global gameplay experiences** that feel smooth and connected!

---

### Requirements

**CommandBridge** v2.0.0 introduces new requirements and updates:  

- **Java 21 Required**: The server must run on Java 21.  
- **Minecraft Compatibility**: Fully compatible with Minecraft 1.21.x.  
- **Single JAR File**: Only download `CommandBridge-XXX-all.jar`.  
- **Dual Placement**: The JAR must be placed in both the target Paper server and the Velocity server to function.  
- **Plugin Compatibility**: Built for Paper servers, though it may work on other software (not tested).  

> **Important**: These requirements apply only to versions **2.0.0** and above.

---

### News

The **2.0.0 release** brings major updates and improvements:  

- **Rewritten Code**: Cleaner, faster, and more reliable.  
- **WebSocket Technology**: Replaces plugin messaging to fix issues where messages could not be sent if no players were online.  
- **Alpha Release**: Still in early stages, so expect some rough edges.  

---

### Installation (Short Version)

For detailed instructions, visit the [wiki](https://docs.old.huraxdax.club/) (currently outdated but new one is in progress, but the configuration is mostly the same). New one is in progess, you can read it [tho](https://docs.huraxdax.club).

1. **Add the JAR**: Place the plugin JAR in the `plugins` folder of both the Paper and Velocity servers.  
2. **Restart Servers**: Restart both servers. After the restart, a `secret.key` file will be generated in the Velocity server's `plugins/CommandBridge` folder.  
3. **Secure the Key**:  
   - Open `secret.key` on the Velocity server.  
   - Copy the key and paste it into the `secret` field in the `config.yml` of all Paper servers.  
   - **Do not share this key.**  
4. **Open a Port**:  
   - Choose an unused port for the Velocity server.  
   - Configure this port in the `config.yml` of both Velocity and Paper servers.  
5. **Set Server IP**:  
   - Find your Velocity server's IP address (plain IP, no domain).  
   - Update the `host` field in Velocity's `config.yml` and the `remote` field in all Paper servers with this IP.  
6. **Set Identifiers**:  
   - In Velocity: Set a `server-id` (any name you prefer).  
   - In Paper: Set a matching `client-id`.  
7. **Restart Order**: Restart the Velocity server **before** the Paper servers.  

After setup, you should see logs like this in the Velocity console:  
```plaintext
[21:10:10 INFO] [CommandBridge]: New connection attempt from /127.0.0.1:42918
[21:10:10 INFO] [CommandBridge]: Client authenticated successfully: /127.0.0.1:42918
[21:10:10 INFO] [CommandBridge]: Added connected client: lobby
```

Now you're ready to create scripts!  

---

### What Comes in the Future

Exciting features and improvements are planned for **CommandBridge**:

- **Multiple Velocity Server Support**: Connect additional Velocity servers to act as clients.  
- **PlaceholderAPI (PAPI) Support**: Unlock even more placeholders for greater flexibility.  
- **GUI Menu for Scripts**: Create and manage scripts with an easy-to-use graphical interface.  
- **Bug Fixes**: Continuous improvements to ensure stability and performance.  
- **Better Documentation**: Expanded guides and tutorials for easier setup and usage.  
- **Dump Command & Tools**: Integration with a website and Discord bot for troubleshooting and support.  
- **And More!**  

Stay tuned for updates and new features! üéâ  

---

### Help or Issues

- Report issues on [GitHub](https://github.com/72-S/CommandBridge/issues).  
- Join the [Discord server](https://discord.gg/QPqBYb44ce) for support.  

---

### Metrics Collection

This plugin collects anonymous server statistics via [bStats](https://bstats.org/), an open-source statistics service for Minecraft plugins. You can disable this in `plugins/bStats/config.yml`.  

![bStats](https://bstats.org/signatures/velocity/CommandBridge.svg)

---

### Contributing

Join the [Discord server](https://discord.gg/QPqBYb44ce) or visit the [GitHub](https://github.com/72-S/CommandBridge) for more information on contributing to the project.
</file>

<file path="paper/src/main/java/dev/consti/commandbridge/paper/utils/ScriptUtils.java">
package dev.consti.commandbridge.paper.utils;

import dev.consti.commandbridge.paper.Main;
import dev.consti.commandbridge.paper.command.CommandRegistrar;
import dev.consti.commandbridge.paper.core.Runtime;
import dev.consti.foundationlib.logging.Logger;
import dev.consti.foundationlib.utils.ScriptManager;

public class ScriptUtils extends ScriptManager {
    private final Logger logger;
    private final CommandRegistrar registrar;

    public ScriptUtils(Logger logger, String pluginName) {
        super(logger, pluginName);
        this.logger = logger;
        this.registrar = Runtime.getInstance().getRegistrar();
    }

    @Override
    public void onFileProcessed(String fileName, ScriptConfig scriptConfig) {
        if (scriptConfig.isEnabled()) {
            logger.info("Loaded script: {}", fileName);
            try {
                registrar.registerCommand(getScriptConfig(fileName));
                logger.debug("Registered command: {}", scriptConfig.getName());
            } catch (Exception e) {
                logger.error("Failed to register script '{}' : {}",
                        scriptConfig.getName(),
                        logger.getDebug() ? e : e.getMessage()
                );
            }
        } else {
            logger.info("Skipped disabled script: {}", scriptConfig.getName());
        }
    }

    public void unloadCommands(Runnable callback) {
        new SchedulerAdapter(Main.getInstance())
                .run(
                        () -> {
                            logger.debug("Running on thread (unload): {}", Thread.currentThread().getName());
                            Runtime.getInstance().getRegistrar().unregisterAllCommands();
                            logger.debug("All commands have been unloaded");
                            callback.run();
                });
    }




}
</file>

<file path="velocity/src/main/java/dev/consti/commandbridge/velocity/helper/command/StartCommand.java">
package dev.consti.commandbridge.velocity.helper.command;

import com.mojang.brigadier.builder.LiteralArgumentBuilder;
import com.velocitypowered.api.command.CommandSource;
import dev.consti.commandbridge.velocity.core.Runtime;
import dev.consti.foundationlib.logging.Logger;
import net.kyori.adventure.text.Component;
import net.kyori.adventure.text.format.NamedTextColor;


public class StartCommand {
    public static LiteralArgumentBuilder<CommandSource> build(Logger logger) {
        return LiteralArgumentBuilder.<CommandSource>literal("start")
                .executes(context -> {
                    CommandSource source = context.getSource();
                    if (!source.hasPermission("commandbridge.admin")) {
                        source.sendMessage(Component.text("You do not have permission to start the WebSocket server", NamedTextColor.RED));
                        return 0;
                    }
                    Runtime.getInstance().getServer().startServer(
                    Integer.parseInt(Runtime.getInstance().getConfig().getKey("config.yml", "port")),
                    Runtime.getInstance().getConfig().getKey("config.yml", "host"),
                    Runtime.getInstance().getConfig().getKey("config.yml", "san")
            );

                    source.sendMessage(Component.text("WebSocket Server started").color(NamedTextColor.GREEN));
                    return 1;
                });
    }
}
</file>

<file path="velocity/src/main/java/dev/consti/commandbridge/velocity/helper/command/VersionCommand.java">
package dev.consti.commandbridge.velocity.helper.command;

import com.mojang.brigadier.builder.LiteralArgumentBuilder;
import com.velocitypowered.api.command.CommandSource;
import dev.consti.commandbridge.velocity.Main;
import dev.consti.foundationlib.logging.Logger;
import dev.consti.foundationlib.utils.VersionChecker;
import net.kyori.adventure.text.Component;
import net.kyori.adventure.text.event.ClickEvent;
import net.kyori.adventure.text.format.NamedTextColor;
import net.kyori.adventure.text.format.TextDecoration;


public class VersionCommand {
    public static LiteralArgumentBuilder<CommandSource> build(Logger logger) {
        return LiteralArgumentBuilder.<CommandSource>literal("version")
                .executes(context -> {
                    CommandSource source = context.getSource();
                    if (!source.hasPermission("commandbridge.admin")) {
                        source.sendMessage(Component.text("You do not have permission to check the version", NamedTextColor.RED));
                        return 0;
                    }

                    String currentVersion = Main.getVersion();
                    source.sendMessage(Component.text("Checking for updates...").color(NamedTextColor.YELLOW));
                    logger.debug("VersionCommand executed by: {}", source);

                    new Thread(() -> {
                        String latestVersion = VersionChecker.getLatestVersion();

                        if (latestVersion == null) {
                            source.sendMessage(
                                    Component.text("Unable to check for updates").color(NamedTextColor.RED));
                            logger.warn("Failed to retrieve latest version for update check");
                            return;
                        }

                        logger.debug("Current version: {}, Latest version: {}", currentVersion, latestVersion);

                        if (VersionChecker.isNewerVersion(latestVersion, currentVersion)) {
                            source.sendMessage(
                                    Component.text("A new version is available: " + latestVersion)
                                            .color(NamedTextColor.RED));
                            source.sendMessage(
                                    Component.text("Please download the latest release: ")
                                            .append(
                                                    Component.text("here")
                                                            .color(NamedTextColor.BLUE)
                                                            .decorate(TextDecoration.UNDERLINED)
                                                            .clickEvent(ClickEvent.openUrl(VersionChecker.getDownloadUrl()))));
                            logger.warn("A newer version is available: {}", latestVersion);
                        } else {
                            source.sendMessage(
                                    Component.text("You are running the latest version: " + currentVersion)
                                            .color(NamedTextColor.GREEN));
                        }
                    }).start();

                    return 1;
                });
    }
}
</file>

<file path="velocity/src/main/java/dev/consti/commandbridge/velocity/helper/StatusManager.java">
package dev.consti.commandbridge.velocity.helper;

import dev.consti.commandbridge.velocity.core.Runtime;
import dev.consti.foundationlib.logging.Logger;

import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;

public class StatusManager {
    private final Logger logger;
    private final Map<String, String> statusMap = new HashMap<>();
    private final Set<String> connectedClients = Runtime.getInstance().getServer().getConnectedClients();

    public StatusManager(Logger logger) {
        this.logger = logger;
    }

    public void addClientToStatus(String clientId, String status) {
        statusMap.put(clientId, status);
        logger.debug("Updated statusMap: {}", statusMap);
    }

    public void clearStatusMap() {
        statusMap.clear();
    }

    public String checkForFailures() {
        logger.debug("Checking for failures...");

        List<String> missingClients = connectedClients.stream()
                .filter(client -> !statusMap.containsKey(client))
                .toList();

        if (!missingClients.isEmpty()) {
            String missingClientString = String.join(", ", missingClients);
            logger.warn("Waiting for responses from clients: {}", missingClientString);
            return "Missing responses from: " + missingClientString;
        }

        String failedClients = statusMap.entrySet().stream()
                .filter(entry -> !"success".equals(entry.getValue()))
                .map(Map.Entry::getKey)
                .reduce((a, b) -> a + ", " + b)
                .orElse(null);

        if (failedClients != null) {
            logger.error("Failure detected on clients: {}", failedClients);
            return "Failure detected on: " + failedClients;
        }

        logger.debug("No failures detected. All clients are operational");
        return null;
    }
}
</file>

<file path="velocity/src/main/java/dev/consti/commandbridge/velocity/util/GeneralUtils.java">
package dev.consti.commandbridge.velocity.util;

import com.velocitypowered.api.command.CommandMeta;
import com.velocitypowered.api.command.CommandSource;
import com.velocitypowered.api.proxy.ProxyServer;
import dev.consti.commandbridge.velocity.Main;
import dev.consti.commandbridge.velocity.core.Runtime;
import dev.consti.commandbridge.velocity.helper.InternalRegistrar;
import dev.consti.commandbridge.velocity.helper.FailureChecker;
import dev.consti.commandbridge.velocity.helper.StatusManager;
import dev.consti.foundationlib.logging.Logger;

import java.util.Set;
import java.util.concurrent.TimeUnit;

public class GeneralUtils {
    private final Logger logger;
    private final ProxyServer proxy;
    private final Main plugin;
    private final StatusManager statusManager;
    private final Set<String> connectedClients;
    private CommandMeta meta;

    public GeneralUtils(Logger logger) {
        this.logger = logger;
        this.proxy = ProxyUtils.getProxyServer();
        this.plugin = Main.getInstance();
        this.connectedClients = Runtime.getInstance().getServer().getConnectedClients();
        this.statusManager = new StatusManager(logger);
    }

    public void addClientToStatus(String clientId, String status) {
        statusManager.addClientToStatus(clientId, status);
    }

    public void startFailureCheck(CommandSource source) {
        statusManager.clearStatusMap();
        FailureChecker checkTask = new FailureChecker(logger, proxy, plugin, statusManager, source);
        try {
            proxy.getScheduler().buildTask(plugin, checkTask).delay(1, TimeUnit.SECONDS).schedule();
        } catch (Exception e) {
            logger.error("Failed to schedule the reload check task: {}", logger.getDebug() ? e : e.getMessage());
            source.sendMessage(
                    net.kyori.adventure.text.Component.text("Reload command failed: Unable to start the failure check")
                            .color(net.kyori.adventure.text.format.NamedTextColor.RED));
        }
    }

    public void registerCommands() {
        InternalRegistrar registrar = new InternalRegistrar(logger, proxy, plugin, connectedClients);
        registrar.registerCommands();
    }

    public CommandMeta getMeta() {
        return meta;
    }

    public void setMeta(CommandMeta commandMeta) {
        meta = commandMeta;
    }

    public void unregisterCommands() {
        proxy.getCommandManager().unregister(meta);
    }
}
</file>

<file path="velocity/src/main/java/dev/consti/commandbridge/velocity/util/ProxyUtils.java">
package dev.consti.commandbridge.velocity.util;

import com.velocitypowered.api.proxy.ProxyServer;

import dev.consti.commandbridge.velocity.core.Runtime;
import dev.consti.foundationlib.logging.Logger;

public class ProxyUtils {
    private static ProxyServer proxyServer;
    private static final Logger logger = Runtime.getInstance().getLogger();

    private ProxyUtils() {
    }

    public static synchronized void setProxyServer(ProxyServer server) {
        if (proxyServer == null) {
            proxyServer = server;
        } else {
            logger.error("Attempted to set ProxyServer instance more than once!");
            throw new IllegalStateException("Proxy instance is already set!");
        }
    }

    public static synchronized ProxyServer getProxyServer() {
        if (proxyServer == null) {
            logger.error("Attempted to retrieve ProxyServer instance before initialization!");
            throw new IllegalStateException("Proxy instance is not initialized!");
        }
        return proxyServer;
    }
}
</file>

<file path="velocity/src/main/java/dev/consti/commandbridge/velocity/websocket/HttpServer.java">
package dev.consti.commandbridge.velocity.websocket;

import dev.consti.foundationlib.logging.Logger;
import io.netty.channel.ChannelHandlerContext;
import io.netty.channel.SimpleChannelInboundHandler;
import io.netty.channel.ChannelHandler.Sharable;
import io.netty.handler.codec.http.DefaultFullHttpResponse;
import io.netty.handler.codec.http.FullHttpRequest;
import io.netty.handler.codec.http.FullHttpResponse;
import io.netty.handler.codec.http.HttpHeaderNames;
import io.netty.handler.codec.http.HttpResponseStatus;
import static io.netty.handler.codec.http.HttpResponseStatus.*;
import static io.netty.handler.codec.http.HttpVersion.HTTP_1_1;


@Sharable
public class HttpServer extends SimpleChannelInboundHandler<FullHttpRequest>{
    private Logger logger;

    
    public HttpServer(Logger logger) {
        this.logger = logger;
    }


    @Override
    protected void channelRead0(ChannelHandlerContext ctx, FullHttpRequest msg) {
        String uri = msg.uri();
        logger.debug("Incoming HTTP request to: {}", uri);

        if ("/ping".equalsIgnoreCase(uri)) {
            sendTextResponse(ctx, OK, "pong");
        } else if ("websocket".equalsIgnoreCase(msg.headers().get(HttpHeaderNames.UPGRADE))) {
            ctx.fireChannelRead(msg.retain());
        } else {
            sendTextResponse(ctx, NOT_FOUND, "Not Found");
        }
    }

    private void sendTextResponse(ChannelHandlerContext ctx, HttpResponseStatus status, String content) {
        FullHttpResponse response = new DefaultFullHttpResponse(
            HTTP_1_1,
            status,
            ctx.alloc().buffer().writeBytes(content.getBytes())
        );
        response.headers().set(HttpHeaderNames.CONTENT_TYPE, "text/plain");
        response.headers().set(HttpHeaderNames.CONTENT_LENGTH, response.content().readableBytes());
        ctx.writeAndFlush(response);
    }

    @Override
    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {
        logger.error("Error in HttpServer handler: {}", logger.getDebug() ? cause : cause.getMessage());
        ctx.close();
    }

}
</file>

<file path="wiki/troubleshooting/support-resources.md">
---
description: >-
  Where to find help and support for CommandBridge.
---

# üì≠ Support resources

Need help with CommandBridge? Here are some resources to get support and stay informed:

- **GitHub Issues** ‚Äì If you encounter a bug or have a feature request, please report it on the [GitHub issue tracker](https://github.com/72-S/CommandBridge/issues). Make sure to include details like plugin version, logs, and how to reproduce the issue.

- **Discord Community** ‚Äì Join the official [CommandBridge Discord server](https://discord.gg/QPqBYb44ce) for community support. You can ask questions, get help from other server owners and the developer, and see announcements. There‚Äôs a good chance someone has encountered your issue before and can assist.

- **Documentation** ‚Äì Re-check this documentation (you‚Äôre already here!). The **Troubleshooting** section covers common issues. The latest updates and usage examples are covered in the relevant sections of the wiki.

When seeking support, it helps to have:
  - **Plugin version** and **Minecraft/Velocity/Paper versions** you are using.
  - Relevant log excerpts or error messages (use a paste service for longer logs).
  - A description of what you‚Äôve tried so far to resolve the issue.

The CommandBridge community is friendly and ready to help. Don‚Äôt hesitate to reach out if you‚Äôre stuck!
</file>

<file path="gradlew.bat">
@rem
@rem Copyright 2015 the original author or authors.
@rem
@rem Licensed under the Apache License, Version 2.0 (the "License");
@rem you may not use this file except in compliance with the License.
@rem You may obtain a copy of the License at
@rem
@rem      https://www.apache.org/licenses/LICENSE-2.0
@rem
@rem Unless required by applicable law or agreed to in writing, software
@rem distributed under the License is distributed on an "AS IS" BASIS,
@rem WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@rem See the License for the specific language governing permissions and
@rem limitations under the License.
@rem
@rem SPDX-License-Identifier: Apache-2.0
@rem

@if "%DEBUG%"=="" @echo off
@rem ##########################################################################
@rem
@rem  Gradle startup script for Windows
@rem
@rem ##########################################################################

@rem Set local scope for the variables with windows NT shell
if "%OS%"=="Windows_NT" setlocal

set DIRNAME=%~dp0
if "%DIRNAME%"=="" set DIRNAME=.
@rem This is normally unused
set APP_BASE_NAME=%~n0
set APP_HOME=%DIRNAME%

@rem Resolve any "." and ".." in APP_HOME to make it shorter.
for %%i in ("%APP_HOME%") do set APP_HOME=%%~fi

@rem Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
set DEFAULT_JVM_OPTS="-Xmx64m" "-Xms64m"

@rem Find java.exe
if defined JAVA_HOME goto findJavaFromJavaHome

set JAVA_EXE=java.exe
%JAVA_EXE% -version >NUL 2>&1
if %ERRORLEVEL% equ 0 goto execute

echo. 1>&2
echo ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH. 1>&2
echo. 1>&2
echo Please set the JAVA_HOME variable in your environment to match the 1>&2
echo location of your Java installation. 1>&2

goto fail

:findJavaFromJavaHome
set JAVA_HOME=%JAVA_HOME:"=%
set JAVA_EXE=%JAVA_HOME%/bin/java.exe

if exist "%JAVA_EXE%" goto execute

echo. 1>&2
echo ERROR: JAVA_HOME is set to an invalid directory: %JAVA_HOME% 1>&2
echo. 1>&2
echo Please set the JAVA_HOME variable in your environment to match the 1>&2
echo location of your Java installation. 1>&2

goto fail

:execute
@rem Setup the command line

set CLASSPATH=%APP_HOME%\gradle\wrapper\gradle-wrapper.jar


@rem Execute Gradle
"%JAVA_EXE%" %DEFAULT_JVM_OPTS% %JAVA_OPTS% %GRADLE_OPTS% "-Dorg.gradle.appname=%APP_BASE_NAME%" -classpath "%CLASSPATH%" org.gradle.wrapper.GradleWrapperMain %*

:end
@rem End local scope for the variables with windows NT shell
if %ERRORLEVEL% equ 0 goto mainEnd

:fail
rem Set variable GRADLE_EXIT_CONSOLE if you need the _script_ return code instead of
rem the _cmd.exe /c_ return code!
set EXIT_CODE=%ERRORLEVEL%
if %EXIT_CODE% equ 0 set EXIT_CODE=1
if not ""=="%GRADLE_EXIT_CONSOLE%" exit %EXIT_CODE%
exit /b %EXIT_CODE%

:mainEnd
if "%OS%"=="Windows_NT" endlocal

:omega
</file>

<file path="gradle/wrapper/gradle-wrapper.properties">
distributionBase=GRADLE_USER_HOME
distributionPath=wrapper/dists
distributionUrl=https\://services.gradle.org/distributions/gradle-8.10-bin.zip
networkTimeout=10000
validateDistributionUrl=true
zipStoreBase=GRADLE_USER_HOME
zipStorePath=wrapper/dists
</file>

<file path="paper/src/main/java/dev/consti/commandbridge/paper/command/CommandExecutor.java">
package dev.consti.commandbridge.paper.command;

import java.util.Optional;
import java.util.UUID;

import org.bukkit.Bukkit;
import org.bukkit.command.CommandSender;
import org.bukkit.entity.Player;

import dev.consti.commandbridge.paper.Main;
import dev.consti.commandbridge.paper.core.Runtime;
import dev.consti.commandbridge.paper.utils.CommandUtils;
import dev.consti.commandbridge.paper.utils.SchedulerAdapter;
import dev.consti.foundationlib.json.MessageParser;
import dev.consti.foundationlib.logging.Logger;

public class CommandExecutor {
    private final Main plugin;
    private final Logger logger;

    public CommandExecutor() {
        this.plugin = Main.getInstance();
        this.logger = Runtime.getInstance().getLogger();
    }

    public void dispatchCommand(String message) {
        MessageParser parser = new MessageParser(message);
        String serverId = Runtime.getInstance().getConfig().getKey("config.yml", "client-id");
        if (!parser.getBodyValueAsString("client").equals(serverId)) {
            logger.debug("Message not intended for this client: {}", serverId);
            return;
        }
        String command = parser.getBodyValueAsString("command");
        String target = parser.getBodyValueAsString("target");
        logger.info("Dispatching command '{}' for executor: {}", command, target);

        switch (target) {
            case "console" -> executeConsoleCommand(command);
            case "player" -> executePlayerCommand(parser, command);
            default -> logger.warn("Invalid target: {}", target);
        }
    }

    private void executeConsoleCommand(String command) {
        logger.debug("Executing command '{}' as console", command);

        if (CommandUtils.isCommandValid(command)) {
            logger.warn("Invalid command: {}", command);
            Runtime.getInstance().getClient().sendError("Invalid command: " + command);
            return;
        }

        CommandSender console = Bukkit.getConsoleSender();
        new SchedulerAdapter(plugin).run(() -> {
            boolean status = Bukkit.dispatchCommand(console, command);
            logResult("console", command, status);
        });
   }

    private void executePlayerCommand(MessageParser parser, String command) {
        logger.debug("Executing command '{}' as player", command);
        String uuidStr = parser.getBodyValueAsString("uuid");
        String name = parser.getBodyValueAsString("name");

        try {
            UUID uuid = UUID.fromString(uuidStr);
            Optional<Player> playerOptional = Optional.ofNullable(Bukkit.getPlayer(uuid));

            playerOptional.ifPresentOrElse(player -> handlePlayerCommand(player, command),
                    () -> logger.warn("Player '{}' not found or offline", name));
        } catch (Exception e) {
            logger.error("Error while processing player: {}",
                    logger.getDebug() ? e : e.getMessage()
                    );
            Runtime.getInstance().getClient().sendError("Error while processing player: " + e.getMessage());
        }
   }

private void handlePlayerCommand(Player player, String command) {
    if (CommandUtils.isCommandValid(command)) {
        logger.warn("Invalid command: {}", command);
        Runtime.getInstance().getClient().sendError("Invalid command: " + command);
        player.sendMessage("¬ßcThe command '" + command + "' is invalid");
        return;
    }

    new SchedulerAdapter(plugin).run(() -> {
      boolean status = Bukkit.dispatchCommand(player, command);
      logResult("player", command, status);
    });
}


// private boolean isCommandValid(String command) {
//     String baseCommand = command.split(" ")[0];
//     PluginCommand pluginCommand = Bukkit.getPluginCommand(baseCommand);
//     if (pluginCommand != null) {
//         return false;
//     }
//     return Bukkit.getServer().getCommandMap().getCommand(baseCommand) == null;
// }
//
private void logResult(String target, String command, boolean status) {
    if (status) {
        logger.info("Successfully executed command '{}' as {}", command, target);
    } else {
        logger.warn("Failed to execute command '{}' as {}", command, target);
        Runtime.getInstance().getClient().sendError("Failed to execute command '" + command + "' as " + target);
    }
}

}
</file>

<file path="paper/src/main/resources/bukkit-config.yml">
# Client Configuration File

# General debug mode.
# Set to true to enable detailed logs and diagnostics for troubleshooting,
# or false for standard logging.
debug: false

# Unique identifier for the client.
# This is used to distinguish this client from others in the network.
# Example: client-id: "lobby" for a lobby client.
client-id: "lobby"

# The address of the remote server this client will connect to.
# Use "127.0.0.1" for local connections or the server's IP for remote access.
# Example: remote: "192.168.1.100" for a server on the local network.
remote: "127.0.0.1"

# The port number the client will use to connect to the remote server.
# Ensure this matches the port configured on the server side.
port: 8080

# Time in seconds to keep trying to reconnect after server shutdown.
# After this, use /cbc reconnect to retry manually.
timeout: 120

# A shared secret key used for authentication between the client and the server.
# This ensures secure communication.
# The key is stored securely in the secret.key file located in the server's plugin folder.
secret: "CHANGE_ME"
</file>

<file path="paper/src/main/resources/bukkit-example.yml">
##########################################################################
# EXAMPLE CONFIGURATION
# This file demonstrates how to dispatch a command to the Bukkit server
# or servers, where the command gets executed on the Velocity server.
##########################################################################

# The name of the command to be dispatched.
# This is the identifier for the command configuration.
name: examplebukkit

# Enable or disable this command.
# Set to true to allow the command to be executed, or false to disable it.
enabled: true

# Ignore permission checks for this command.
# Set to true to bypass permission validation, or false to enforce it.
ignore-permission-check: false

# Hide permission warnings when the executor does not have the required permissions.
# Set to true to suppress warnings, or false to show them.
hide-permission-warning: false

# A list of commands to execute on the server.
commands:
  # Command 1
  - command: 'velocity info' # The command string to be executed.
    delay: 0                     # Delay (in seconds) before executing the command.
    target-executor: 'player'    # Who executes the command: 'player' or 'console'.
    check-if-executor-is-player: true  # If true, ensures the executor is a player.
    check-if-executor-is-on-server: true # If true, ensures the executor is online.

  # Command 2
  - command: 'velocity plugins' # The command string to be executed.
    delay: 0                      # Delay (in seconds) before executing the command.
    target-executor: 'console'    # Who executes the command: 'player' or 'console'.
    check-if-executor-is-player: false  # If true, ensures the executor is a player.
    check-if-executor-is-on-server: false # If true, ensures the executor is online.
</file>

<file path="velocity/src/main/java/dev/consti/commandbridge/velocity/core/Runtime.java">
package dev.consti.commandbridge.velocity.core;


import dev.consti.commandbridge.velocity.Main;
import dev.consti.commandbridge.velocity.command.CommandDispatcher;
import dev.consti.commandbridge.velocity.command.CommandForwarder;
import dev.consti.commandbridge.velocity.command.CommandRegistrar;
import dev.consti.commandbridge.velocity.util.GeneralUtils;
import dev.consti.commandbridge.velocity.util.ScriptUtils;
import dev.consti.commandbridge.velocity.websocket.HttpServer;
import dev.consti.commandbridge.velocity.websocket.Server;
import dev.consti.foundationlib.logging.Logger;
import dev.consti.foundationlib.utils.ConfigManager;

public class Runtime {
    private static Runtime instance;
    private Logger logger;
    private ConfigManager config;
    private ScriptUtils scriptUtils;
    private Server server;
    private Startup startup;
    private CommandForwarder helper;
    private CommandRegistrar registrar;
    private GeneralUtils generalUtils;
    private CommandDispatcher commandDispatcher;
    private HttpServer httpServer;

    private Runtime() {}

    public static synchronized Runtime getInstance() {
        if (instance == null) {
            instance = new Runtime();
            instance.getLogger().debug("Runtime singleton instance initialized.");
        }
        return instance;
    }

    public synchronized Logger getLogger() {
        if (logger == null) {
            logger = new Logger("CommandBridge");
            logger.debug("Logger initialized.");
        }
        return logger;
    }

    public synchronized ConfigManager getConfig() {
        if (config == null) {
            config = new ConfigManager(getLogger(), "CommandBridge");
            getLogger().debug("ConfigManager initialized.");
        }
        return config;
    }

    public synchronized ScriptUtils getScriptUtils() {
        if (scriptUtils == null) {
            scriptUtils = new ScriptUtils(getLogger(), "CommandBridge");
            getLogger().debug("ScriptUtils initialized.");
        }
        return scriptUtils;
    }

    public synchronized Server getServer() {
        if (server == null) {
            server = new Server(getLogger(), getConfig().getSecret());
            getLogger().debug("Server initialized.");
        }
        return server;
    }

    public synchronized Startup getStartup() {
        if (startup == null) {
            startup = new Startup(getLogger());
            getLogger().debug("Startup initialized.");
        }
        return startup;
    }

    public synchronized CommandForwarder getHelper() {
        if (helper == null) {
            helper = new CommandForwarder(getLogger(), Main.getInstance());
            getLogger().debug("CommandForwarder initialized.");
        }
        return helper;
    }

    public synchronized CommandRegistrar getRegistrar() {
        if (registrar == null) {
            registrar = new CommandRegistrar(getLogger());
            getLogger().debug("InternalRegistrar initialized.");
        }
        return registrar;
    }

    public synchronized GeneralUtils getGeneralUtils() {
        if (generalUtils == null) {
            generalUtils = new GeneralUtils(getLogger());
            getLogger().debug("GeneralUtils initialized.");
        }
        return generalUtils;
    }

    public synchronized CommandDispatcher getCommandExecutor() {
        if (commandDispatcher == null) {
            commandDispatcher = new CommandDispatcher();
            getLogger().debug("CommandDispatcher initialized.");
        }
        return commandDispatcher;
    }

    public synchronized HttpServer getHttpServer() {
        if (httpServer == null) {
            httpServer = new HttpServer(logger);
            getLogger().debug("HttpServer initialized.");
        }
        return httpServer;
    }
}
</file>

<file path="velocity/src/main/java/dev/consti/commandbridge/velocity/helper/command/StopCommand.java">
package dev.consti.commandbridge.velocity.helper.command;

import com.mojang.brigadier.builder.LiteralArgumentBuilder;
import com.velocitypowered.api.command.CommandSource;
import dev.consti.commandbridge.velocity.core.Runtime;
import dev.consti.foundationlib.logging.Logger;
import net.kyori.adventure.text.Component;
import net.kyori.adventure.text.format.NamedTextColor;


public class StopCommand {
    public static LiteralArgumentBuilder<CommandSource> build(Logger logger) {
        return LiteralArgumentBuilder.<CommandSource>literal("stop")
                .executes(context -> {
                    CommandSource source = context.getSource();
                    if (!source.hasPermission("commandbridge.admin")) {
                        source.sendMessage(Component.text("You do not have permission to stop the WebSocket server", NamedTextColor.RED));
                        return 0;
                    }

                    Runtime.getInstance().getStartup().stop();
                    source.sendMessage(Component.text("WebSocket Server stopped").color(NamedTextColor.YELLOW));
                    return 1;
                });
    }
}
</file>

<file path="velocity/src/main/java/dev/consti/commandbridge/velocity/helper/HelpCommand.java">
package dev.consti.commandbridge.velocity.helper;

import com.mojang.brigadier.builder.LiteralArgumentBuilder;
import com.velocitypowered.api.command.CommandSource;
import dev.consti.foundationlib.logging.Logger;
import net.kyori.adventure.text.Component;
import net.kyori.adventure.text.event.ClickEvent;
import net.kyori.adventure.text.format.NamedTextColor;
import net.kyori.adventure.text.format.TextDecoration;

public class HelpCommand {
    public static LiteralArgumentBuilder<CommandSource> build(Logger logger) {
        return LiteralArgumentBuilder.<CommandSource>literal("help")
                .executes(context -> sendHelpMessage(context.getSource(), logger));
    }

    public static int sendHelpMessage(CommandSource source, Logger logger) {
        logger.debug("Sending help message to: {}", source);

        source.sendMessage(Component.text("==== CommandBridge Help ====").color(NamedTextColor.GOLD));
        source.sendMessage(Component.text(""));

        source.sendMessage(Component.text("Available Commands:").color(NamedTextColor.YELLOW));

        source.sendMessage(formatCommand("help", "Displays this help message", false));
        source.sendMessage(formatCommand("list", "Lists connected clients", false));
        source.sendMessage(formatCommand("reload", "Reloads all configs and scripts", false));
        source.sendMessage(formatCommand("version", "Displays the current version", false));

        source.sendMessage(Component.text(""));
        source.sendMessage(Component.text("Debug Commands (Debug mode only):").color(NamedTextColor.RED));
        source.sendMessage(formatCommand("stop", "Stops the cb server", false));
        source.sendMessage(formatCommand("start", "Starts the cb server", false));

        source.sendMessage(Component.text(""));
        source.sendMessage(Component.text("Client Commands (/cbc):").color(NamedTextColor.AQUA));
        source.sendMessage(formatCommand("reconnect", "Reconnects the current client", true));

        source.sendMessage(Component.text(""));
        source.sendMessage(Component.text("Documentation: ")
                .append(Component.text("https://docs.commandbridge.72s.dev")
                        .color(NamedTextColor.LIGHT_PURPLE)
                        .decorate(TextDecoration.UNDERLINED)
                        .clickEvent(ClickEvent.openUrl("https://72-s.github.io/CommandBridge/"))));

        source.sendMessage(Component.text(""));
        source.sendMessage(Component.text("============================").color(NamedTextColor.GOLD));
        return 1;
    }

    private static Component formatCommand(String command, String description, boolean client) {
        String alias = client ? "/cbc " : "/cb ";
        return Component.text("  - ")
                .append(Component.text(alias + command).color(NamedTextColor.GREEN))
                .append(Component.text(" - " + description).color(NamedTextColor.WHITE));
    }
}
</file>

<file path="wiki/getting-started/installation.md">
---
description: >-
  Installing CommandBridge is quick and simple. Follow these steps to get started.
---

# üì© Installation

### Setup **the Plugin**

1. Download the latest **`CommandBridge-xxx-all.jar`** from the [releases page](https://modrinth.com/plugin/commandbridge/versions).  
2. Place the JAR file into the `plugins` folder on **both your Velocity and Paper servers**.  
3. Restart **both** the **Velocity and Paper** server and let the plugin generate its configs. 

{% hint style="success" %}  
No need for separate JARs ‚Äì CommandBridge will automatically detect whether it‚Äôs running on Velocity or Paper.  
{% endhint %}

***

### **Upgrading to Version 2.0.0**

If you‚Äôre upgrading from an older version of CommandBridge to version **2.0.0 or above**, follow these additional steps:

1. **Convert Scripts Manually**:  
   * The script format has changed. You‚Äôll need to manually convert your old scripts to the new format. You can see how to write the scripts [here](../scripts/guide.md).  
2. **Regenerate `config.yml`**:  
   * Delete your old `config.yml`.  
   * Start the server to let the plugin generate a new configuration file.  
   * Follow the [plugin setup guide](plugin-setup.md) on how to configure the plugin.

{% hint style="info" %}  
Future updates will include an automatic script converter for easier upgrades.  
{% endhint %}
</file>

<file path="wiki/getting-started/plugin-setup.md">
---
description: >-
  After installing the CommandBridge plugin and restarting your servers, follow this guide to configure it properly. This guide assumes you have restarted all servers with the plugin installed.
---

# ‚öôÔ∏è Plugin setup

### **Important Terminology**

<table>
  <thead>
    <tr><th width="200">Clients</th><th>Server</th></tr>
  </thead>
  <tbody>
    <tr><td>All Paper servers</td><td>The Velocity proxy</td></tr>
  </tbody>
</table>

In this guide, when referring to "clients," it means all the Paper servers connected to your Velocity server (the "server").

***

### **Verify File Generation**

After restarting your servers, the following files and folders should be generated:

**On Each Paper Server:**

```markdown
paper/
‚îî‚îÄ‚îÄ plugins/
    ‚îî‚îÄ‚îÄ CommandBridge/
        ‚îú‚îÄ‚îÄ config.yml             # Main configuration file for the Paper server
        ‚îî‚îÄ‚îÄ scripts/               # Folder for script configurations
            ‚îî‚îÄ‚îÄ example.yml        # Example script configuration
``` 

**On the Velocity Server:**

```markdown
velocity/
‚îî‚îÄ‚îÄ plugins/
    ‚îî‚îÄ‚îÄ CommandBridge/
        ‚îú‚îÄ‚îÄ config.yml             # Main configuration file for the Velocity proxy
        ‚îú‚îÄ‚îÄ secret.key             # Secret key for authentication (only on Velocity)
        ‚îî‚îÄ‚îÄ scripts/               # Folder for script configurations
            ‚îî‚îÄ‚îÄ example.yml        # Example script configuration
``` 

#### Key Notes:

* The **`secret.key`** file is **only generated on the Velocity server**.  
* Both Velocity and Paper servers have:  
  * **`config.yml`** ‚Äì Configuration file specific to each platform (proxy or server).  
  * **`scripts/`** ‚Äì A folder containing script configuration files (with a default `example.yml` provided).

If these files and folders match your setup, proceed to the next steps. Otherwise, ensure the plugin is installed correctly on all servers.

***

### **Step 1: Set the Secret Key**

1. **Open the `secret.key` file** in the Velocity `plugins/CommandBridge/` folder.  
2. Copy the key (a long string) and paste it into the `secret` field in the `config.yml` file of **each Paper server**:  

   ```yaml
   secret: "CHANGE_ME"
   ```  

   Replace `"CHANGE_ME"` with the value from the Velocity `secret.key` file.

{% hint style="danger" %}  
Do not share this key. **Anyone with this key can connect to your CommandBridge and execute commands on your network.**  
{% endhint %}

***

### **Step 2: Set Unique IDs**

Each Paper server is a client and needs a unique identifier:

- **On Paper (Client)**: In each Paper server‚Äôs `config.yml`, set the **`client-id`** to a unique name for that server. For example, if the server is called "lobby", use:  

  ```yaml
  client-id: "lobby"
  ```  

  Ensure no two Paper servers share the same `client-id`.

- **On Velocity (Server)**: In the Velocity `config.yml`, set the **`server-id`**. By default, this is `"main"`. You can typically leave this as is (only change if you intend to have multiple CommandBridge servers).

***

### **Step 3: Configure Velocity Network Settings**

1. **Host** (`host` in Velocity `config.yml`): By default this is `0.0.0.0` (all network interfaces).  
   - If your Velocity proxy and Paper servers run on the **same machine** (self-hosted setup), you can set this to `127.0.0.1` to bind locally.  
   - If you are using an external hosting provider or different machines, leave it as `0.0.0.0` so it listens on all interfaces.

2. **Port** (`port` in Velocity `config.yml`): Choose an unused TCP port for CommandBridge to communicate.  
   - Update the `port` field with that number. For example:  

     ```yaml
     port: 3000
     ```  

   - If self-hosting, ensure this port is open on your machine‚Äôs firewall.  
   - If using a hosting provider, use their panel/tools to open this port for your Velocity proxy.

3. **SAN (Subject Alternative Name)** (`san` in Velocity `config.yml`):  
   - Set this to the **IP address or domain name of your Velocity server** (**do not include the port**). For example:  

     ```yaml
     san: "152.248.198.124"
     ```  

   - This is used for SSL certificate generation. It must match the address that clients (Paper servers) use to connect.

{% hint style="warning" %}  
Do not include the port in the SAN value. For example, use `"152.248.198.124"`, **not** `"152.248.198.124:3000"`.  
{% endhint %}

***

### **Step 4: Configure Paper Clients**

For each Paper server (client):

1. **Remote Host** (`remote` in Paper `config.yml`): Set this to the IP address or domain of the Velocity server (the same value you used for Velocity‚Äôs SAN, without port). For example:  

   ```yaml
   remote: "152.248.198.124"
   ```  

2. **Port** (`port` in Paper `config.yml`): Set this to the same port number you configured in the Velocity config (e.g., `3000` in our example).

These settings tell each Paper server how to reach the Velocity server‚Äôs CommandBridge socket.

***

### **Step 5: Restart Servers**

Now restart your servers in the following order:

1. **Restart Velocity first** (the proxy server).  
2. Once Velocity is up, restart all the connected Paper servers.

Starting Velocity first ensures it‚Äôs ready to accept connections from the Paper clients.

***

### **Validation**

While the servers are starting up, check the **Velocity console** for log messages like these:

```
[21:10:10 INFO] [CommandBridge]: New connection attempt from /127.0.0.1:42918  
[21:10:10 INFO] [CommandBridge]: Client authenticated successfully: /127.0.0.1:42918  
[21:10:10 INFO] [CommandBridge]: Added connected client: lobby
```

These logs indicate a Paper client (`lobby` in this case) connected and authenticated. If you see messages like that for each Paper server, your configuration is successful!

If these logs do **not** appear (or you see errors), double-check the configuration files for typos or mismatched values and ensure any required ports are open.
</file>

<file path="wiki/getting-started/requirements.md">
---
description: >-
  Before installing CommandBridge, ensure that your server setup meets the following requirements. The plugin has specific dependencies and version requirements to function correctly.
---

# üìò Requirements

[#summary-for-lazy-people](requirements.md#summary-for-lazy-people "mention")

{% hint style="warning" %}  
For older plugin versions, please refer to the [legacy wiki](https://docs.old.huraxdax.club).  
{% endhint %}

### **Java Requirements**

| Plugin version      | Java version |
| ------------------- | ------------ |
| 2.0.0 and above     | 21           |
| below 2.0.0 (1.8.4) | 17           |

### **Minecraft Compatibility**

| Plugin version      | Minecraft version |
| ------------------- | ----------------- |
| 2.0.0 and above     | 1.20.x ‚Äì 1.21.x   |
| below 2.0.0 (1.8.4) | 1.20.x ‚Äì 1.21.1   |

***

### **Permission Management**

CommandBridge requires a **permission plugin** to manage command execution effectively.

* **Recommended**: [LuckPerms](https://luckperms.net/) (highly compatible and actively maintained).  
* **Required Setup**:  
  * Install a permission plugin **on both the Velocity and Paper servers**.  
  * Any permission plugin will work, but ensure it‚Äôs installed on both platforms.

***

### **Plugin Compatibility**

CommandBridge is a **cross-compatible plugin** designed to run on both **Velocity** and **Paper** servers using the same JAR file. Below are the specific compatibility details:

| Server Type                            | Compatibility       | Notes                                                         |
| -------------------------------------- | ------------------- | ------------------------------------------------------------- |
| Velocity                               | ‚úÖ Supported         | Fully supported. Designed for the Velocity proxy.             |
| Paper                                  | ‚úÖ Supported         | Fully supported. Built on the Paper API.                      |
| Spigot                                 | ‚úÖ Supported         | Supported via Paper compatibility layer.                      |
| Bukkit                                 | ‚úÖ Supported         | Supported via Paper compatibility layer.                      |
| Folia (Paper fork)                     | ‚úÖ Supported         | Uses regionized multithreading. Should work but may contain bugs. |
| Purpur (Paper fork)                    | ‚ö†Ô∏è Not Fully Tested | Should work (based on Paper), but not officially tested.      |
| Tuinity (Paper fork)                   | ‚ö†Ô∏è Not Fully Tested | May work, but not officially tested or guaranteed.            |
| Cross-platform proxies (e.g., Waterfall) | ‚ö†Ô∏è Not Tested       | Should work with Velocity on backend, but not explicitly tested. |
| Modloaders (Forge/Fabric etc.)         | ‚ùå Not Supported     | Only plugin platforms are supported (no modloader compatibility). |

### **Summary (for lazy people)**

| Requirement           | Details                                                      |
| --------------------- | ------------------------------------------------------------ |
| **Java Version**      | Java 21 (for v2.0.0+). For older plugin versions (v1.8.4 and below), use Java 17. |
| **Minecraft Version** | Supports Minecraft 1.20.x ‚Äì 1.21.x for v2.0.0+. Older Minecraft versions require using the legacy plugin (latest legacy version: 1.8.4). |
| **Permission Plugin** | Required on both Velocity and Paper servers. Recommended: [LuckPerms](https://luckperms.net/). |
| **Server Software**   | Use Velocity (proxy) and Paper (server). Bukkit/Spigot work via Paper compatibility but are not separately tested. Modloaders are **not** supported. |
</file>

<file path="wiki/other/data-collection.md">
---
description: >-
  Information on what data CommandBridge collects and how to opt out.
---

# üî¢ Data collection

CommandBridge uses an open-source metrics service called [bStats](https://bstats.org/) to collect **anonymous statistics** about plugin usage. This helps the developer understand how the plugin is used (like how many servers use it, what Minecraft version, etc.) and improve it over time.

**What is collected**: Basic server info such as plugin version, Minecraft version, player count, and other non-personal statistics. **No personal or sensitive data** (like IPs or chat) is collected.

**How to opt out**: You can disable metrics collection by editing the `plugins/bStats/config.yml` file on each server and setting `enabled: false`. After that, no data will be sent to bStats from that server.

![bStats](https://bstats.org/signatures/velocity/CommandBridge.svg)

*The chart above is an example of a bStats graph for CommandBridge (showing the number of servers using the plugin over time).*

This data collection follows the standard practice for many Minecraft plugins and is completely anonymous. It can be useful for the developer and does not impact performance. However, the choice is yours ‚Äì you can easily opt out as described.

_For more details on bStats, you can visit their site [here](https://bstats.org/)._
</file>

<file path="wiki/troubleshooting/common-issues.md">
---
description: >-
  Solutions to common problems when setting up or using CommandBridge.
---

# ‚ùå Common issues

Setting up a proxy and multiple servers can be tricky. Here are some common issues you might encounter with CommandBridge and how to resolve them.

### 1. Paper server cannot connect to Velocity (No connection / authentication fails)

**Symptoms:** In Velocity‚Äôs console, you **do not** see the ‚ÄúClient authenticated successfully‚Äù message for one or more Paper servers when they start. Paper server logs might show errors or timeout trying to connect.

**Possible Causes & Solutions:**

- **Secret key mismatch:** Ensure you correctly copied the secret key from Velocity‚Äôs `secret.key` into each Paper server‚Äôs `config.yml` (`secret` field). A wrong or missing key will prevent the Paper client from authenticating. *(If you regenerate the Velocity secret.key, you must update all clients again.)*

- **Host/Remote configuration:** Double-check the `host` in Velocity‚Äôs config and the `remote` in Paper‚Äôs config. For example, if Velocity‚Äôs host is set to `127.0.0.1` (localhost), then Paper‚Äôs `remote` must also point to `127.0.0.1` ‚Äì and they *must be running on the same machine*. If your Paper server is on a different machine or container, Velocity‚Äôs `host` should be `0.0.0.0` (and Paper‚Äôs `remote` should use Velocity‚Äôs external IP or domain).

- **Port not open or mismatched:** Verify that the `port` number is the same in Velocity and all Paper configs. Also ensure that port is not blocked by a firewall:
  - If self-hosting, check your OS firewall or router port forwarding for the specified port.  
  - If using a server host, use their panel to open the port for the Velocity proxy.  
  - If the port is in use by another service, choose a different port in the configs and restart.

- **SAN not configured or wrong:** The **SAN (Subject Alternative Name)** in Velocity‚Äôs config must include the IP or domain that Paper clients use to connect. If this is incorrect, the SSL certificate will not match and the connection will fail. For example, if Paper‚Äôs `remote` is set to `"example.com"`, then Velocity‚Äôs `san` should be `"example.com"` as well. Do not include ports in the SAN or remote fields.

After checking these settings, restart Velocity first, then Paper servers. Watch the Velocity console for connection messages. If it still fails, turn on **debug mode** (set `debug: true` in Velocity‚Äôs `config.yml` and restart) to get detailed logs, and look for any specific error messages.

### 2. ‚ÄúAddress already in use‚Äù error on Velocity startup

**Symptom:** Velocity‚Äôs console shows an error indicating it couldn‚Äôt bind to the port (e.g., `java.net.BindException: Address already in use`).

**Cause:** The port configured for CommandBridge is already being used by another service (or another instance of Velocity).

**Solution:** Choose a different unused port in Velocity‚Äôs `config.yml` for CommandBridge and update all Paper servers‚Äô `config.yml` to match the new port. Then restart Velocity (and Paper servers). Ensure no other application is using that port. Commonly, ports 3000‚Äì4000 are free, but it depends on your environment.

### 3. ‚ÄúClient authenticated successfully‚Äù appears, but commands aren‚Äôt executing

**Symptom:** Velocity‚Äôs log shows that clients connected, but when you run a CommandBridge command, nothing happens on the other side.

**Possible Causes & Solutions:**

- **Scripts not defined on that side:** Make sure you created the script configuration on the correct side. For example, if a player runs a command on a Paper server, that command needs to be defined either on the Paper side (to forward to Velocity) or on Velocity (to accept forwarded commands). If only defined on Velocity, ensure the command name is not being blocked on Paper. If in doubt, define the script on both sides or use a Velocity-side script as shown in the **Scripts Guide** for global commands.

- **Permission issues:** By default, CommandBridge requires players to have permission to use custom commands. If `ignore-permission-check` is `false` in your script config, you need to grant the appropriate permission node via your permissions plugin:
  - The permission node is `commandbridge.command.<name>` (where `<name>` is the script name). For example, for a script named ‚Äúhub‚Äù, give players `commandbridge.command.hub`.  
  - Alternatively, you can set `ignore-permission-check: true` in the script config to temporarily bypass permission checks (not recommended for public commands).  
  - Ensure this is done on both Velocity and Paper (since a player might trigger the command on either platform).

- **Missing dependency:** Ensure you have a permission plugin installed on both Velocity and Paper. Without one, permission checks might automatically fail. (LuckPerms on both is recommended.)

- **Target server issues:** If a script is supposed to run a command on a target Paper server and nothing happens, check that the target server‚Äôs `client-id` exactly matches what the script‚Äôs `target-client-ids` list uses (case-sensitive). If the names don‚Äôt match, Velocity will send the command to a non-existent target.

- **Plugin not loaded or script disabled:** Confirm that the CommandBridge plugin is actually enabled on all servers (`/plugins` on Paper, or `/bridge version` on Velocity‚Äôs console). If the plugin failed to load on a server (check console for errors on startup), fix that first. Also verify the script file has `enabled: true`.

### 4. ‚ÄúYou do not have permission to use this command‚Äù message when using a script command

**Cause:** This indicates the player (or console) triggering the CommandBridge command doesn‚Äôt have permission, and the script has not ignored permission checks.

**Solution:** As mentioned above, grant the appropriate permission via your permissions plugin, or set the script‚Äôs `ignore-permission-check: true` if you want to bypass. If you prefer to hide this message without giving permission, you can set `hide-permission-warning: true` (though the command still won‚Äôt run). Generally, for player-facing commands, it‚Äôs best to give them permission in a controlled way.

### 5. Commands run, but placeholders aren‚Äôt working

**Symptom:** You used placeholders (like `%cb_player%` or a PlaceholderAPI code) in your script, but in the executed command it shows the literal placeholder text or nothing happens.

**Solution:** 
- Make sure you have PlaceholderAPI installed on Paper if you are using placeholders other than the built-in `%cb_...%` ones. Without PAPI, only the built-in placeholders will be replaced.  
- If using placeholders on Velocity side, consider installing PapiProxyBridge on Velocity so that PAPI placeholders can be recognized on the proxy.  
- Check logs in debug mode ‚Äì CommandBridge will log whether it hooked into PlaceholderAPI. If it says PAPI not found, you know why placeholders weren‚Äôt parsed.  
- Also ensure your placeholder syntax is correct and supported. For example, built-in placeholders use `%cb_player%` exactly (all lowercase).

### 6. Still having issues?

If you‚Äôve checked the above and are still experiencing problems, see the **Support resources** page for where to get additional help (Discord or GitHub). Enabling `debug: true` in the config and then replicating the issue can provide more detailed logs to share when asking for support.
</file>

<file path="wiki/README.md">
---
description: >-
  Welcome to my documentation! This guide will help you install and configure the CommandBridge plugin.
---

# üëã Welcome

{% hint style="warning" %}  
This documentation applies **only to CommandBridge plugin versions 2.0.0 and above**.

If you are using an earlier version, please refer to the [legacy documentation](https://docs.old.huraxdax.club/).  
{% endhint %}

### What This Documentation Covers

* [x] Quick Installation  
* [x] Configuration Guide  
* [x] Troubleshooting  
* [ ] How to escape vim

### Why use CommandBridge?

CommandBridge is the easiest way to enable **real-time, cross-server communication** between Velocity and Paper servers.  
Seamlessly manage commands, automate tasks, and create a unified server experience.
</file>

<file path="wiki/use-cases.md">
---
description: >-
  CommandBridge shines in scenarios where you need cross-server communication to execute commands seamlessly. Below are practical scenarios where CommandBridge can be a game-changer.
---

# ü§ñ Use cases

### <mark style="color:orange;">Example 1:</mark> Global `/hub` Command with Additional Actions

**Scenario**:  
You want to implement a global `/hub` command that works on **any server in your network**. When a player types `/hub`, they are:

1. **Teleported to the hub server** (handled by Velocity).  
2. Once in the hub, a **Paper plugin plays background music** using the `/music` command.

**Problem**:

* The `/hub` command isn‚Äôt natively available on Paper servers.  
* The `/music` command can only be executed on the hub server.

**Solution with CommandBridge**:  
CommandBridge lets you define the `/hub` command as follows:

1. The **player types `/hub`** on any server (Paper or Velocity).  
2. **CommandBridge triggers the teleport** to the hub server using Velocity‚Äôs `/server hub` command.  
3. Once the player is on the hub server, **CommandBridge automatically executes `/music`** as the player.

| Step                   | Action                                        | Executed On        |
| ---------------------- | --------------------------------------------- | ------------------ |
| **Player runs `/hub`** | CommandBridge receives and processes the command. | Velocity           |
| **Teleport to hub**    | Executes Velocity's `/server hub` command to teleport. | Velocity           |
| **Play music**         | Executes `/music` for the player after teleporting. | Hub (Paper plugin) |

**Why Use CommandBridge?**

* **Global availability**: `/hub` works from any server in your network.  
* **Multi-step execution**: Executes commands in sequence, even across servers.  
* **Automation**: Automatically triggers the `/music` command without user intervention.

***

### <mark style="color:orange;">**Example 2:**</mark> Timed Gameplay with Return to Lobby

**Scenario**:  
You have a **minigame server** where players have **15 minutes** to play. After their time is up, they must:

1. **Teleport back to the main lobby** (handled by Velocity).  
2. A message should appear announcing their return, triggered on the minigame server.

**Problem**:

* Paper doesn‚Äôt support Velocity‚Äôs `/server` commands natively.  
* The minigame server needs to trigger global actions without direct access to Velocity commands.

**Solution with CommandBridge**:

1. A **Paper plugin** on the minigame server triggers a CommandBridge-defined command, e.g., `/end-session`.  
2. CommandBridge teleports the player to the lobby using Velocity‚Äôs `/server lobby`.  
3. CommandBridge executes a follow-up `/broadcast` command on the minigame server, announcing their departure.

| Step                       | Action                                              | Executed On      |
| -------------------------- | --------------------------------------------------- | ---------------- |
| **Trigger `/end-session`** | Minigame plugin triggers the CommandBridge command.  | Minigame (Paper) |
| **Teleport to lobby**      | Executes Velocity‚Äôs `/server lobby` command.         | Velocity         |
| **Announce return**        | Broadcasts a farewell message to players.           | Minigame (Paper) |

**Why Use CommandBridge?**

* **Seamless teleportation**: Coordinates actions across Velocity and Paper.  
* **Custom workflows**: Chains actions like teleporting and messaging.

***

### <mark style="color:orange;">**Example 3:**</mark> Centralized Rewards with Conditional Actions

**Scenario**:  
You‚Äôre running a **network-wide event** where players can earn rewards. After claiming their reward:

1. They are **teleported to a ‚Äúrewards room‚Äù server**.  
2. The server **gives them a diamond** automatically.  
3. An announcement is broadcast **only on the rewards server**.

**Problem**:

* Bukkit/Paper plugins can‚Äôt trigger Velocity‚Äôs `/server` commands directly.  
* Reward actions need to be automated and localized per server.

**Solution with CommandBridge**:

1. Define a CommandBridge command, e.g., `/claim-reward`.  
2. The command:  
   * Teleports the player to the ‚Äúrewards room‚Äù using Velocity‚Äôs `/server rewards`.  
   * Executes `/give %cb_player% diamond` on the rewards server (Paper) to give a diamond to the player.  
   * Sends a local announcement using `/say %cb_player% claimed their reward!` on the rewards server.

| Step                            | Action                                       | Executed On     |
| ------------------------------- | -------------------------------------------- | --------------- |
| **Player runs `/claim-reward`** | CommandBridge triggers the sequence.         | Any server      |
| **Teleport to rewards server**  | Executes `/server rewards`.                  | Velocity        |
| **Give diamond**                | Runs `/give {player} diamond`.               | Rewards (Paper) |
| **Local announcement**          | Sends `/say {player} claimed their reward!`. | Rewards (Paper) |

**Why Use CommandBridge?**

* **Cross-server coordination**: Automates actions across multiple servers.  
* **Localized commands**: Keeps announcements server-specific while managing rewards globally.

***

### **When Should You Use CommandBridge?**¬†

CommandBridge is ideal if you:

* **Need global commands** that work on every server in your network.  
* **Automate multi-step workflows**, such as teleportation and follow-up actions.  
* **Coordinate cross-server actions** seamlessly between Velocity and Paper.
</file>

<file path="gradlew">
#!/bin/sh

#
# Copyright ¬© 2015-2021 the original authors.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      https://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#
# SPDX-License-Identifier: Apache-2.0
#

##############################################################################
#
#   Gradle start up script for POSIX generated by Gradle.
#
#   Important for running:
#
#   (1) You need a POSIX-compliant shell to run this script. If your /bin/sh is
#       noncompliant, but you have some other compliant shell such as ksh or
#       bash, then to run this script, type that shell name before the whole
#       command line, like:
#
#           ksh Gradle
#
#       Busybox and similar reduced shells will NOT work, because this script
#       requires all of these POSIX shell features:
#         * functions;
#         * expansions ¬´$var¬ª, ¬´${var}¬ª, ¬´${var:-default}¬ª, ¬´${var+SET}¬ª,
#           ¬´${var#prefix}¬ª, ¬´${var%suffix}¬ª, and ¬´$( cmd )¬ª;
#         * compound commands having a testable exit status, especially ¬´case¬ª;
#         * various built-in commands including ¬´command¬ª, ¬´set¬ª, and ¬´ulimit¬ª.
#
#   Important for patching:
#
#   (2) This script targets any POSIX shell, so it avoids extensions provided
#       by Bash, Ksh, etc; in particular arrays are avoided.
#
#       The "traditional" practice of packing multiple parameters into a
#       space-separated string is a well documented source of bugs and security
#       problems, so this is (mostly) avoided, by progressively accumulating
#       options in "$@", and eventually passing that to Java.
#
#       Where the inherited environment variables (DEFAULT_JVM_OPTS, JAVA_OPTS,
#       and GRADLE_OPTS) rely on word-splitting, this is performed explicitly;
#       see the in-line comments for details.
#
#       There are tweaks for specific operating systems such as AIX, CygWin,
#       Darwin, MinGW, and NonStop.
#
#   (3) This script is generated from the Groovy template
#       https://github.com/gradle/gradle/blob/HEAD/platforms/jvm/plugins-application/src/main/resources/org/gradle/api/internal/plugins/unixStartScript.txt
#       within the Gradle project.
#
#       You can find Gradle at https://github.com/gradle/gradle/.
#
##############################################################################

# Attempt to set APP_HOME

# Resolve links: $0 may be a link
app_path=$0

# Need this for daisy-chained symlinks.
while
    APP_HOME=${app_path%"${app_path##*/}"}  # leaves a trailing /; empty if no leading path
    [ -h "$app_path" ]
do
    ls=$( ls -ld "$app_path" )
    link=${ls#*' -> '}
    case $link in             #(
      /*)   app_path=$link ;; #(
      *)    app_path=$APP_HOME$link ;;
    esac
done

# This is normally unused
# shellcheck disable=SC2034
APP_BASE_NAME=${0##*/}
# Discard cd standard output in case $CDPATH is set (https://github.com/gradle/gradle/issues/25036)
APP_HOME=$( cd -P "${APP_HOME:-./}" > /dev/null && printf '%s
' "$PWD" ) || exit

# Use the maximum available, or set MAX_FD != -1 to use that value.
MAX_FD=maximum

warn () {
    echo "$*"
} >&2

die () {
    echo
    echo "$*"
    echo
    exit 1
} >&2

# OS specific support (must be 'true' or 'false').
cygwin=false
msys=false
darwin=false
nonstop=false
case "$( uname )" in                #(
  CYGWIN* )         cygwin=true  ;; #(
  Darwin* )         darwin=true  ;; #(
  MSYS* | MINGW* )  msys=true    ;; #(
  NONSTOP* )        nonstop=true ;;
esac

CLASSPATH=$APP_HOME/gradle/wrapper/gradle-wrapper.jar


# Determine the Java command to use to start the JVM.
if [ -n "$JAVA_HOME" ] ; then
    if [ -x "$JAVA_HOME/jre/sh/java" ] ; then
        # IBM's JDK on AIX uses strange locations for the executables
        JAVACMD=$JAVA_HOME/jre/sh/java
    else
        JAVACMD=$JAVA_HOME/bin/java
    fi
    if [ ! -x "$JAVACMD" ] ; then
        die "ERROR: JAVA_HOME is set to an invalid directory: $JAVA_HOME

Please set the JAVA_HOME variable in your environment to match the
location of your Java installation."
    fi
else
    JAVACMD=java
    if ! command -v java >/dev/null 2>&1
    then
        die "ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.

Please set the JAVA_HOME variable in your environment to match the
location of your Java installation."
    fi
fi

# Increase the maximum file descriptors if we can.
if ! "$cygwin" && ! "$darwin" && ! "$nonstop" ; then
    case $MAX_FD in #(
      max*)
        # In POSIX sh, ulimit -H is undefined. That's why the result is checked to see if it worked.
        # shellcheck disable=SC2039,SC3045
        MAX_FD=$( ulimit -H -n ) ||
            warn "Could not query maximum file descriptor limit"
    esac
    case $MAX_FD in  #(
      '' | soft) :;; #(
      *)
        # In POSIX sh, ulimit -n is undefined. That's why the result is checked to see if it worked.
        # shellcheck disable=SC2039,SC3045
        ulimit -n "$MAX_FD" ||
            warn "Could not set maximum file descriptor limit to $MAX_FD"
    esac
fi

# Collect all arguments for the java command, stacking in reverse order:
#   * args from the command line
#   * the main class name
#   * -classpath
#   * -D...appname settings
#   * --module-path (only if needed)
#   * DEFAULT_JVM_OPTS, JAVA_OPTS, and GRADLE_OPTS environment variables.

# For Cygwin or MSYS, switch paths to Windows format before running java
if "$cygwin" || "$msys" ; then
    APP_HOME=$( cygpath --path --mixed "$APP_HOME" )
    CLASSPATH=$( cygpath --path --mixed "$CLASSPATH" )

    JAVACMD=$( cygpath --unix "$JAVACMD" )

    # Now convert the arguments - kludge to limit ourselves to /bin/sh
    for arg do
        if
            case $arg in                                #(
              -*)   false ;;                            # don't mess with options #(
              /?*)  t=${arg#/} t=/${t%%/*}              # looks like a POSIX filepath
                    [ -e "$t" ] ;;                      #(
              *)    false ;;
            esac
        then
            arg=$( cygpath --path --ignore --mixed "$arg" )
        fi
        # Roll the args list around exactly as many times as the number of
        # args, so each arg winds up back in the position where it started, but
        # possibly modified.
        #
        # NB: a `for` loop captures its iteration list before it begins, so
        # changing the positional parameters here affects neither the number of
        # iterations, nor the values presented in `arg`.
        shift                   # remove old arg
        set -- "$@" "$arg"      # push replacement arg
    done
fi


# Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
DEFAULT_JVM_OPTS='"-Xmx64m" "-Xms64m"'

# Collect all arguments for the java command:
#   * DEFAULT_JVM_OPTS, JAVA_OPTS, JAVA_OPTS, and optsEnvironmentVar are not allowed to contain shell fragments,
#     and any embedded shellness will be escaped.
#   * For example: A user cannot expect ${Hostname} to be expanded, as it is an environment variable and will be
#     treated as '${Hostname}' itself on the command line.

set -- \
        "-Dorg.gradle.appname=$APP_BASE_NAME" \
        -classpath "$CLASSPATH" \
        org.gradle.wrapper.GradleWrapperMain \
        "$@"

# Stop when "xargs" is not available.
if ! command -v xargs >/dev/null 2>&1
then
    die "xargs is not available"
fi

# Use "xargs" to parse quoted args.
#
# With -n1 it outputs one arg per line, with the quotes and backslashes removed.
#
# In Bash we could simply go:
#
#   readarray ARGS < <( xargs -n1 <<<"$var" ) &&
#   set -- "${ARGS[@]}" "$@"
#
# but POSIX shell has neither arrays nor command substitution, so instead we
# post-process each arg (as a line of input to sed) to backslash-escape any
# character that might be a shell metacharacter, then use eval to reverse
# that process (while maintaining the separation between arguments), and wrap
# the whole thing up as a single "set" statement.
#
# This will of course break if any of these variables contains a newline or
# an unmatched quote.
#

eval "set -- $(
        printf '%s\n' "$DEFAULT_JVM_OPTS $JAVA_OPTS $GRADLE_OPTS" |
        xargs -n1 |
        sed ' s~[^-[:alnum:]+,./:=@_]~\\&~g; ' |
        tr '\n' ' '
    )" '"$@"'

exec "$JAVACMD" "$@"
</file>

<file path="paper/src/main/java/dev/consti/commandbridge/paper/utils/GeneralUtils.java">
package dev.consti.commandbridge.paper.utils;

import java.util.ArrayList;
import java.util.List;

import org.bukkit.ChatColor;

import dev.consti.commandbridge.paper.Main;
import dev.consti.foundationlib.logging.Logger;
import dev.jorel.commandapi.CommandAPICommand;
import dev.jorel.commandapi.arguments.Argument;
import dev.jorel.commandapi.arguments.ArgumentSuggestions;
import dev.jorel.commandapi.arguments.StringArgument;
import dev.consti.commandbridge.paper.core.Runtime;

public class GeneralUtils {
    private final Logger logger;

    public GeneralUtils(Logger logger) {
        this.logger = logger;
    }

    public void reloadAll() {
        new SchedulerAdapter(Main.getInstance())
                .run(
                        () -> {
                            logger.debug("Running on thread (reload): {}", Thread.currentThread().getName());
                            try {
                                Runtime.getInstance().getConfig().reload();
                                logger.debug("All configs have been reloaded");
                                logger.setDebug(Boolean
                                        .parseBoolean(Runtime.getInstance().getConfig().getKey("config.yml", "debug")));
                                logger.info("Debug mode set to: {}",
                                        Runtime.getInstance().getConfig().getKey("config.yml", "debug"));
                                Runtime.getInstance().getScriptUtils().reload();
                                logger.debug("All scripts have been reloaded");
                                logger.info("Everything Reloaded!");
                                Runtime.getInstance().getClient().sendTask("reload", "success");
                            } catch (Exception e) {
                                logger.error("Error occurred while reloading: {}",
                                        logger.getDebug() ? e : e.getMessage());
                                Runtime.getInstance().getClient().sendTask("reload", "failure");
                            }
                        });
    }

    public void registerCommands() {
        List<Argument<?>> arguments = new ArrayList<>();
        arguments.add(new StringArgument("arguments").replaceSuggestions(ArgumentSuggestions.strings("reconnect")));
        new CommandAPICommand("commandbridgeclient")
                .withArguments(arguments)
                .withAliases("cbc")
                .withPermission("commandbridge.admin")
                .executes((sender, args) -> {
                    String opt = (String) args.get("arguments");
                    if (opt.matches("reconnect")) {
                        Runtime.getInstance().getClient().disconnect();
                        try {
                            Runtime.getInstance().getClient().connect(
                                    Runtime.getInstance().getConfig().getKey("config.yml", "remote"),
                                    Integer.parseInt(Runtime.getInstance().getConfig().getKey("config.yml", "port")));
                            sender.sendMessage(ChatColor.GREEN + "Client reconnected successfully");
                        } catch (Exception e) {
                            logger.error("Client reconnection failed: ", e);
                            sender.sendMessage(ChatColor.RED + "Failed to reconnect");
                        }
                    }
                })
                .register();
    }

}
</file>

<file path="paper/src/main/java/dev/consti/commandbridge/paper/websocket/Client.java">
package dev.consti.commandbridge.paper.websocket;

import dev.consti.commandbridge.paper.Main;
import dev.consti.commandbridge.paper.core.Runtime;
import dev.consti.commandbridge.paper.utils.SchedulerAdapter;
import dev.consti.foundationlib.json.MessageBuilder;
import dev.consti.foundationlib.json.MessageParser;
import dev.consti.foundationlib.logging.Logger;
import dev.consti.foundationlib.websocket.SimpleWebSocketClient;
import org.bukkit.entity.Player;

public class Client extends SimpleWebSocketClient {
    private final Logger logger;

    public Client(Logger logger, String secret) {
        super(logger, secret);
        this.logger = logger;
    }

    @Override
    protected void onMessage(String message) {
        MessageParser parser = new MessageParser(message);
        logger.debug("Received payload: {}", message);
        try {
            String type = parser.getType();
            switch (type) {
                case "command" -> handleCommandRequest(message);
                case "system" -> handleSystemRequest(message);
                default -> {
                    logger.warn("Invalid type: {}", type);
                    sendError("Invalid type: " + type);
                }
            }
        } catch (Exception e) {
            logger.error("Error while processing message: {}",
                    logger.getDebug() ? e : e.getMessage());
            sendError("Internal client error: " + e.getMessage());
        }
    }

    @Override
    protected void afterAuth() {
        logger.debug("Sending server information's...");
        MessageBuilder builder = new MessageBuilder("system");
        builder.addToBody("channel", "name");
        builder.addToBody("name", Runtime.getInstance().getConfig().getKey("config.yml", "client-id"));
        logger.debug("Sending payload: {}", builder.build().toString());
        sendMessage(builder.build());
    }

    private void handleCommandRequest(String message) {
        logger.debug("Handling command response");
        Runtime.getInstance().getCommandExecutor().dispatchCommand(message);
    }

    private void handleSystemRequest(String message) {
        logger.debug("Handling system request");
        MessageParser parser = new MessageParser(message);
        String channel = parser.getBodyValueAsString("channel");
        String status = parser.getStatus();

        switch (channel) {
            case "error" -> logger.warn("Error from server '{}' : {}", parser.getBodyValueAsString("server"), status);
            case "info" -> logger.info("Info from server '{}' : {}", parser.getBodyValueAsString("server"), status);
            case "task" -> systemTask(parser, status);
            default -> logger.warn("Invalid channel: {}", channel);
        }
    }

    private void systemTask(MessageParser parser, String status) {
        String task = parser.getBodyValueAsString("task");
        switch (task) {
            case "reload" ->
                Runtime.getInstance().getScriptUtils().unloadCommands(() -> new SchedulerAdapter(Main.getInstance())
                        .runLater(Runtime.getInstance().getGeneralUtils()::reloadAll, 10L));
            case "reconnect" -> Ping.reconnect(logger);
            default -> logger.warn("Invalid task: {}", task);
        }
    }

    public void sendError(String errorMessage) {
        MessageBuilder builder = new MessageBuilder("system");
        builder.addToBody("channel", "error").withStatus(errorMessage).addToBody("client",
                Runtime.getInstance().getConfig().getKey("config.yml", "client-id"));
        sendMessage(builder.build());
    }

    public void sendInfo(String infoMessage) {
        MessageBuilder builder = new MessageBuilder("system");
        builder.addToBody("channel", "info").withStatus(infoMessage).addToBody("client",
                Runtime.getInstance().getConfig().getKey("config.yml", "client-id"));
        sendMessage(builder.build());
    }

    public void sendTask(String task, String status) {
        MessageBuilder builder = new MessageBuilder("system");
        builder.addToBody("channel", "task").addToBody("task", task)
                .addToBody("client", Runtime.getInstance().getConfig().getKey("config.yml", "client-id"))
                .withStatus(status);
        sendMessage(builder.build());
    }

    public void sendCommand(String command, String client, String target, Player executor) {
        MessageBuilder builder = new MessageBuilder("command");
        builder.addToBody("command", command).addToBody("client", client).addToBody("target", target);

        if (target.equals("player")) {
            builder.addToBody("name", executor.getName()).addToBody("uuid", executor.getUniqueId());
        }
        logger.info("Sending command '{}' to server", command);
        logger.debug("Sending payload: {}", builder.build().toString());
        sendMessage(builder.build());
    }
}
</file>

<file path="velocity/src/main/java/dev/consti/commandbridge/velocity/helper/command/ListCommand.java">
package dev.consti.commandbridge.velocity.helper.command;

import com.mojang.brigadier.builder.LiteralArgumentBuilder;
import com.velocitypowered.api.command.CommandSource;
import dev.consti.foundationlib.logging.Logger;
import net.kyori.adventure.text.Component;
import net.kyori.adventure.text.format.NamedTextColor;

import java.util.Set;

public class ListCommand {
    public static LiteralArgumentBuilder<CommandSource> build(Set<String> connectedClients, Logger logger) {
        return LiteralArgumentBuilder.<CommandSource>literal("list")
                .executes(context -> {
                    CommandSource source = context.getSource();

                    if (!source.hasPermission("commandbridge.admin")) {
                        source.sendMessage(Component.text("You do not have permission to list connected clients", NamedTextColor.RED));
                        return 0;
                    }

                    if (connectedClients.isEmpty()) {
                        source.sendMessage(
                                Component.text("No clients are currently connected").color(NamedTextColor.RED));
                    } else {
                        String clientsString = String.join(", ", connectedClients);
                        source.sendMessage(Component.text("===== Connected Clients =======").color(NamedTextColor.GOLD));
                        source.sendMessage(Component.text(clientsString).color(NamedTextColor.GREEN));
                        source.sendMessage(Component.text("============================").color(NamedTextColor.GOLD));
                    }
                    return 1;
                });
    }
}
</file>

<file path="velocity/src/main/java/dev/consti/commandbridge/velocity/helper/FailureChecker.java">
package dev.consti.commandbridge.velocity.helper;

import com.velocitypowered.api.command.CommandSource;
import com.velocitypowered.api.proxy.ProxyServer;
import dev.consti.commandbridge.velocity.Main;
import dev.consti.commandbridge.velocity.core.Runtime;
import dev.consti.foundationlib.logging.Logger;
import net.kyori.adventure.text.Component;
import net.kyori.adventure.text.format.NamedTextColor;

import java.util.concurrent.TimeUnit;

public class FailureChecker implements Runnable {
    private final Logger logger;
    private final ProxyServer proxy;
    private final Main plugin;
    private final StatusManager statusManager;
    private final CommandSource source;
    private final int maxRetries;
    private final int[] retries;

    public FailureChecker(Logger logger, ProxyServer proxy, Main plugin, StatusManager statusManager, CommandSource source) {
        this.logger = logger;
        this.proxy = proxy;
        this.plugin = plugin;
        this.statusManager = statusManager;
        this.source = source;
        this.maxRetries = Integer.parseInt(Runtime.getInstance().getConfig().getKey("config.yml", "timeout"));
        this.retries = new int[]{0};
    }

    @Override
    public void run() {
        retries[0]++;
        logger.debug("Failure check attempt {}/{}", retries[0], maxRetries);

        try {
            String failedClients = statusManager.checkForFailures();

            if (failedClients == null) {
                source.sendMessage(
                        Component.text("Everything has reloaded successfully!")
                                .color(NamedTextColor.GREEN)
                );
                logger.info("Scripts reloaded successfully");
                statusManager.clearStatusMap();
            } else if (retries[0] >= maxRetries) {
                // Timeout after 8 seconds
                source.sendMessage(
                        Component.text("ReloadCommand failed: " + failedClients)
                                .color(NamedTextColor.RED)
                );
                logger.error("Reload command failed '{}'", failedClients);
                statusManager.clearStatusMap();
            } else {
                proxy.getScheduler().buildTask(plugin, this).delay(1, TimeUnit.SECONDS).schedule();
            }
        } catch (Exception e) {
            logger.error("An error occurred during the reload process: {}", logger.getDebug() ? e : e.getMessage());
            source.sendMessage(
                    Component.text("Reload command failed due to an internal error. Check logs for details")
                            .color(NamedTextColor.RED)
            );
        }
    }
}
</file>

<file path="velocity/src/main/java/dev/consti/commandbridge/velocity/helper/InternalRegistrar.java">
package dev.consti.commandbridge.velocity.helper;

import com.mojang.brigadier.builder.LiteralArgumentBuilder;
import com.mojang.brigadier.tree.LiteralCommandNode;
import com.velocitypowered.api.command.BrigadierCommand;
import com.velocitypowered.api.command.CommandSource;
import com.velocitypowered.api.proxy.ProxyServer;
import dev.consti.commandbridge.velocity.Main;
import dev.consti.commandbridge.velocity.core.Runtime;
import dev.consti.commandbridge.velocity.helper.command.ListCommand;
import dev.consti.commandbridge.velocity.helper.command.ReloadCommand;
import dev.consti.commandbridge.velocity.helper.command.StartCommand;
import dev.consti.commandbridge.velocity.helper.command.StopCommand;
import dev.consti.commandbridge.velocity.helper.command.VersionCommand;
import dev.consti.foundationlib.logging.Logger;
import net.kyori.adventure.text.Component;
import net.kyori.adventure.text.format.NamedTextColor;

import java.util.Set;

public class InternalRegistrar {
    private final Logger logger;
    private final ProxyServer proxy;
    private final Main plugin;
    private final Set<String> connectedClients;

    public InternalRegistrar(Logger logger, ProxyServer proxy, Main plugin, Set<String> connectedClients) {
        this.logger = logger;
        this.proxy = proxy;
        this.plugin = plugin;
        this.connectedClients = connectedClients;
    }

    public void registerCommands() {
        logger.info("Registering commands for CommandBridge...");
        try {
            // Build the main command
            LiteralArgumentBuilder<CommandSource> commandBridgeBuilder = LiteralArgumentBuilder
                    .<CommandSource>literal("commandbridge")
                    .executes(context -> {
                        // Default action, for example show help
                        if (context.getSource().hasPermission("commandbridge.admin")) {
                            return HelpCommand.sendHelpMessage(context.getSource(), logger);
                        }
                        context.getSource().sendMessage(
                                Component.text("You do not have permission to use this command", NamedTextColor.RED));
                        return 0;
                    });

            // Append subcommands
            commandBridgeBuilder.then(ReloadCommand.build(Runtime.getInstance().getGeneralUtils(), logger));
            commandBridgeBuilder.then(VersionCommand.build(logger));
            commandBridgeBuilder.then(HelpCommand.build(logger));
            commandBridgeBuilder.then(ListCommand.build(connectedClients, logger));
            if (logger.getDebug()) {
                commandBridgeBuilder.then(StopCommand.build(logger));
                commandBridgeBuilder.then(StartCommand.build(logger));
            }

            LiteralCommandNode<CommandSource> commandBridgeNode = commandBridgeBuilder.build();

             Runtime.getInstance().getGeneralUtils().setMeta(proxy.getCommandManager()
                    .metaBuilder("commandbridge")
                    .aliases("cb")
                    .plugin(plugin)
                    .build());

            BrigadierCommand brigadierCommand = new BrigadierCommand(commandBridgeNode);
            proxy.getCommandManager().register(Runtime.getInstance().getGeneralUtils().getMeta(), brigadierCommand);
            logger.info("CommandBridge commands registered successfully");
        } catch (Exception e) {
            logger.error("Failed to register CommandBridge commands: {}", logger.getDebug() ? e : e.getMessage());
        }
    }

}
</file>

<file path="wiki/other/contribution-guidelines.md">
---
description: Guidelines and information on contributing to the CommandBridge project.
---

# üíª Contribution Guidelines

Contributions to CommandBridge are welcome! Here‚Äôs how you can help:

* **Reporting Issues or Suggestions**: Use the [GitHub issues page](https://github.com/72-S/CommandBridge/issues) to report bugs, propose new features, or enhance documentation. Clear, detailed reports make it easier to address problems.
* **Submitting Code**: If you are a developer and want to contribute code:
  1. Fork the repository on GitHub and create a new branch for your changes.
  2. Make sure your changes follow the style of the project.
  3. Test your changes in a Velocity+Paper setup if possible.
  4. Submit a Pull Request with a clear description of your changes.
* **Improving Documentation**: If you find something in this documentation that can be improved, feel free to edit the Markdown files and open a pull request, or suggest changes via Discord/issue tracker.
* **Joining the Discussion**: For general ideas or to see planned features, join the [Discord server](https://discord.gg/QPqBYb44ce). There may be existing discussions you can contribute to, or you can start a new one in the appropriate channel.

By contributing, you agree that your contributions will be licensed under the same Apache 2.0 License as the project. The team will review contributions and merge them if they fit well with the project‚Äôs goals.

Thank you for helping make CommandBridge better!
</file>

<file path="paper/src/main/java/dev/consti/commandbridge/paper/command/CommandForwarder.java">
package dev.consti.commandbridge.paper.command;

import org.bukkit.ChatColor;
import org.bukkit.command.CommandSender;
import org.bukkit.entity.Player;

import dev.consti.commandbridge.paper.Main;
import dev.consti.commandbridge.paper.core.Runtime;
import dev.consti.commandbridge.paper.utils.SchedulerAdapter;
import dev.consti.foundationlib.logging.Logger;
import dev.consti.foundationlib.utils.ScriptManager;
import dev.consti.foundationlib.utils.StringParser;
import me.clip.placeholderapi.PlaceholderAPI;

public class CommandForwarder {
    private final Logger logger;
    private final Main plugin;

    public CommandForwarder(Logger logger, Main plugin) {
        this.logger = logger;
        this.plugin = plugin;
    }

    public int executeScriptCommands(CommandSender sender, ScriptManager.ScriptConfig script, String[] args) {
        if (isPermissionDenied(sender, script)) {
            return 0;
        }

        for (ScriptManager.Command cmd : script.getCommands()) {
            logger.debug("Processing command: {}", cmd.getCommand());

            switch (cmd.getTargetExecutor().toLowerCase()) {
                case "player" -> handlePlayerExecutor(cmd, sender, args);
                case "console" -> handleConsoleExecutor(cmd, args);
                default -> logger.warn("Unknown target executor for command: {}", cmd.getCommand());
            }
        }

        return 1;
    }

    private boolean isPermissionDenied(CommandSender sender, ScriptManager.ScriptConfig script) {
        if (!script.shouldIgnorePermissionCheck()
                && !sender.hasPermission("commandbridge.command." + script.getName())) {
            logger.warn("Sender '{}' has no permission to use this command", sender);
            if (!script.shouldHidePermissionWarning()) {
                sender.sendMessage(ChatColor.RED + "You do not have permission to use this command.");
            }
            return true;
        }
        return false;
    }

    private void handlePlayerExecutor(ScriptManager.Command cmd, CommandSender sender, String[] args) {
        if (cmd.isCheckIfExecutorIsPlayer() && !(sender instanceof Player)) {
            logger.warn("This command requires a player as executor, but sender is not a player.");
            sender.sendMessage(
                    ChatColor.RED + "This command requires a player as executor, but source is not a player object");
            return;
        }

        Player player = (Player) sender;
        String parsedCommand = parseCommand(cmd, args, player);

        if (parsedCommand == null)
            return;

        if (cmd.getDelay() > 0) {
            scheduleCommand(cmd, parsedCommand, player);
        } else {
            sendCommand(cmd, parsedCommand, player);
        }
    }

    private void handleConsoleExecutor(ScriptManager.Command cmd, String[] args) {
        String parsedCommand = parseCommand(cmd, args, null);

        if (parsedCommand == null)
            return;

        if (cmd.getDelay() > 0) {
            scheduleCommand(cmd, parsedCommand, null);
        } else {
            sendCommand(cmd, parsedCommand, null);
        }
    }

    private String parseCommand(ScriptManager.Command cmd, String[] args, Player player) {
        StringParser parser = StringParser.create();

        if (player != null && cmd.getTargetExecutor().equals("player")) {
            addPlayerPlaceholders(parser, player);
        } else {
            return parser.parsePlaceholders(cmd.getCommand(), args);
        }

        try {
            String parsedCommand = parser.parsePlaceholders(cmd.getCommand(), args);
            if (Runtime.getInstance().getStartup().isPlaceholderAPI()) {
                parsedCommand = PlaceholderAPI.setPlaceholders(player, parsedCommand);
            }
            return parsedCommand;

        } catch (Exception e) {
            logger.error("Error occurred while parsing command: {}", logger.getDebug() ? e : e.getMessage());
            if (player != null) {
                player.sendMessage(ChatColor.RED + "Error occurred while parsing command");
            }
            Runtime.getInstance().getClient().sendError("Error occurred while parsing commands");
        }

        return null;
    }

    private void addPlayerPlaceholders(StringParser parser, Player player) {
        logger.debug("Adding placeholders for player: {}", player.getName());
        parser.addPlaceholder("%cb_player%", player.getName());
        parser.addPlaceholder("%cb_uuid%", player.getUniqueId().toString());
        parser.addPlaceholder("%cb_world%", player.getWorld().getName());
    }

    private void scheduleCommand(ScriptManager.Command cmd, String command, Player player) {
        logger.debug("Scheduling command '{}' with delay: {} seconds", cmd.getCommand(), cmd.getDelay());
        if (player != null) {
            player.sendMessage("Scheduling command with '" + cmd.getDelay() + "' seconds");
        }
        new SchedulerAdapter(plugin).runLater(() -> sendCommand(cmd, command, player), cmd.getDelay() * 20L);
    }

    private void sendCommand(ScriptManager.Command cmd, String command, Player player) {
        // List<String> targetServers = cmd.getTargetServerIds();
        //
        // if (targetServers.isEmpty()) {
        // logger.warn("No target servers defined for command: {}", cmd.getCommand());
        // return;
        // }
        //
        // for (String serverId : targetServers) {
        // try {
        // logger.info("Sending command to server '{}' as {}", serverId, player == null
        // ? "console" : "player");
        // Runtime.getInstance().getClient().sendCommand(command, serverId,
        // cmd.getTargetExecutor(), player);
        // } catch (Exception e) {
        // logger.error("Failed to send command to server '{}': {}", serverId,
        // e.getMessage());
        // }
        // }

        logger.info("Sending command to server as {}", player == null ? "console" : "player");
        Runtime.getInstance().getClient().sendCommand(command, "", cmd.getTargetExecutor(), player);
    }
}
</file>

<file path="paper/src/main/java/dev/consti/commandbridge/paper/core/Startup.java">
package dev.consti.commandbridge.paper.core;

import org.bukkit.Bukkit;

import dev.consti.commandbridge.paper.Main;
import dev.consti.commandbridge.paper.utils.SchedulerAdapter;
import dev.consti.foundationlib.logging.Logger;
import dev.consti.foundationlib.utils.VersionChecker;

public class Startup {
    private final Logger logger;
    private final Runtime runtime;
    private boolean placeholderAPI = false;

    public Startup(Logger logger) {
        this.logger = logger;
        this.runtime = Runtime.getInstance();
    }

    public void start() {
        try {
            runtime.getConfig().copyConfig("bukkit-config.yml", "config.yml");
            runtime.getConfig().loadAllConfigs();

            boolean debugMode = Boolean.parseBoolean(runtime.getConfig().getKey("config.yml", "debug"));
            logger.setDebug(debugMode);
            if (SchedulerAdapter.isFolia()) {
                logger.info("Running on Folia!");
            } else {
                logger.info("Running on Paper!");
            }
            logger.info("Debug mode set to: {}", debugMode);

            logger.debug("Copying default scripts...");
            runtime.getScriptUtils().copyDefaultScript("bukkit-example.yml", "example.yml");
            runtime.getScriptUtils().loadAllScripts();

            logger.debug("Connecting to WebSocket server...");
            runtime.getClient().connect(
                    runtime.getConfig().getKey("config.yml", "remote"),
                    Integer.parseInt(runtime.getConfig().getKey("config.yml", "port")));

            logger.debug("Setting up version checker...");
            VersionChecker.setProjectId("wIuI4ru2");

            logger.debug("Checking for updates...");
            checkForUpdates();

            logger.debug("Registering internal commands...");
            runtime.getGeneralUtils().registerCommands();

            if (Bukkit.getPluginManager().isPluginEnabled("PlaceholderAPI")) {
                logger.info("Hooked into PlaceholderAPI ‚Äî external placeholders enabled");
                placeholderAPI = true;
            } else {
                logger.warn("PlaceholderAPI not found ‚Äî using internal placeholder system only");
                placeholderAPI = false;
            }
        } catch (Exception e) {
            logger.error("Failed to initialize CommandBridge: {}",
                    logger.getDebug() ? e : e.getMessage());
        }
    }

    public boolean isPlaceholderAPI() {
        return placeholderAPI;
    }

    public void stop() {
        try {
            logger.debug("Disconnecting from WebSocket server...");
            runtime.getClient().disconnect();
        } catch (Exception e) {
            logger.error("Failed to stop CommandBridge: {}",
                    logger.getDebug() ? e : e.getMessage());
        }
    }

    private void checkForUpdates() {
        String currentVersion = Main.getVersion();
        logger.debug("Current version: {}", currentVersion);
        new Thread(() -> {
            try {
                String latestVersion = VersionChecker.getLatestVersion();
                if (latestVersion == null) {
                    logger.warn("Unable to check for updates");
                    return;
                }
                if (VersionChecker.isNewerVersion(latestVersion, currentVersion)) {
                    logger.warn("A new version is available: {}", latestVersion);
                    logger.warn("Please download the latest release: {}", VersionChecker.getDownloadUrl());
                    runtime.getClient().sendError("Please update CommandBridge");
                } else {
                    logger.info("You are running the latest version: {}", currentVersion);
                }
            } catch (Exception e) {
                logger.error("Error while checking for updates: {}",
                        logger.getDebug() ? e : e.getMessage());
            }
        }).start();
    }
}
</file>

<file path="paper/src/main/java/dev/consti/commandbridge/paper/Main.java">
package dev.consti.commandbridge.paper;

import java.io.InputStream;
import java.util.Properties;

import org.bukkit.plugin.java.JavaPlugin;

import dev.consti.commandbridge.paper.core.Runtime;
import dev.consti.foundationlib.logging.Logger;
import dev.jorel.commandapi.CommandAPI;
import dev.jorel.commandapi.CommandAPIBukkitConfig;

public class Main extends JavaPlugin {
    private static Main instance;
    private final Logger logger;

    public Main() {
        instance = this;
        logger = Runtime.getInstance().getLogger();
    }
    
    public static String getVersion() {
        try (InputStream input = Main.class.getClassLoader().getResourceAsStream("plugin.properties")) {
            if (input == null) {
                return "Unknown";
            }
            Properties properties = new Properties();
            properties.load(input);
            return properties.getProperty("plugin.version", "Unknown");
        } catch (Exception e) {
            e.printStackTrace();
            return "Unknown";
        }
    }

    public static Main getInstance() {
        return instance;
    }


    @Override
    public void onLoad() {
        CommandAPI.onLoad(new CommandAPIBukkitConfig(this).verboseOutput(false).usePluginNamespace().silentLogs(true).skipReloadDatapacks(true).shouldHookPaperReload(false));
    }
    @Override
    public void onEnable() {
        CommandAPI.onEnable();
        logger.info("Initializing CommandBridge...");
        Runtime.getInstance().getStartup().start();
    }

    @Override
    public void onDisable() {
        CommandAPI.onDisable();
        logger.info("Stopping CommandBridge...");
        Runtime.getInstance().getStartup().stop();
    }

}
</file>

<file path="paper/src/main/resources/plugin.yml">
name: CommandBridge
version: 2.2.1
main: dev.consti.commandbridge.paper.Main
author: 72-S
api-version: '1.20'
folia-supported: true
softdepend:
- PlaceholderAPI
</file>

<file path="velocity/src/main/resources/velocity-example.yml">
##########################################################################
# EXAMPLE CONFIGURATION
# This file demonstrates how to dispatch a command to the Velocity server,
# where the commands are executed on the Bukkit servers.
##########################################################################

# The name of the command to be dispatched.
# This is the identifier for the command configuration.
name: examplecommand

# Enable or disable this command.
# Set to true to allow the command to be executed, or false to disable it.
enabled: true

# Ignore permission checks for this command.
# Set to true to bypass permission validation, or false to enforce it.
ignore-permission-check: false

# Hide permission warnings when the executor does not have the required permissions.
# Set to true to suppress warnings, or false to show them.
hide-permission-warning: false

# A list of commands to execute on the target servers.
commands:
  # Command 1
  - command: 'say Hello, world!'  # The command string to be executed (use single quotes).
    delay: 0                      # Delay (in seconds) before executing the command.
    target-client-ids:            # List of target server IDs where the command will be executed.
      - 'lobby'
      - 'survival'
    target-executor: 'player'     # Who executes the command: 'player' or 'console'.
    wait-until-player-is-online: true  # If true, waits until the player is online to execute.
    check-if-executor-is-player: true  # If true, ensures the executor is a player.
    check-if-executor-is-on-server: true # If true, ensures the executor is online on the server.

  # Command 2
  - command: 'say I love Coding!' # The command string to be executed (use single quotes).
    delay: 0                      # Delay (in seconds) before executing the command.
    target-client-ids:            # List of target server IDs where the command will be executed.
      - 'lobby'
    target-executor: 'player'     # Who executes the command: 'player' or 'console'.
    wait-until-player-is-online: true  # If true, waits until the player is online to execute.
    check-if-executor-is-player: false # If true, ensures the executor is a player.
    check-if-executor-is-on-server: false # If true, ensures the executor is online on the server.
</file>

<file path="wiki/SUMMARY.md">
# Table of contents

* [üëã Welcome](README.md)
* [ü§ñ Use cases](use-cases.md)

## Getting Started

* [üìò Requirements](getting-started/requirements.md)
* [üì© Installation](getting-started/installation.md)
* [‚öôÔ∏è Plugin setup](getting-started/plugin-setup.md)

## Scripts

* [üìú Scripts Guide](scripts/guide.md)

## Troubleshooting

* [‚ùå Common issues](troubleshooting/common-issues.md)
* [üì≠ Support resources](troubleshooting/support-resources.md)

## Other

* [üíª Contribution Guidelines](other/contribution-guidelines.md)
* [üî¢ Data collection](other/data-collection.md)
</file>

<file path="server.sh">
#!/bin/bash

# Server paths
SERVER1_DIR="/mnt/Storage/Server-TEST/CommandBridge/Velocity/"
SERVER2_DIR="/mnt/Storage/Server-TEST/CommandBridge/Paper/"

# Server JAR files
SERVER1_JAR="velocity-3.3.0-SNAPSHOT-436.jar"
SERVER2_JAR="paper-1.20-17.jar"

# Function to run a server
run_server() {
  local server_dir=$1
  local server_jar=$2
  local extra_args=$3
  cd "$server_dir" || exit
  java -Xmx1024M -Xms1024M -jar "$server_jar" $extra_args
}

# Start the first server in the current terminal
echo "Starting Velocity server in the current terminal..."
run_server "$SERVER1_DIR" "$SERVER1_JAR" &

# Start the second server in a new Kitty terminal with nogui flag
echo "Starting Bukkit server in a new Kitty terminal..."
kitty bash -c "cd '$SERVER2_DIR' && java -Xmx1024M -Xms1024M -jar '$SERVER2_JAR' nogui; exec bash"

# Wait for the first server to complete
wait
</file>

<file path="velocity/src/main/resources/velocity-config.yml">
# Server Configuration File

# General debug mode.
# Set to true for detailed logs and diagnostics, or false for standard logging.
debug: false

# Unique identifier for the server.
# This helps distinguish between multiple servers in a network setup.
server-id: "main"

# The host address the server will bind to.
# You can use "127.0.0.1" to bind to the localhost interface (local connections only),
# or "0.0.0.0" to bind to all available network interfaces (accepts connections from all IPs).
# Change only if you know what you're doing.
host: "0.0.0.0"

# Server Address Name (SAN).
# Specify your server's public IP or domain name here if accessible from external networks.
# Example: san: "152.248.198.124"
san: ""

# The port number the server will listen on.
# Ensure this port is open and not used by another service.
port: 8080

# Timeout for the reload command.
# Specifies the time (in seconds) for clients to respond during a reload operation.
# Each second represents one retry for the client to send a successful request.
# If the client does not respond successfully within the timeout duration, the operation will fail.
# Example: timeout: 8 means clients have up to 8 seconds (or 8 tries) to respond.
timeout: 8
</file>

<file path="velocity/src/main/java/dev/consti/commandbridge/velocity/command/CommandRegistrar.java">
package dev.consti.commandbridge.velocity.command;

import java.util.HashMap;
import java.util.Map;

import com.mojang.brigadier.arguments.StringArgumentType;
import com.mojang.brigadier.builder.LiteralArgumentBuilder;
import com.mojang.brigadier.builder.RequiredArgumentBuilder;
import com.velocitypowered.api.command.BrigadierCommand;
import com.velocitypowered.api.command.CommandMeta;
import com.velocitypowered.api.command.CommandSource;
import com.velocitypowered.api.proxy.ProxyServer;

import dev.consti.commandbridge.velocity.core.Runtime;
import dev.consti.commandbridge.velocity.util.ProxyUtils;
import dev.consti.foundationlib.logging.Logger;
import dev.consti.foundationlib.utils.ScriptManager;

public class CommandRegistrar {
    private final Logger logger;
    private final ProxyServer proxy;
    private final CommandForwarder helper;
    private final Map<String, CommandMeta> registeredCommands = new HashMap<>();

    public CommandRegistrar(Logger logger) {
        this.logger = logger;
        this.proxy = ProxyUtils.getProxyServer();
        this.helper = Runtime.getInstance().getHelper();
    }


    public void unregisterAllCommands() {
        for (String command : registeredCommands.keySet()) {
            try {
                CommandMeta commandMeta = registeredCommands.get(command);
                proxy.getCommandManager().unregister(commandMeta);
                logger.debug("Unregistered command: {}", command);
            } catch (Exception e) {
                logger.error("Failed to unregister command '{}' : {}",
                        command,
                        logger.getDebug() ? e : e.getMessage()
                );
            }
        }
        registeredCommands.clear();
        logger.info("All registered commands have been unregistered.");
    }


    public void registerCommand(ScriptManager.ScriptConfig script) {
        String commandName = script.getName();
        try {
            LiteralArgumentBuilder<CommandSource> commandBuilder = LiteralArgumentBuilder.<CommandSource>literal(commandName)
                    .executes(context -> {
                        logger.debug("Executing base command: {}", commandName);
                        return helper.executeScriptCommands(context.getSource(), script, new String[0]);
                    });
            RequiredArgumentBuilder<CommandSource, String> argsArgument =
                    RequiredArgumentBuilder.<CommandSource, String>argument("args", StringArgumentType.greedyString())
                            .executes(context -> {
                                String argsString = context.getArgument("args", String.class);
                                logger.debug("Command '{}' called with arguments: {}", commandName, argsString);
                                String[] args = argsString.split(" ");
                                return helper.executeScriptCommands(context.getSource(), script, args);
                            });
            commandBuilder.then(argsArgument);

            // LiteralCommandNode<CommandSource> rootNode = commandBuilder.build();
            BrigadierCommand brigadierCommand = new BrigadierCommand(commandBuilder.build());
            CommandMeta commandMeta = proxy.getCommandManager().metaBuilder(commandName).build();

            proxy.getCommandManager().register(commandMeta, brigadierCommand);
            registeredCommands.put(commandName, commandMeta);
        } catch (Exception e) {
            logger.error(
                    "Failed to register command '{}' : {}",
                    commandName,
                    logger.getDebug() ? e : e.getMessage()
            );
        }
    }


}
</file>

<file path="velocity/src/main/java/dev/consti/commandbridge/velocity/helper/command/ReloadCommand.java">
package dev.consti.commandbridge.velocity.helper.command;

import com.mojang.brigadier.builder.LiteralArgumentBuilder;
import com.velocitypowered.api.command.CommandSource;
import dev.consti.commandbridge.velocity.core.Runtime;
import dev.consti.commandbridge.velocity.util.GeneralUtils;
import dev.consti.foundationlib.json.MessageBuilder;
import dev.consti.foundationlib.logging.Logger;
import net.kyori.adventure.text.Component;
import net.kyori.adventure.text.format.NamedTextColor;

public class ReloadCommand {

    public static LiteralArgumentBuilder<CommandSource> build(GeneralUtils utils, Logger logger) {
        return LiteralArgumentBuilder.<CommandSource>literal("reload")
                .executes(context -> {
                    CommandSource source = context.getSource();
                    if (!source.hasPermission("commandbridge.admin")) {
                        source.sendMessage(
                                Component.text("You do not have permission to reload the plugin", NamedTextColor.RED));
                        return 0;
                    }

                    try {
                        // Logic from original reload command
                        Runtime.getInstance().getRegistrar().unregisterAllCommands();
                        logger.debug("All commands have been unregistered");

                        Runtime.getInstance().getConfig().reload();
                        logger.debug("Configuration files have been reloaded");

                        logger.setDebug(
                                Boolean.parseBoolean(Runtime.getInstance().getConfig().getKey("config.yml", "debug")));
                        logger.info("Debug mode set to: {}", Runtime.getInstance().getConfig().getKey("config.yml", "debug"));

                        Runtime.getInstance().getScriptUtils().reload();
                        logger.debug("Scripts have been reloaded");

                        Runtime.getInstance().getGeneralUtils().unregisterCommands();
                        logger.debug("Internal commands have been unregistered");

                        Runtime.getInstance().getGeneralUtils().registerCommands();
                        logger.debug("Internal commands have been registered");

                        MessageBuilder builder = new MessageBuilder("system");
                        builder.addToBody("channel", "task").addToBody("task", "reload").addToBody("server",
                                Runtime.getInstance().getConfig().getKey("config.yml", "server-id"));

                        Runtime.getInstance().getServer().broadcastServerMessage(builder.build());
                        logger.debug("Sending payload: {}", builder.build());
                        source.sendMessage(
                                Component.text("Waiting for clients to respond...")
                                        .color(NamedTextColor.YELLOW));
                        logger.debug("Waiting for clients to respond...");
                        utils.startFailureCheck(source);
                        return 1;
                    } catch (Exception e) {
                        logger.error("An error occurred during the reload process: {}", e.getMessage(), e);
                        source.sendMessage(
                                Component.text("ReloadCommand failed due to an internal error. Check logs for details")
                                        .color(NamedTextColor.RED));
                    }
                    return 1;

                });
    }
}
</file>

<file path="velocity/src/main/java/dev/consti/commandbridge/velocity/core/Startup.java">
package dev.consti.commandbridge.velocity.core;


import dev.consti.commandbridge.velocity.Main;
import dev.consti.commandbridge.velocity.websocket.Server;
import dev.consti.foundationlib.logging.Logger;
import dev.consti.foundationlib.utils.VersionChecker;

public class Startup {
    private final Logger logger;
    private final Runtime runtime;
    private boolean placeholderAPI = false;

    public Startup(Logger logger) {
        this.logger = logger;
        this.runtime = Runtime.getInstance();
    }

    public void start() {
        try {
            runtime.getConfig().copyConfig("velocity-config.yml", "config.yml");
            runtime.getConfig().loadAllConfigs();
            runtime.getConfig().loadSecret();

            boolean debugMode = Boolean.parseBoolean(runtime.getConfig().getKey("config.yml", "debug"));
            logger.setDebug(debugMode);
            logger.debug("Debug mode set to: {}", debugMode);

            logger.debug("Copying default scripts...");
            runtime.getScriptUtils().copyDefaultScript("velocity-example.yml", "example.yml");
            runtime.getScriptUtils().loadAllScripts();

            logger.debug("Starting WebSocket server...");
            runtime.getServer().startServer(
                    Integer.parseInt(runtime.getConfig().getKey("config.yml", "port")),
                    runtime.getConfig().getKey("config.yml", "host"),
                    runtime.getConfig().getKey("config.yml", "san")
            );

            logger.debug("Setting up version checker...");
            VersionChecker.setProjectId("wIuI4ru2");

            logger.debug("Checking for updates...");
            checkForUpdates();

            logger.debug("Registering internal commands...");
            runtime.getGeneralUtils().registerCommands();

            if (Main.getInstance().proxy.getPluginManager().getPlugin("papiproxybridge").isPresent()) {
                logger.info("Hooked into PapiProxyBridge ‚Äî PlaceholderAPI placeholders enabled");
                placeholderAPI = true;
            } else {
                logger.warn("PapiProxyBridge not found ‚Äî using internal placeholder system only");
                placeholderAPI = false;
            }
        } catch (Exception e) {
            logger.error("Failed to initialize CommandBridge: {}",
                    logger.getDebug() ? e : e.getMessage()
            );
        }
    }

    public boolean isPlaceholderAPI() {
        return placeholderAPI;
    }

    public void stop() {
        try {
            Server server = runtime.getServer();
            logger.debug("Stopping WebSocket server...");
            for (String conn : server.getConnectedClients()) {
                runtime.getServer().sendTask(server.getWebSocket(conn), "reconnect", "closed");
            }
            runtime.getServer().stopServer(0);
        } catch (Exception e) {
            logger.error("Failed to stop CommandBridge: {}", logger.getDebug() ? e : e.getMessage());
        }
    }

    private void checkForUpdates() {
        String currentVersion = Main.getVersion();
        logger.debug("Current version: {}", currentVersion);
        new Thread(() -> {
            try {
                String latestVersion = VersionChecker.getLatestVersion();
                if (latestVersion == null) {
                    logger.warn("Unable to check for updates");
                    return;
                }
                if (VersionChecker.isNewerVersion(latestVersion, currentVersion)) {
                    logger.warn("A new version is available: {}", latestVersion);
                    logger.warn("Please download the latest release: {}", VersionChecker.getDownloadUrl());
                } else {
                    logger.info("You are running the latest version: {}", currentVersion);
                }
            } catch (Exception e) {
                logger.error("Error while checking for updates: {}", logger.getDebug() ? e : e.getMessage());
            }
        }).start();
    }
}
</file>

<file path="velocity/src/main/java/dev/consti/commandbridge/velocity/command/CommandForwarder.java">
package dev.consti.commandbridge.velocity.command;

import java.util.List;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.TimeUnit;

import com.velocitypowered.api.command.CommandSource;
import com.velocitypowered.api.proxy.Player;
import com.velocitypowered.api.proxy.ProxyServer;

import dev.consti.commandbridge.velocity.Main;
import dev.consti.commandbridge.velocity.core.Runtime;
import dev.consti.commandbridge.velocity.util.ProxyUtils;
import dev.consti.foundationlib.logging.Logger;
import dev.consti.foundationlib.utils.ScriptManager;
import dev.consti.foundationlib.utils.StringParser;
import net.kyori.adventure.text.Component;
import net.kyori.adventure.text.format.NamedTextColor;
import net.william278.papiproxybridge.api.PlaceholderAPI;

public class CommandForwarder {
    private final Logger logger;
    private final ProxyServer proxy;
    private final Main plugin;

    public CommandForwarder(Logger logger, Main plugin) {
        this.logger = logger;
        this.proxy = ProxyUtils.getProxyServer();
        this.plugin = plugin;
    }

    public int executeScriptCommands(CommandSource source, ScriptManager.ScriptConfig script, String[] args) {
        logger.debug("Executing script commands for script: {}", script.getName());

        if (isPermissionDenied(source, script)) {
            return 0;
        }

        for (ScriptManager.Command cmd : script.getCommands()) {
            logger.debug("Processing command: {}", cmd.getCommand());

            switch (cmd.getTargetExecutor().toLowerCase()) {
                case "player" -> handlePlayerExecutor(cmd, source, args);
                case "console" -> handleConsoleExecutor(cmd, source, args);
                default -> logger.warn("Unknown target executor for command: {}", cmd.getCommand());
            }
        }

        logger.info("Script commands executed successfully for command: {}", script.getName());
        return com.mojang.brigadier.Command.SINGLE_SUCCESS;
    }

    private boolean isPermissionDenied(CommandSource source, ScriptManager.ScriptConfig script) {
        if (!script.shouldIgnorePermissionCheck()
                && !source.hasPermission("commandbridge.command." + script.getName())) {
            logger.warn("Sender '{}' has no permission to use this command", source);
            if (!script.shouldHidePermissionWarning()) {
                source.sendMessage(
                        Component.text("You do not have permission to use this command", NamedTextColor.RED));
            }
            return true;
        }
        return false;
    }

    private void handlePlayerExecutor(ScriptManager.Command cmd, CommandSource source, String[] args) {
        if (cmd.isCheckIfExecutorIsPlayer() && !(source instanceof Player)) {
            logger.warn("This command requires a player as executor, but source is not a player");
            source.sendMessage(
                    Component.text("This command requires a player as executor, but source is not a player object",
                            NamedTextColor.RED));
            return;
        }

        Player player = (Player) source;

        // Check if the player is on the required server if needed
        if (cmd.isCheckIfExecutorIsOnServer() && !isPlayerOnTargetServer(player, cmd)) {
            logger.warn("Player '{}' is not on the required server for this command.", player.getUsername());
            source.sendMessage(Component.text("Player " + player.getUsername() + " is not on the required server",
                    NamedTextColor.YELLOW));
            return;
        }

        parseCommand(cmd, args, player).thenAccept(parsedCommand -> {
            if (parsedCommand == null)
                return;

            if (cmd.getDelay() > 0) {
                scheduleCommand(cmd, parsedCommand, args, player, 0);
            } else {
                sendCommand(cmd, parsedCommand, args, player, 0);
            }
        });

    }

    private void handleConsoleExecutor(ScriptManager.Command cmd, CommandSource source, String[] args) {

        parseCommand(cmd, args, null).thenAccept(parsedCommand -> {
            if (parsedCommand == null)
                return;

            if (cmd.getDelay() > 0) {
                scheduleCommand(cmd, parsedCommand, args, null, 0);
            } else {
                sendCommand(cmd, parsedCommand, args, null, 0);
            }
        });

    }

    private boolean isPlayerOnTargetServer(Player player, ScriptManager.Command cmd) {
        return player.getCurrentServer()
                .map(serverConn -> cmd.getTargetClientIds().contains(serverConn.getServerInfo().getName()))
                .orElse(false);
    }

    private CompletableFuture<String> parseCommand(ScriptManager.Command cmd, String[] args, Player player) {
        StringParser parser = StringParser.create();

        if (player != null && cmd.getTargetExecutor().equals("player")) {
            addPlayerPlaceholders(parser, player);
        } else {
            return CompletableFuture.completedFuture(parser.parsePlaceholders(cmd.getCommand(), args));
        }

        try {
            String parsedCommand = parser.parsePlaceholders(cmd.getCommand(), args);

            if (Runtime.getInstance().getStartup().isPlaceholderAPI()) {
                return PlaceholderAPI.createInstance()
                        .formatPlaceholders(parsedCommand, player.getUniqueId())
                        .exceptionally(e -> {
                            logger.error("PlaceholderAPI error: {}", logger.getDebug() ? e : e.getMessage());
                            return parsedCommand; // Fallback
                        });
            }

            return CompletableFuture.completedFuture(parsedCommand);
        } catch (Exception e) {
            logger.error("Error occurred while parsing command: {}", logger.getDebug() ? e : e.getMessage());
            if (player != null) {
                player.sendMessage(Component.text("Error occurred while parsing command").color(NamedTextColor.RED));
            }
            for (String conn : cmd.getTargetClientIds()) {
                Runtime.getInstance().getServer().sendError(
                        Runtime.getInstance().getServer().getWebSocket(conn),
                        "Error occurred while parsing commands");
            }

            return CompletableFuture.completedFuture(null);
        }
    }

    private void addPlayerPlaceholders(StringParser parser, Player player) {
        logger.debug("Adding placeholders for player: {}", player.getUsername());
        parser.addPlaceholder("%player%", player.getUsername());
        parser.addPlaceholder("%uuid%", player.getUniqueId().toString());
        parser.addPlaceholder("%server%", player.getCurrentServer()
                .map(srv -> srv.getServerInfo().getName())
                .orElse("defaultServerName"));
    }

    private void scheduleCommand(ScriptManager.Command cmd, String command, String[] args, Player player,
            int retryCount) {
        logger.debug("Scheduling command '{}' with delay: {} seconds", cmd.getCommand(), cmd.getDelay());
        proxy.getScheduler().buildTask(plugin, () -> sendCommand(cmd, command, args, player, retryCount))
                .delay(cmd.getDelay(), TimeUnit.SECONDS)
                .schedule();
    }

    private void sendCommand(ScriptManager.Command cmd, String command, String[] args, Player player, int retryCount) {
        logger.debug("Executing command: {} with retryCount: {}", cmd.getCommand(), retryCount);

        // Prevent infinite loops
        if (retryCount >= 30) {
            logger.warn("Max retries reached for command: {}", cmd.getCommand());
            if (player != null) {
                player.sendMessage(Component.text("Max retries reached", NamedTextColor.YELLOW));
            }
            return;
        }

        // If we need the player to be online, check it here
        if (cmd.shouldWaitUntilPlayerIsOnline() && "player".equalsIgnoreCase(cmd.getTargetExecutor())) {
            if (player == null || !player.isActive()) {
                logger.warn("Player is not online. Retrying command: {}", cmd.getCommand());
                player.sendMessage(Component.text("Player is not online. Retrying command", NamedTextColor.YELLOW));
                proxy.getScheduler().buildTask(plugin, () -> sendCommand(cmd, command, args, player, retryCount + 1))
                        .delay(1, TimeUnit.SECONDS)
                        .schedule();
                return;
            }
        }

        List<String> targetClients = cmd.getTargetClientIds();
        if (targetClients.isEmpty()) {
            logger.warn("No target clients defined for command: {}", cmd.getCommand());
            if (player != null) {
                player.sendMessage(
                        Component.text("No target clients are defined for this command", NamedTextColor.RED));
            }
            return;
        }

        for (String clientId : targetClients) {
            if (Runtime.getInstance().getServer().isServerConnected(clientId)) {
                logger.info("Sending command to client '{}' as {}", clientId, player == null ? "console" : "player");
                Runtime.getInstance().getServer().sendCommand(command, clientId, cmd.getTargetExecutor(), player);
            } else {
                logger.warn("Client '{}' not found", clientId);
                if (player != null) {
                    player.sendMessage(Component.text("Client '" + clientId + "' not found", NamedTextColor.RED));
                }
            }
        }
    }
}
</file>

<file path="velocity/src/main/java/dev/consti/commandbridge/velocity/websocket/Server.java">
package dev.consti.commandbridge.velocity.websocket;

import java.util.*;

import com.velocitypowered.api.proxy.Player;

import dev.consti.commandbridge.velocity.core.Runtime;
import dev.consti.foundationlib.json.MessageBuilder;
import dev.consti.foundationlib.json.MessageParser;
import dev.consti.foundationlib.logging.Logger;
import dev.consti.foundationlib.websocket.SimpleWebSocketServer;
import io.netty.channel.Channel;

public class Server extends SimpleWebSocketServer {
    private final Logger logger;
    private final Map<String, Channel> clientConnections = new HashMap<>();

    public Server(Logger logger, String secret) {
        super(logger, secret);
        super.addHttpHandler(Runtime.getInstance().getHttpServer());
        this.logger = logger;
    }

    @Override
    protected void onMessage(Channel webSocket, String message) {
        MessageParser parser = new MessageParser(message);
        logger.debug("Received message: {}", message);
        try {
            String type = parser.getType();
            switch (type) {
                case "command" -> handleCommandRequest(webSocket, message);
                case "system" -> handleSystemRequest(webSocket, message);
                default -> {
                    logger.warn("Invalid type: {}", type);
                    sendError(webSocket, "Invalid type: " + type);
                }
            }
        } catch (Exception e) {
            logger.error("Error while processing message: {}",
                    logger.getDebug() ? e : e.getMessage());
            sendError(webSocket, "Internal server error: " + e.getMessage());
        }
    }

    @Override
    protected void onConnectionClose(Channel conn, int code, String reason) {
        String clientAddress = conn.remoteAddress().toString();

        if (getConnections().contains(conn)) {
            String disconnectedClientName = clientConnections.entrySet().stream()
                    .filter(entry -> entry.getValue().equals(conn))
                    .map(Map.Entry::getKey)
                    .findFirst()
                    .orElse(null);

            logger.info("Client '{}' disconnected", clientAddress);
            if (disconnectedClientName != null) {
                clientConnections.remove(disconnectedClientName);
                logger.debug("Removed disconnected client: {}", disconnectedClientName);
            } else {
                logger.warn("Disconnected WebSocket client '{}' not found in client connections map.", clientAddress);
            }
        } 
    }

    private void handleCommandRequest(Channel webSocket, String message) {
        logger.debug("Handling command request");
        Runtime.getInstance().getCommandExecutor().dispatchCommand(message);
    }

    private void handleSystemRequest(Channel webSocket, String message) {
        logger.debug("Handling system request");
        MessageParser parser = new MessageParser(message);
        String channel = parser.getBodyValueAsString("channel");
        String name = parser.getBodyValueAsString("name");
        String client = parser.getBodyValueAsString("client");
        String status = parser.getStatus();

        switch (channel) {
            case "name" -> {
                if (name != null) {
                    clientConnections.put(name, webSocket);
                    logger.info("Added connected client: {}", name);
                } else {
                    logger.warn("Client did not provide 'name' in system request");
                }
            }
            case "error" -> logger.warn("Error Message from client '{}' : {}", client, status);
            case "info" -> logger.info("Info from client '{}' : {}", client, status);
            case "task" -> systemTask(parser, status, client);
            default -> logger.warn("Invalid channel: {}", channel);
        }
    }

    private void systemTask(MessageParser parser, String status, String client) {
        String task = parser.getBodyValueAsString("task");
        switch (task) {
            case "reload" -> Runtime.getInstance().getGeneralUtils().addClientToStatus(client, parser.getStatus());
            default -> logger.warn("Invalid task: {}", task);
        }
    }

    public void sendError(Channel webSocket, String errorMessage) {
        MessageBuilder builder = new MessageBuilder("system");
        builder.addToBody("channel", "error")
                .addToBody("server", Runtime.getInstance().getConfig().getKey("config.yml", "server-id"))
                .withStatus(errorMessage);
        sendMessage(builder.build(), webSocket);
    }

    public void sendInfo(Channel webSocket, String infoMessage) {
        MessageBuilder builder = new MessageBuilder("system");
        builder.addToBody("channel", "info")
                .addToBody("server", Runtime.getInstance().getConfig().getKey("config.yml", "server-id"))
                .withStatus(infoMessage);
        sendMessage(builder.build(), webSocket);
    }

    public void sendTask(Channel webSocket, String task, String status) {
        MessageBuilder builder = new MessageBuilder("system");
        builder.addToBody("channel", "task").addToBody("task", task)
                .addToBody("server", Runtime.getInstance().getConfig().getKey("config.yml", "server-id"))
                .withStatus(status);
        sendMessage(builder.build(), webSocket);
    }

    public void sendCommand(String command, String client, String target, Player executor) {
        Channel conn = clientConnections.get(client);
        if (conn == null) {
            logger.warn("Client '{}' is not connected, cannot send message.", client);
            return;
        }

        MessageBuilder builder = new MessageBuilder("command");
        builder.addToBody("command", command).addToBody("client", client).addToBody("target", target);

        if (target.equals("player")) {
            builder.addToBody("name", executor.getUsername()).addToBody("uuid", executor.getUniqueId());
        }
        logger.info("Sending command '{}' to client: {}", command, client);
        logger.debug("Sending payload: {}", builder.build().toString());
        sendMessage(builder.build(), conn);
    }

    public boolean isServerConnected(String clientName) {
        boolean exists = clientConnections.containsKey(clientName);
        logger.debug("Checking if client '{}' is connected: {}", clientName, exists);
        return exists;
    }

    public Set<String> getConnectedClients() {
        return clientConnections.keySet();
    }

    public Channel getWebSocket(String client) {
        return clientConnections.get(client);
    }

}
</file>

<file path="CHANGELOG.md">
**[v2.2.1] - 2025-04-25**

- Fixed issues with the Metrics class causing runtime errors.
- Resolved an "Internal Server Error" when players lacked permission.
- Added full support for Folia, ensuring compatibility and improved performance.
</file>

<file path="velocity/src/main/java/dev/consti/commandbridge/velocity/Main.java">
package dev.consti.commandbridge.velocity;

import java.io.InputStream;
import java.util.Properties;

import org.bstats.velocity.Metrics;

import com.google.inject.Inject;
import com.velocitypowered.api.event.Subscribe;
import com.velocitypowered.api.event.connection.PostLoginEvent;
import com.velocitypowered.api.event.proxy.ProxyInitializeEvent;
import com.velocitypowered.api.event.proxy.ProxyShutdownEvent;
import com.velocitypowered.api.plugin.Plugin;
import com.velocitypowered.api.proxy.Player;
import com.velocitypowered.api.proxy.ProxyServer;

import dev.consti.commandbridge.velocity.core.Runtime;
import dev.consti.commandbridge.velocity.util.ProxyUtils;
import dev.consti.foundationlib.logging.Logger;
import dev.consti.foundationlib.utils.VersionChecker;
import net.kyori.adventure.text.Component;
import net.kyori.adventure.text.event.ClickEvent;
import net.kyori.adventure.text.format.NamedTextColor;
import net.kyori.adventure.text.format.TextDecoration;

@Plugin(id = "commandbridge", name = "CommandBridge", version = "Unknown", authors = "72-S")
public class Main {
    private static Main instance;
    public final ProxyServer proxy;
    private final Logger logger;
    private final Metrics.Factory metricsFactory;

    @Inject
    public Main(ProxyServer proxy, Logger bLogger, Metrics.Factory metricsFactory) {
        this.proxy = proxy;
        this.logger = Runtime.getInstance().getLogger();
        instance = this;
        this.metricsFactory = metricsFactory;
        ProxyUtils.setProxyServer(proxy);
    }

    public static Main getInstance() {
        return instance;
    }

    public static String getVersion() {
        try (InputStream input = Main.class.getClassLoader().getResourceAsStream("plugin.properties")) {
            if (input == null) {
                return "Unknown";
            }
            Properties properties = new Properties();
            properties.load(input);
            return properties.getProperty("plugin.version", "Unknown");
        } catch (Exception e) {
            e.printStackTrace();
            return "Unknown";
        }
    }

    @Subscribe
    public void onProxyInitialization(ProxyInitializeEvent event) {
        logger.info("Initializing CommandBridge...");
        Runtime.getInstance().getStartup().start();
        int pluginId = 22008;
        metricsFactory.make(this, pluginId);

    }

    @Subscribe
    public void onProxyShutdown(ProxyShutdownEvent event) {
        logger.info("Stopping CommandBridge...");
        Runtime.getInstance().getStartup().stop();
    }

    @Subscribe
    public void onPlayerJoin(PostLoginEvent event) {
        Player player = event.getPlayer();
        if (player == null) {
            logger.warn("PostLoginEvent triggered with a null player object.");
            return;
        }

        if (player.hasPermission("commandbridge.admin")) {
            logger.debug("Player '{}' has admin permissions. Checking for updates...", player.getUsername());

            proxy.getScheduler().buildTask(this, () -> {
                String currentVersion = Main.getVersion();
                String latestVersion = VersionChecker.getLatestVersion();

                if (latestVersion == null) {
                    player.sendMessage(Component.text("Unable to check for updates.").color(NamedTextColor.RED));
                    logger.warn("Update check failed: Unable to retrieve the latest version.");
                    return;
                }

                if (VersionChecker.isNewerVersion(latestVersion, currentVersion)) {
                    player.sendMessage(Component.text("A new version of CommandBridge is available: " + latestVersion)
                            .color(NamedTextColor.RED));
                    player.sendMessage(Component.text("Please download the latest release: ")
                            .append(Component.text("here")
                                    .color(NamedTextColor.BLUE)
                                    .decorate(TextDecoration.UNDERLINED)
                                    .clickEvent(ClickEvent.openUrl(VersionChecker.getDownloadUrl()))));
                    logger.debug("Notified player '{}' about the new version: {}", player.getUsername(), latestVersion);
                } else {
                    logger.debug("Player '{}' is running the latest version: {}", player.getUsername(), currentVersion);
                }
            }).schedule();
        } else {
            logger.debug("Player {} does not have admin permissions. No update check performed.", player.getUsername());
        }
    }
}
</file>

<file path="paper/src/main/resources/paper-plugin.yml">
name: CommandBridge
version: 2.2.1
main: dev.consti.commandbridge.paper.Main
author: 72-S
api-version: '1.20'
folia-supported: true
dependencies:
  server:
    PlaceholderAPI:
      load: BEFORE
      required: false
</file>

<file path="paper/build.gradle.kts">
buildscript {
    repositories {
      mavenCentral()
    }
    dependencies {
        classpath("org.yaml:snakeyaml:2.3")

    }
}

import org.yaml.snakeyaml.DumperOptions
import org.yaml.snakeyaml.Yaml

plugins {
    id("java")
    id("com.gradleup.shadow") version "8.3.3"
}

val pversion: String by gradle.extra

group = "dev.consti"
version = pversion

repositories {
    mavenCentral()
    maven { url = uri("https://repo.papermc.io/repository/maven-public/") }
    maven { url = uri("https://repo.codemc.org/repository/maven-public/") }
    maven { url = uri("https://hub.spigotmc.org/nexus/content/repositories/snapshots/")}
    maven { url = uri("https://repo.extendedclip.com/releases/")}
    maven {
        name = "GitHubPackages"
        url = uri("https://maven.pkg.github.com/72-S/FoundationLib")
        credentials {
            username = "72-S"
            password = System.getenv("GITHUB_TOKEN")
        }
    }
}

java {
    toolchain {
        languageVersion.set(JavaLanguageVersion.of(21))
    }
}

dependencies {
    // compileOnly("io.papermc.paper:paper-api:1.20-R0.1-SNAPSHOT")
    // compileOnly("org.spigotmc:spigot-api:1.20-R0.1-SNAPSHOT")
    compileOnly("dev.folia:folia-api:1.20.1-R0.1-SNAPSHOT")
    implementation("org.ow2.asm:asm:9.7")
    implementation("dev.consti:foundationlib:2.2.3")
    implementation("dev.jorel:commandapi-bukkit-shade:9.7.0")
    compileOnly("dev.jorel:commandapi-annotations:9.7.0")
    compileOnly("me.clip:placeholderapi:2.11.6")
    annotationProcessor("dev.jorel:commandapi-annotations:9.7.0")
}


tasks.register("modifyPaperPluginYaml") {
    doLast {
        
        val yamlFile = file("src/main/resources/paper-plugin.yml") 

        if (yamlFile.exists()) {
            println("Found paper-plugin.yml")

            val options = DumperOptions().apply {
                defaultFlowStyle = DumperOptions.FlowStyle.BLOCK
            }
            val yaml = Yaml(options)

            val yamlContent = yaml.load<Map<String, Any>>(yamlFile.reader()).toMutableMap()

            yamlContent["version"] = pversion

            yamlFile.writer().use { writer ->
                yaml.dump(yamlContent, writer)
            }

            println("paper-plugin.yml updated successfully with version ${pversion}")
        } else {
            println("paper-plugin.yml not found!")
        }
    }
}

tasks.register("modifyLegacyPluginYaml") {
    doLast {
        
        val yamlFile = file("src/main/resources/plugin.yml") 

        if (yamlFile.exists()) {
            println("Found legacy plugin.yml")

            val options = DumperOptions().apply {
                defaultFlowStyle = DumperOptions.FlowStyle.BLOCK
            }
            val yaml = Yaml(options)

            val yamlContent = yaml.load<Map<String, Any>>(yamlFile.reader()).toMutableMap()

            yamlContent["version"] = pversion

            yamlFile.writer().use { writer ->
                yaml.dump(yamlContent, writer)
            }

            println("legacy plugin.yml updated successfully with version ${pversion}")
        } else {
            println("legacy plugin.yml not found!")
        }
    }
}

tasks.named("processResources") {
    dependsOn("modifyPaperPluginYaml")
    dependsOn("modifyLegacyPluginYaml")
}
</file>

<file path="settings.gradle.kts">
rootProject.name = "CommandBridge"
include("paper", "velocity")


gradle.extra["pversion"] = "2.2.1"


gradle.extra["pluginType"] = "release"

gradle.extra["pluginVersions"] = listOf("1.20", "1.20.1", "1.20.2", "1.20.3", "1.20.4", "1.20.5", "1.20.6", "1.21", "1.21.1", "1.21.2", "1.21.3", "1.21.4")

gradle.extra["pluginLoaders"] = listOf("folia", "paper", "purpur", "velocity", "bukkit", "spigot", "waterfall")
</file>

<file path="velocity/build.gradle.kts">
import com.google.gson.JsonObject
import com.google.gson.JsonParser
import java.nio.file.Files

plugins {
    id("java")
}

val pversion: String by gradle.extra

group = "dev.consti"
version = pversion

repositories {
    mavenCentral()
    maven { url = uri("https://repo.papermc.io/repository/maven-public/") }
    maven { url = uri("https://repo.william278.net/releases/") }
    maven {
        name = "GitHubPackages"
        url = uri("https://maven.pkg.github.com/72-S/FoundationLib")
        credentials {
            username = "72-S"
            password = System.getenv("GITHUB_TOKEN")
        }
    }
}

java {
    toolchain {
        languageVersion.set(JavaLanguageVersion.of(21))
    }
}

dependencies {
    compileOnly("com.velocitypowered:velocity-api:3.4.0-SNAPSHOT")
    annotationProcessor("com.velocitypowered:velocity-api:3.4.0-SNAPSHOT")
    implementation("dev.consti:foundationlib:2.2.3")
    compileOnly("net.william278:papiproxybridge:1.7.2")
    implementation("org.bstats:bstats-velocity:3.1.0")
}


tasks.register("modifyVelocityPluginJson") {
    doLast {
        val jsonFile = layout.buildDirectory.file("classes/java/main/velocity-plugin.json").get().asFile
        if (jsonFile.exists()) {
            println("Found velocity-plugin.json")

            val jsonContent = Files.readString(jsonFile.toPath())
            val jsonObject = JsonParser.parseString(jsonContent).asJsonObject

            jsonObject.addProperty("version", pversion)

            Files.writeString(jsonFile.toPath(), jsonObject.toString())
            println("velocity-plugin.json updated successfully with version ${pversion}")
        } else {
            println("velocity-plugin.json not found")
        }
    }
}

tasks.register("generatePluginProperties") {
    doLast {
        println("Generating plugin.properties file")

        val propertiesFile = layout.buildDirectory.file("resources/main/plugin.properties").get().asFile
        propertiesFile.parentFile.mkdirs()
        propertiesFile.writeText("""
            plugin.version=${pversion}
        """.trimIndent())

        println("Successfully generated plugin.properties file")
    }
}


tasks.named("processResources") {
    dependsOn("generatePluginProperties")
    finalizedBy("modifyVelocityPluginJson")
}
</file>

<file path="build.gradle.kts">
plugins {
    id("java")
    id("com.gradleup.shadow") version "8.3.3"
    id("maven-publish")
    id("com.modrinth.minotaur") version "2.+"
}

val pversion: String by gradle.extra
val pluginType: String by gradle.extra
val pluginVersions: List<String> by gradle.extra
val pluginLoaders: List<String> by gradle.extra

group = "dev.consti"

version = pversion

repositories {
    mavenCentral()
    maven {
        name = "GitHubPackages"
        url = uri("https://maven.pkg.github.com/72-S/FoundationLib")
        credentials {
            username = "72-S"
            password = System.getenv("GITHUB_TOKEN")
        }
    }
    maven { url = uri("https://repo.william278.net/releases/") }
    maven { url = uri("https://repo.extendedclip.com/releases/") }
}

dependencies {
    implementation(project(":paper"))
    implementation(project(":velocity"))
}

java { toolchain { languageVersion.set(JavaLanguageVersion.of(21)) } }

tasks {
    // Configure the existing shadowJar task, don't register a new one
    shadowJar {
        dependsOn(":paper:shadowJar")
        manifest { attributes["paperweight-mappings-namespace"] = "spigot" }

        relocate("dev.jorel.commandapi", "dev.consti.commandbridge.commandapi")
        relocate("org.bstats", "dev.consti.commandbridge.bstats")

        // Include the compiled outputs of core, paper, and velocity
        from(
                project(":paper")
                        .takeIf { it.plugins.hasPlugin("java") }
                        ?.sourceSets
                        ?.main
                        ?.get()
                        ?.output
                        ?: files()
        )
        from(
                project(":velocity")
                        .takeIf { it.plugins.hasPlugin("java") }
                        ?.sourceSets
                        ?.main
                        ?.get()
                        ?.output
                        ?: files()
        )

        configurations = listOf(project.configurations.runtimeClasspath.get())
        mergeServiceFiles()
    }

    val copyToPaperPlugins by
            registering(Copy::class) {
                dependsOn(shadowJar)
                from(shadowJar.get().outputs.files)
                into("/mnt/Storage/Server-TEST/CommandBridge/Paper/plugins")
            }

    val copyToVelocityPlugins by
            registering(Copy::class) {
                dependsOn(shadowJar)
                from(shadowJar.get().outputs.files)
                into("/mnt/Storage/Server-TEST/CommandBridge/Velocity/plugins")
            }

    register("dev") { dependsOn(copyToPaperPlugins, copyToVelocityPlugins) }
}

afterEvaluate {
    modrinth {
        token.set(System.getenv("MODRINTH_TOKEN"))
        projectId.set("wIuI4ru2")
        versionName.set("CommandBridge $pversion")
        changelog.set(rootProject.file("CHANGELOG.md").readText())
        versionNumber.set(pversion)
        versionType.set(pluginType)
        uploadFile.set(tasks.shadowJar)
        gameVersions.set(pluginVersions)
        loaders.set(pluginLoaders)
        debugMode.set(false)
    }
}
</file>

</files>
